<!DOCTYPE HTML>
<html lang="zh_CN" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Substrate Contracts Book</title>
        
        <meta name="robots" content="noindex" />
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        
        <link rel="icon" href="favicon.svg">
        
        
        <link rel="shortcut icon" href="favicon.png">
        
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="introduction.html"><strong aria-hidden="true">1.</strong> 介绍</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="contracts/overview.html"><strong aria-hidden="true">1.1.</strong> 合约综述</a></li><li class="chapter-item expanded "><a href="contracts/model.html"><strong aria-hidden="true">1.2.</strong> 合约模型</a></li><li class="chapter-item expanded "><a href="contracts/language.html"><strong aria-hidden="true">1.3.</strong> 合约语言（框架）</a></li><li class="chapter-item expanded "><a href="contracts/wasm_first_step.html"><strong aria-hidden="true">1.4.</strong> Wasm初步</a></li></ol></li><li class="chapter-item expanded "><a href="pallet-contracts/introduction.html"><strong aria-hidden="true">2.</strong> pallet-contracts 合约模块</a></li><li class="chapter-item expanded "><a href="ink/introduction.html"><strong aria-hidden="true">3.</strong> ink!</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ink/tutorial.html"><strong aria-hidden="true">3.1.</strong> ink! tutorial</a></li><li class="chapter-item expanded "><a href="ink/framework.html"><strong aria-hidden="true">3.2.</strong> ink! 框架</a></li><li class="chapter-item expanded "><a href="ink/edsl-basic.html"><strong aria-hidden="true">3.3.</strong> ink! eDSL基础元素</a></li><li class="chapter-item expanded "><a href="ink/call-contracts.html"><strong aria-hidden="true">3.4.</strong> ink! 跨合约调用</a></li><li class="chapter-item expanded "><a href="ink/ink-solidity.html"><strong aria-hidden="true">3.5.</strong> ink! 与solidity的对比</a></li><li class="chapter-item expanded "><a href="ink/cargo-contract.html"><strong aria-hidden="true">3.6.</strong> cargo-contract</a></li><li class="chapter-item expanded "><a href="ink/trap.html"><strong aria-hidden="true">3.7.</strong> ink! 当前的坑</a></li></ol></li><li class="chapter-item expanded "><a href="ask/introduction.html"><strong aria-hidden="true">4.</strong> Ask!</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ask/tutorial.html"><strong aria-hidden="true">4.1.</strong> tutorial</a></li><li class="chapter-item expanded "><a href="ask/design.html"><strong aria-hidden="true">4.2.</strong> 设计</a></li><li class="chapter-item expanded "><a href="ask/basics.html"><strong aria-hidden="true">4.3.</strong> 基础</a></li><li class="chapter-item expanded "><a href="ask/example.html"><strong aria-hidden="true">4.4.</strong> example</a></li></ol></li><li class="chapter-item expanded "><a href="solang/introduction.html"><strong aria-hidden="true">5.</strong> Solang</a></li><li class="chapter-item expanded "><a href="redspot/introduction.html"><strong aria-hidden="true">6.</strong> Redspot</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="redspot/tutorial.html"><strong aria-hidden="true">6.1.</strong> tutorial</a></li><li class="chapter-item expanded "><a href="redspot/overview.html"><strong aria-hidden="true">6.2.</strong> 介绍</a></li><li class="chapter-item expanded "><a href="redspot/configuration.html"><strong aria-hidden="true">6.3.</strong> 配置</a></li><li class="chapter-item expanded "><a href="redspot/runtime-environment.html"><strong aria-hidden="true">6.4.</strong> Runtime Environment</a></li><li class="chapter-item expanded "><a href="redspot/console.html"><strong aria-hidden="true">6.5.</strong> 控制台console</a></li><li class="chapter-item expanded "><a href="redspot/q-and-a.html"><strong aria-hidden="true">6.6.</strong> Q &amp; A</a></li><li class="chapter-item expanded "><a href="redspot/plugin.html"><strong aria-hidden="true">6.7.</strong> plugin</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="redspot/plugin/redspot-chai.html"><strong aria-hidden="true">6.7.1.</strong> @redspot/chai</a></li><li class="chapter-item expanded "><a href="redspot/plugin/redspot-gas-reporter.html"><strong aria-hidden="true">6.7.2.</strong> @redspot/gas-reporter</a></li><li class="chapter-item expanded "><a href="redspot/plugin/redspot-patract.html"><strong aria-hidden="true">6.7.3.</strong> @redspot/patract</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="europa/introduction.html"><strong aria-hidden="true">7.</strong> Europa</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="europa/tutorial.html"><strong aria-hidden="true">7.1.</strong> tutorial</a></li><li class="chapter-item expanded "><a href="europa/execution_info.html"><strong aria-hidden="true">7.2.</strong> 合约执行日志信息解释</a></li><li class="chapter-item expanded "><a href="europa/sample.html"><strong aria-hidden="true">7.3.</strong> 根据信息定位问题示例</a></li><li class="chapter-item expanded "><a href="europa/wasm_executor.html"><strong aria-hidden="true">7.4.</strong> Wasm executor</a></li><li class="chapter-item expanded "><a href="europa/wasm_backtrace.html"><strong aria-hidden="true">7.5.</strong> Wasm Backtrace</a></li></ol></li><li class="chapter-item expanded "><a href="zkmega/introduction.html"><strong aria-hidden="true">8.</strong> zkMega</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="zkmega/tutorial.html"><strong aria-hidden="true">8.1.</strong> tutorial</a></li><li class="chapter-item expanded "><a href="zkmega/contract.html"><strong aria-hidden="true">8.2.</strong> 零知识合约</a></li><li class="chapter-item expanded "><a href="zkmega/example.html"><strong aria-hidden="true">8.3.</strong> 使用案例</a></li><li class="chapter-item expanded "><a href="zkmega/benchmark.html"><strong aria-hidden="true">8.4.</strong> benchmark</a></li></ol></li><li class="chapter-item expanded "><a href="himalia/introduction.html"><strong aria-hidden="true">9.</strong> Himalia</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="himalia/tutorial.html"><strong aria-hidden="true">9.1.</strong> tutorial</a></li><li class="chapter-item expanded "><a href="himalia/go-patract.html"><strong aria-hidden="true">9.2.</strong> go-patract</a></li><li class="chapter-item expanded "><a href="himalia/py-patract.html"><strong aria-hidden="true">9.3.</strong> py-patract</a></li></ol></li><li class="chapter-item expanded "><a href="metis/introduction.html"><strong aria-hidden="true">10.</strong> Metis</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="metis/tokens.html"><strong aria-hidden="true">10.1.</strong> Tokens</a></li><li class="chapter-item expanded "><a href="metis/access-control.html"><strong aria-hidden="true">10.2.</strong> Access Control</a></li></ol></li><li class="chapter-item expanded "><a href="carpo/introduction.html"><strong aria-hidden="true">11.</strong> Carpo</a></li><li class="chapter-item expanded "><a href="patract/introduction.html"><strong aria-hidden="true">12.</strong> Patract</a></li><li class="chapter-item expanded "><a href="elara/introduction.html"><strong aria-hidden="true">13.</strong> Elara</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="elara/tutorial.html"><strong aria-hidden="true">13.1.</strong> tutorial</a></li><li class="chapter-item expanded "><a href="elara/design.html"><strong aria-hidden="true">13.2.</strong> 设计</a></li><li class="chapter-item expanded "><a href="elara/API.html"><strong aria-hidden="true">13.3.</strong> API</a></li></ol></li><li class="chapter-item expanded "><a href="patra-store/introduction.html"><strong aria-hidden="true">14.</strong> PatraStore</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="patra-store/overview.html"><strong aria-hidden="true">14.1.</strong> Overview</a></li><li class="chapter-item expanded "><a href="patra-store/getting-starter.html"><strong aria-hidden="true">14.2.</strong> Getting Starter</a></li><li class="chapter-item expanded "><a href="patra-store/publish-dapps.html"><strong aria-hidden="true">14.3.</strong> 发布DApp</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                        
                        <button id="language-toggle" class="icon-button" type="button" title="Select language" aria-label="Select language" aria-haspopup="true" aria-expanded="false" aria-controls="language-list">
                            <i class="fa fa-globe"></i>
                        </button>
                        <ul id="language-list" class="language-popup" aria-label="Languages" role="menu">
                          
                            <li role="none"><a href="../en_US/print.html"><button role="menuitem" class="language" id="light">English</button></a></li>
                          
                            <li role="none"><a href="../zh_CN/print.html"><button role="menuitem" class="language" id="light">中文</button></a></li>
                          
                        </ul>
                        
                    </div>

                    <h1 class="menu-title">Substrate 合约书</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#substrate-合约书" id="substrate-合约书">Substrate 合约书</a></h1>
<h2><a class="header" href="#介绍" id="介绍">介绍</a></h2>
<p>本书用于介绍 Substrate 中与合约体系相关的一系列知识。</p>
<p>本书由 Patract (<a href="https://patract.io/">https://patract.io/</a>) @ <a href="https://github.com/patractlabs">patractlabs</a> 主导编写，由 Aten @ <a href="https://github.com/atenjin">atenjin</a> 负责。</p>
<p>本书仓库位于 <a href="https://github.com/patractlabs/substrate-contracts-book">https://github.com/patractlabs/substrate-contracts-book</a>，欢迎有志之士一起为本书做出贡献。</p>
<p>本书主体包含三类：</p>
<ul>
<li>运行合约的合约平台（模块）</li>
<li>编写合约的语言</li>
<li>帮助合约开发的工具们</li>
</ul>
<p>其中由于<code>pallet-evm</code>（即EVM/solidity体系的合约）在以太坊生态中已有比较丰富的资料，故不会在本合约书中当做重点讲解。而另外的合约体系如<code>pallet-actor</code>，或<code>libra</code>移植合约平台等皆处于比较早期的研究阶段，因此也不会作为本书的重点。</p>
<p><strong>本书当前主要以<code>pallet-contracts</code> （即WASM合约）作为主体进行介绍。</strong></p>
<p>因此本书内容包含：</p>
<ul>
<li>运行合约的合约平台（模块）
<ul>
<li><code>pallet-contracts</code></li>
</ul>
</li>
<li>编写合约的语言
<ul>
<li><code>ink!</code></li>
<li><code>Ask!</code></li>
<li><code>Solang</code></li>
</ul>
</li>
<li>帮助合约开发的工具们
<ul>
<li><code>Redspot</code></li>
<li><code>Europa</code></li>
<li><code>Elara</code></li>
<li>等等</li>
</ul>
</li>
</ul>
<p>为了让合约开发者更好的理解<code>pallet-contracts</code>模块与WASM合约的运行方式，本书也会涉及一些WASM的介绍以及区块链合约模型的介绍。</p>
<h1><a class="header" href="#合约综述" id="合约综述">合约综述</a></h1>
<p>区块链运行合约的模型从本质上可以认为是 “区块链的环境（分布式共识系统）”+“能运行一段逻辑的平台”，例如</p>
<ul>
<li>比特币的模型可以拆成区块模型/PoW + 比特币脚本</li>
<li>以太坊的模型可以拆成区块，状态模型/PoW + EVM</li>
<li>Substrate的模型可以拆成区块，状态模型/Bft共识 + Runtime</li>
</ul>
<p>因此一般来说，我们可以将区块链的模型拆成</p>
<ul>
<li>运行区块链的底层系统：提供分布式可信环境</li>
<li>链的业务逻辑：运行在这个可信环境中</li>
</ul>
<p>而由于区块链系统的特性，要求对<strong>相同的代码，相同的状态，执行的结果一定需要一致</strong>，因此在提供“链的业务逻辑”这一层，为了保证执行结果的一致性，要求整个运行环境必须是“<strong>无副作用的</strong>”，因此不会因为运行节点的不一致（指不是同一个节点）而导致运行的结果不一致。</p>
<p>因此为了保证这种特性，绝大部分区块链都会采用<strong>沙盒/虚拟机的模型</strong>加上裁剪一些功能来做到。</p>
<p>“运行合约的平台”即是一种链的业务逻辑，且这种业务逻辑<strong>特殊在其上面可运行的代码是开放的，合约内容不受链本身控制</strong>。因此对于这种情况，更需要一种“沙盒”的环境来隔离各个合约之间的运行。</p>
<h2><a class="header" href="#什么是沙盒虚拟机" id="什么是沙盒虚拟机">什么是沙盒（虚拟机）</a></h2>
<p>“沙盒”在计算机领域中的概念很广泛，而在区块链中，一般而言沙盒都会由一个虚拟机去运行（因为使用虚拟机最容易模拟沙盒的环境）。</p>
<p>因此不同的链就会采用不同的虚拟机来运行合约的沙盒：</p>
<ul>
<li>
<p>Ethereum：</p>
<p>Gavin Wood 写的黄皮书提出了EVM的模型，创建了EVM虚拟机的概念并拟定了EVM的OP_CODE。之后设计了Solidity编译到OP_CODE，才有了Ethereum的整个生态。相当于Ethereum处理区块链的合约沙盒模型，从零到一构建所有设施。因此Solidity的语法以及EVM能做的事对比现在的区块链显得<strong>十分简陋</strong>（例如solidity的语法，EVM的栈深限制等等），但其作为<strong>先行者开创了区块链合约虚拟机模型先河</strong>。</p>
</li>
<li>
<p>Fabric:</p>
<p>作为联盟链，在使用场景上与公有链存在区别。因此Fabric提出链码的概念，并将链码运行在了docker中。docker就是比较重的一种虚拟机（相对于EVM而言），因此与EVM比较，Fabric的链码可以做到比Solidity更多的事，当然相对的，其运行的代价与EVM相比就高得多。</p>
</li>
<li>
<p>EOS：</p>
<p>EOS采用了Wasm作为合约的虚拟机，也是当时EOS的卖点。相比于运行Solidity的EVM，EOS的Wasm虚拟机的运行效率高了许多，以C++作为编译到Wasm的语言也天然拉近了许多传统的开发者。EOS作为Wasm虚拟机的先行者，在当时已经体现出Wasm相对于EVM的优势，但是由于其合约模型的设计（见下一章节）的缺陷以及当时环境的约束，再加上EOS并非真正的去中心化系统，导致EOS并没有很好的发挥出Wasm合约系统的能力。</p>
</li>
<li>
<p>Substrate 的<code>pallet-contracts</code>：</p>
<p><code>pallet-contracts</code>采用了Wasm虚拟机来运行合约，当前出于安全考量只采用了<code>Wasmi</code>解释器来执行Wasm。但其合约模型与EVM的合约模型近似（见下一章节）。Wasm虚拟机与EVM同样具有启动快，随用随丢的特性，具备高性能和高扩展性的同时又不像docker， JVM一样太过庞大。因此Wasm慢慢在除了浏览器环境以外的更多场景被采用，例如边缘计算，热更新等等。所以当前越来越多的新区块链在需要一个沙盒环境时会将Wasm虚拟机作为主要方案。另一方面Wasm也具备从不同语言编译到Wasm的特性，例如<code>rust</code>，<code>assemblyscript</code>，<code>c++</code>等等，可以吸引到各类开发者加入到合约开发过程中。</p>
</li>
<li>
<p>其他：</p>
<p>其他区块链为了完成这个“沙盒”的目标也会有各自的方案，有的联盟链采用了裁剪过的JVM，有的公链采用了<code>RISC-V</code>的虚拟机，有的链采用了从零设计一个虚拟机（如libra）。这些方案各自有各自的需求与特性，但从模型上而言，无论什么方案，最终目标都是为了提供一个虚拟机环境以运行合约沙盒。</p>
</li>
</ul>
<h2><a class="header" href="#运行合约的沙盒" id="运行合约的沙盒">运行合约的沙盒</a></h2>
<p>上文已描述链的业务逻辑大部分会运行于沙盒的系统中，且“运行合约”这种业务逻辑更是需要沙盒隔离。而另一方面Substrate的runtime就是一个沙盒环境（运行于Wasm中），因此在Substrate的合约模块（<code>pallet-emv</code>，<code>pallet-contracts</code>），就是需要在一个沙盒环境中运行另一个沙盒，如下图所示：</p>
<p><img src="contracts/./imgs/overview_module.jpg" alt="overview" /></p>
<p>其中：</p>
<ul>
<li>左边是以太坊模型，表示每运行一个合约，需要在链的平台上启动一个EVM虚拟机去运行</li>
<li>右边是Substrate模型，我们当前已知Substrate的链的业务逻辑是运行在Wasm虚拟机当中的：
<ul>
<li><code>pallet-EVM</code>：将以太坊的EVM编译到了Runtime Wasm当中，因此每运行一个合约实际上与以太坊一致，创建了一个EVM虚拟机去运行。如果链是以Wasm形态运行，即是在Wasm虚拟机中生成了一个EVM虚拟机去运行。</li>
<li><code>pallet-contracts</code>：Wasm合约使用Wasm虚拟机运行合约，与<code>pallet-evm</code>不同的地方是，如果链是以Wasm形态运行，Wasm合约的虚拟机是跳出当前Runtime Wasm虚拟机重新创建了一个新的Wasm虚拟机运行。
<ul>
<li>当前（在substrate的提交之前 <a href="https://github.com/paritytech/substrate/commit/0b0d124d5f9be89f614f2be8e9da038fcb9f540e"><code>0b0d124d</code></a>）Runtime的Wasm虚拟机推荐采用的是<code>Wasmtime</code>而<code>pallet-contracts</code>合约<strong>只能</strong>采用<code>Wasmi</code>。</li>
<li><code>pallet-contracts</code>也可以使用<code>Wasmtime</code>执行，但是当前parity认为<code>Wasmtime</code>不可控性比较大，因此暂时还未采用<code>Wasmtime</code>。当前他们有相关计划，也有原型代码来使用<code>Wasmtime</code>运行<code>pallet-contracts</code>的合约。（注1）</li>
</ul>
</li>
</ul>
</li>
<li>总之运行合约的过程中，大部分链都采用了一种沙盒的模型去运行合约。而对于EVM，<code>pallet-contracts</code>模型而言，是<strong>每运行一个合约就会创建一个虚拟机</strong>。</li>
</ul>
<h2><a class="header" href="#注解" id="注解">注解</a></h2>
<ol>
<li><code>Wasmtime</code>是实现了JIT的Wasm虚拟机，而<code>Wasmi</code>是纯解释器型的Wasm虚拟机。</li>
<li><code>Wasmtime</code>的执行效率比<code>Wasmi</code>高很多。</li>
</ol>
<h1><a class="header" href="#合约模型" id="合约模型">合约模型</a></h1>
<p>在已经具备合约及合约沙盒的概念后，我们就可以开始讨论合约模型的概念了。</p>
<p>合约沙盒只是代表运行合约的环境，而合约是以什么方式运行的，合约和合约是怎么交互的，合约是怎么与链的数据互动的，这些问题就归属于合约模型问题。</p>
<p>换句话说，<strong>合约模型就是合约是以什么模型运行在合约沙盒/虚拟机中的</strong>。</p>
<p><img src="contracts/./imgs/model.jpg" alt="" /></p>
<p>如图所示，合约模型与合约虚拟机本质上是可以解耦的，其中关系只存在合约虚拟机是否能支持上层所需要的合约模型，例如：</p>
<ul>
<li>Bitcoin 的虚拟机就是比特币脚本的栈执行器，由于执行器设计是非图灵完备的OP_CODE，因此对于上层的合约模型只能支持Bitcoin的脚本。</li>
<li>Ethereum 跟随Bitcoin的灵感，设计了具备图灵完备的OP_CODE，即EVM虚拟机（Ethereum Virtual Machine）。但是EVM的OP_CODE比较简陋，且只有栈的设计，没有堆的概念。但是EVM引入了读写状态的OP_CODE，因此从虚拟机机制上对合约模型可以支持状态模型。因此EVM也被看做一个执行状态转换的状态转换机（如Gavin Wood撰写的以太坊黄皮书中所描述的）。状态模型实际上是比较通用的抽象模型，绝大多数模型都可以用状态模型模拟（如在状态模型中构建UTXO模型），因此从理论上来说，只要继续完善EVM的OP_CODE，EVM的上层同样可以构建出其他合约模型。</li>
<li>libra 认为区块链的核心在于资产的处理，因此提出了Move的虚拟机模型（Move Virtual Machine (MVM)）来从虚拟机上限定合约的模型，可以理解为是一种特化逻辑过的OP_CODE集合。因此MVM的上层只能运行Move模型。</li>
</ul>
<p>通过以上讨论，我们可以认识到合约模型的概念，并且理解到虚拟机对上层合约模型的限制，因此接下来就可以讨论Wasm虚拟机可以运行的合约模型以及<code>pallet-contracts</code>的合约模型构成。</p>
<h2><a class="header" href="#wasm-虚拟机" id="wasm-虚拟机">Wasm 虚拟机</a></h2>
<p>Wasm是一种在基于栈的虚拟机上运行的二进制的指令格式。（WebAssembly (abbreviated Wasm) is a binary instruction format for a stack-based virtual machine, from <a href="https://webassembly.org/">https://webassembly.org/</a>）因此Wasm的模型和主流计算机程序的模型结构比较相似。另一方面Wasm被设计成为了一种比较通用的形式，且设计了WASI并支持了运行环境自由定义<code>host function</code>，因此虽然Wasm从浏览器发展而来，但是当前的使用场景已经不限于浏览器，开始在边缘计算，热更新，Serverless平台等发挥效果。</p>
<p>若以指令的完备性来衡量一个虚拟机的能力，则EVM处于半成品的程度，限制多且不够灵活；而JVM，Wasm虚拟机则是比较完备的，限制少，功能性强。另一方面指令设计的合理性一定程度也会影响虚拟机的执行效率，同时虚拟机采用的实现方案也会对执行效率产生比较大的影响。</p>
<p>例如EVM当前只能以解释器（interpreter）的形式运行，并且当前的实现过程体（go, c++等版本）中没有看到针对解释器的优化，执行效率比较底下，而 JVM, Wasm等虚拟机有采用JIT的模式的实现，执行效率相当高甚至逼近本地执行的性能。</p>
<blockquote>
<p>注：<code>pallet-contracts</code>当前只能使用<code>wasmi</code>（解释器）执行Wasm代码，因此合约的执行性能比不上使用<code>wasmtime</code>的Runtime的执行性能。</p>
</blockquote>
<p>而同时，Wasm虚拟机相比于JVM等虚拟机，十分轻便（Lightweight），快速，可定制性强，<strong>且<code>host function</code>的功能给予了Wasm虚拟机与宿主之间交互的通道</strong>，因此和其他虚拟机相比，将Wasm虚拟机作为区块链合约沙盒与链的功能结合在一起比较容易。</p>
<p>另一方面在笔者看来，Wasm是处于底层代码与上层代码之间比较好的一个抽象层，且其复杂性与完备性也远超于EVM，因此比较适合区块链合约领域的需求。</p>
<p>因此Wasm虚拟机提供的沙盒环境在满足合约沙盒的前提下还满足以下2点要求：</p>
<ul>
<li>指令完备，功能性丰富，执行效率高</li>
<li>有适合的接口能与宿主（这里指代运行Wasm的环境，即链）交互，方便宿主提供需要的功能。</li>
</ul>
<h2><a class="header" href="#evm-的合约模型" id="evm-的合约模型">EVM 的合约模型</a></h2>
<p>由于Ethereum是存储状态的区块链，因此EVM的合约模型理所应当的需要基本读写状态的功能。如果把每次合约运行的过程看做一次程序的启动到执行结束的过程，那么状态数据的变化就对应着这个程序需要持久化数据的变化。</p>
<p>因此对于读写状态，以太坊的EVM提供了<code>SLOAD</code>和<code>SSTORE</code>两个指令。</p>
<p>另一方面以太坊描述一个账户使用了“账户模型”，即将合约和调用合约的用户都看做了一个账户，在这个账户下存在<code>balance</code>等概念，因此EVM提供了<code>CALLER</code>，<code>ORIGIN</code>，<code>CALLVALUE</code>等等一系列指令来描述这种模型。</p>
<p>同时由于在EVM的抽象体系中，认为合约与用户是一致的，因此出现了“合约调用合约”的模型，即<code>CALL</code>，<code>DELEGATECALL</code>等指令，由此带来了合约的可组合性，造就了Ethereum繁荣的生态。而在EVM中，一个合约依托于一个EVM进行运行，因此合约调用合约是在一个EVM中启动了另一个EVM并加载指令进行执行。</p>
<p>当然EVM虚拟机设计的初衷就是为了解决比特币脚本的非图灵完备问题，为了解决这个问题并保证停机问题不发生，引入了指令的Gas计费模型</p>
<p>因此总结以上可以得到，EVM的合约模型具备以下特性：</p>
<ol>
<li>处理数据的模型是状态机模型，状态的变更靠外界调用触发（类比于调用了状态变更函数的过程）；</li>
<li>合约模型中需要链相关的特性；</li>
<li>将合约与用户看做一致，允许合约调用合约；</li>
<li>引入指令计费模型。</li>
</ol>
<h2><a class="header" href="#pallet-contracts的合约模型" id="pallet-contracts的合约模型"><code>pallet-contracts</code>的合约模型</a></h2>
<p>这里直接下结论：<strong><code>pallet-contracts</code>虽然使用了Wasm虚拟机来执行代码，但是其合约模型基本与EVM合约模型一致</strong>。</p>
<p>也就是说<code>pallet-contracts</code>的合约模型同样具备以下4点特性：</p>
<ol>
<li>处理数据的模型是状态机模型；</li>
<li>合约模型中需要链相关的特性；</li>
<li>将合约与用户看做一致，允许合约调用合约；</li>
<li>引入指令计费模型。</li>
</ol>
<p>并且，在以上4种特性的基础上，增加了“存储租赁模型”：</p>
<ul>
<li><code>Rent</code>存储租赁计费。</li>
</ul>
<p>在上文已经称述了合约执行的环境和合约模型是可以解耦的，EVM由于设计的比较早还没有解耦这个层次的概念，因此在指令中<code>SLOAD</code>，<code>SSTORE</code>及类似和链相关的指令是与EVM其他指令合并一起的。而Wasm本来并非为区块链设计，因此一定不存在这些和链环境相关的指令。</p>
<p>因此Wasm的<code>host function</code>即是用来完成这件事情的。链作为<code>host</code>宿主，只需要把<strong>他认为合约可能会用到的方法</strong>提供给Wasm虚拟机，让他导入这些函数对象，在合约的执行过程中即可以使用。因此通过<code>host function</code>，<code>pallet-contracts</code>合约模块就可以具备1，2，4功能，并将提供3需要的部分功能，同时第5点特性（租赁计费）也可以引入。</p>
<p>并且其中第3点功能的实现方式也与EVM一致，当出现合约调用合约的部分时，通过<code>host function</code>从Wasm回到了<code>pallet-contracts</code>模块，并启动了一个新的Wasm虚拟机去执行被调用的合约。（该部分在以后的文章中会描述）</p>
<p>因此总结而言，<code>pallet-contracts</code>的合约模型具备如下特性：</p>
<ol>
<li>合约模型与EVM的合约模型一致，并在此基础上增加了存储计费模型</li>
<li>与链交互的实现通过Wasm的<code>host function</code>特性实现</li>
</ol>
<h2><a class="header" href="#使用wasm虚拟机实现其他合约模型" id="使用wasm虚拟机实现其他合约模型">使用Wasm虚拟机实现其他合约模型</a></h2>
<p>刚才简要描述了<code>pallet-contracts</code>是如何在Wasm虚拟机上实现合约模型的，由于前文已经解释了虚拟机与合约模型是可以解耦的，因此实际上在Wasm虚拟机上同样可以实现其他的合约模型。</p>
<p>例如我们可以考虑将Move虚拟机也移植到Wasm虚拟机中，其有两种可能的实现方式：</p>
<ol>
<li>
<p>类比于将EVM的实现体在Runtime的Wasm环境运行，可以将MVM的实现体也编译成Wasm的形式（例如命名为<code>pallet-mvm</code>），在Runtime Wasm中运行。</p>
<p>基于这种实现，Move依然可以按正常方式编译，并和Solidity的编译结果运行于<code>pallet-evm</code>一致，将Move的编译结果运行在例如<code>pallet-mvm</code>的平台上。</p>
</li>
<li>
<p>将MVM与所有权，链相关的特性抽象一层，做成和<code>pallet-contracts</code>的形式，并设计将Move语言编译的中间码IR编译到Wasm。</p>
<p>基于这种实现，可以将Move编译成为Wasm，并在Wasm虚拟机中运行。</p>
</li>
</ol>
<h2><a class="header" href="#其他合约模型" id="其他合约模型">其他合约模型</a></h2>
<h3><a class="header" href="#eos的合约模型" id="eos的合约模型">EOS的合约模型</a></h3>
<p>EOS的合约模型与EVM类似，同时强化了账户模型的概念。因此EOS使用Wasm的方式也是基于Wasm的执行，并通过<code>host function</code>引入与链相关的功能。</p>
<p>EOS和EVM模型的主要区别在于，EOS的合约调用合约的过程是以发交易的形态调用，并且EOS的资源模型是抵押模型。当前普遍认为正是EOS的抵押模型最后导致EOS没有走向成功。</p>
<h3><a class="header" href="#异步合约模型" id="异步合约模型">异步合约模型</a></h3>
<p><code>pallet-actor</code>是 substrate 尝试实现异步合约模型的一个开端，当前没有什么进展。<code>pallet-actor</code>的模型打算使用Wasm虚拟机作为运行环境，并在此基础上添加异步的功能以提升性能。</p>
<p>当前也有其他少数对异步合约模型的研究，但是皆处于比较初步的阶段。</p>
<h1><a class="header" href="#合约语言框架" id="合约语言框架">合约语言（框架）</a></h1>
<p>与“合约模型”的概念相对应的（运行平台），我们可以衍生出合约语言（框架）的概念（编写能运行于平台上的代码）。</p>
<p>而这里不简单的使用“合约语言”，而是用“合约语言（框架）”这样的词语，是因为由于上一章节中我们已经拆分出了“合约沙盒”与“合约模型”的结构层次，因此实际上一些新型的合约平台并不是像EVM那样“发明”了一套新的Solidity合约语言，而是选择了一些语言（如Rust，C++，AssemblyScript等），基于这门语言在“hack语法解析”，“宏”，等维度上给现有语言添加上合约相关的约束，功能逻辑等。因此许多情况下会以“框架”，“库”等形态存在（如Frame Contract Pallet的rust合约语言框架ink!）。而这种“框架/库”又不是平时程序开发中使用库的维度，有一些合约语言框架需要修改到编译器维度，因此我们更倾向称呼为“语言框架”。</p>
<h2><a class="header" href="#合约语言框架与合约模型的对应关系" id="合约语言框架与合约模型的对应关系">合约语言（框架）与合约模型的对应关系</a></h2>
<p><img src="contracts/./imgs/language_1.jpg" alt="language 1" /></p>
<p>如上图所示，上半部分是 EVM 与 Solidity 之间的关系。由于EVM/Solidity提出的时间比较早，因此其模型与通常的计算机虚拟机与语言的模型关系是一致的。而下半部分是在分离了合约模型后，语言框架部分的对应关系。</p>
<p>这里重点介绍下半部分，上半部分读者可以根据自己在以太坊合约开发的经验对比后文的介绍进行分析。</p>
<p>在编译形语言的体系中，先简单定义以下名词（非严谨说法，仅为了后文介绍而定义）：</p>
<ul>
<li>S语言：程序员编写代码的原语言(source)，例如将C++编译成汇编，那么C++就是原语言S</li>
<li>T语言：S语言通过编译器编译后生产的语言(target)，例如将C++编译成汇编，那么汇编就是目标语言T</li>
</ul>
<p>前文已经介绍了运行合约体系的环境可以在逻辑上拆分为“合约模型”与“合约虚拟机”，前者管合约的业务逻辑，后者管如何运行合约的代码，那么相对应的，合约语言部分同样可以拆解为“合约语言框架”和“编译到合约虚拟机的S语言”。</p>
<p>那么根据这种定义，显然，Solidity就是就是一种同时具备“合约语言框架”和“S语言”特性的产物：</p>
<ol>
<li>
<p>Solidity具备图灵完备的语言体系，因此Solidity是一门“语言”（相对于BTC脚本而言）</p>
</li>
<li>
<p>Solidity的语法中具备很多合约特性的关键字，对应于“合约语言框架”的概念，如：</p>
<ul>
<li><code>mapping</code>：合约存储的典型案例</li>
<li><code>msg.sender</code>, <code>msg.value</code>：等与合约调用相关的变量</li>
<li><code>view</code>,<code>pure</code>等修饰符</li>
<li><code>call</code>,<code>delegate_call</code>等与合约调用相关关键字</li>
</ul>
<p>这些概念并非是为了支持Solidity这门语言能执行逻辑而存在的，而是为了服务于Ethereum合约虚拟机的业务逻辑而存在的。</p>
</li>
</ol>
<p>而“合约语言框架”实现的目的就是为了与合约模型的业务逻辑所对应，什么样的合约模型就需要什么样的合约语言框架。例如EVM底层是k/v类型的存储，因此Solidity中设计的<code>mapping</code>不能遍历（除非附带多余存储）。例如EVM合约交互的合约模型设计为合约调用合约的模式，那么Solidity中就提供了<code>call</code>，<code>delegate_call</code>。<strong>对应到其他合约体系也同理</strong>。</p>
<p>而另一方面合约语言框架是架设到S语言上的附加功能，因此合约语言框架提供的功能最终也是编译到S语言对应的T语言上。而区块链所需要的一些特性例如确定性要求，不允许使用操作系统调用的接口等等，会在这个层面上<strong>做约束</strong>。因此合约语言框架除了本身对S语言本身提供了合约模型的功能以外，还会需要给语言本身产生一定的约束。这一步也是开发和理解合约语言框架中比较困难的地方。同时也正是由于这个点，造成了合约开发者使用合约模型框架的过程中很多别扭的情况。而Solidity或者Move等语言本身就是针对合约平台开发的新语言，纵使其语法会有很多模拟其他语言的痕迹，但是在做约束的这点上可以做到对合约开发者比较友好。而对现有语言加上合约语言框架功能的合约语言，在这一点上很难处理的很好，而这也是造成合约开发者较难使用框架功能的原因之一。</p>
<p>以ink!举例而言：</p>
<ol>
<li>
<p>在区块链中应该避免使用float，因为浮点数可能产生非确定性行为。因此在合约/runtime开发中，若需要使用浮点数，或者出现溢出数字乘除的时候就需要引入定点数来处理。因此在ink!的合约中可以引入Substrate runtime提供的定点数的库来处理。</p>
</li>
<li>
<p>由于<code>pallet-contracts</code>的合约模型与EVM基本相同，因此<code>pallet-contracts</code>的合约存储也是由K/V构成。那么合约模型框架就需要处理标准库里提供的各类集合类型。因此在<strong>ink!中将标准库中可能用到的集合类型重写了一遍</strong>，添加了能将集合元素类型处理成K/V数据的过程。因此在ink!的合约存储中，若设计了集合类型，只能使用ink!标准库中提供的类型。而另一方面由于ink!的返回值需要导出metadata令第三方处理，而当前的metadata的接口实现只给标准库中的集合实现，因此ink!方法的返回值的集合只能使用标准库的集合类型。因此就会出现以下代码：</p>
<pre><code class="language-rust ignore">#[ink::contract]
mod test {
    // 引入 ink 实现的 Vec
    use ink_storage::collections::Vec as StorageVec;
    // 引入标准库的Vec
    use ink_prelude::vec::Vec;
    #[ink(storage)]
    pub struct Test {
        owners: StorageVec&lt;AccountId&gt;, // 只能使用 ink的Vec
    }
    impl Test {
        #[ink(message)]
        pub fn get_owners(&amp;self) -&gt; Vec&lt;AccountId&gt; {
            // 将 ink 实现的 Vec 转换为 标准库实现的 Vec
            self.owners.iter().map(Clone::clone).collect()
        }
    }
}
</code></pre>
</li>
</ol>
<p>因此总结而言，在模型结构上，开发者需要理解到：</p>
<ul>
<li>合约语言框架与合约模型是对应关系，语言框架的特性会与模型一一匹配；</li>
<li>合约语言框架对S语言提供了针对合约模型的业务功能，同时也根据合约业务逻辑的需求对S语言本身有约束。</li>
</ul>
<p>不过由于Solidity本身定位就是服务于写合约而设计出来的语言，因此许多与合约相关的功能能够设计为<strong>关键字</strong>。而若是一门语言本身并不是针对合约设计的，则需要基于这门合约设计对应于合约模型的“合约语言框架”。由于是在这门语言上添加新的功能，因此一般情况下很难与语言本身结合的比较深入。因此最后做到的成果与这门语言提供的能<strong>拓展语法树</strong>的能力相关。语言本身提供了越灵活修改/添加语法树的接口（宏，插件等），那么合约语言框架就可以实现越多的功能。语言本身提供这类可扩展性的功能越少，那么合约语言框架就只能考虑修改编译器，扩展需要的语法以支持合约模型，这样最后的语言就变成了原语言的一种“方言”了。因此前者可以以库/框架的形态存在，而后者则变为了一门新的语言，<strong>这也是我们将这种模型称为“合约语言框架”的原因</strong>。</p>
<h2><a class="header" href="#pallet-contracts-与对应的合约语言框架" id="pallet-contracts-与对应的合约语言框架"><code>pallet-contracts</code> 与对应的合约语言框架</a></h2>
<p><img src="contracts/./imgs/language_2.jpg" alt="language 2" /></p>
<p>在上文解释了合约语言框架的模型后，我们就可以把合约模型框架套在Substrate的Wasm合约系统上了。</p>
<p>那么显然，ink!这整套系统的实现，就是与<code>pallet-contracts</code>的合约模型相对应的。ink! 3.0通过过程宏（2.0通过神声明宏）的系统，将对应于<code>pallet-contracts</code>的功能逻辑引入到了rust当中。因此这套系统里的S语言就是rust，而T语言就是Wasm字节码。ink!在一个辅助工具<code>cargo-contract</code>的帮助下，将使用了ink!框架的rust代码编译成为了合约的Wasm字字节码。而Wasm字节码在链上运行的环境就是wasmi（将来也会引入Wasmtime等JIT形式的执行环境）。</p>
<p>而由于<code>pallet-contracts</code>的执行环境是Wasm字节码，因此能够编译成Wasm字节码的的语言配套上符合<code>pallet-contracts</code>合约模型的合约语言框架，都可以产生能运行于<code>pallet-contracts</code>这个合约平台上的合约。所以对于<code>pallet-contracts</code>而言，完全可以设计不同语言的合约体系给发开发提供多种选择使用不同的语言开发Wasm合约。</p>
<p>当前支持运行于<code>pallet-contracts</code>的合约语言框架除了对于rust的ink!之外，还有以下项目：</p>
<ul>
<li>Ask!, 由 Patract 主导开发，是在AssemblyScript语言上的合约语言框架。(当前正在开发中)</li>
<li>Solang, 由 hyperledger-labs 主导开发，支持将 Solidity 编译到 <code>pallet-contracts</code>的Wasm的工具。</li>
</ul>
<h1><a class="header" href="#wasm简要介绍" id="wasm简要介绍">Wasm简要介绍</a></h1>
<h2><a class="header" href="#wasm与合约模型的关联" id="wasm与合约模型的关联">Wasm与合约模型的关联</a></h2>
<p><img src="contracts/./imgs/wasm.jpg" alt="" /></p>
<h1><a class="header" href="#pallet-contracts-合约模块" id="pallet-contracts-合约模块">pallet-contracts 合约模块</a></h1>
<p><code>pallet-contracts</code>合约模块, 一般称呼为<a href="https://substrate.dev/docs/en/knowledgebase/smart-contracts/contracts-pallet">“Contracts Pallet”</a> 或者 “FRAME Contracts pallet”，又或者称呼为“Substrate Smart Contracts”，是parity官方研发的Wasm合约模块。</p>
<p>依据Substrate knowledgebase的介绍，Contracts Pallet具备如下特性：</p>
<ul>
<li>Are inherently safer to the network.</li>
<li>Have built in economic incentives against abuse.</li>
<li>Have computational overhead to support graceful failures in logic.</li>
<li>Have a lower bar to entry for development.</li>
<li>Enable fast pace community interaction through a playground to write new logic.</li>
</ul>
<h1><a class="header" href="#ink" id="ink">ink</a></h1>
<p>ink! is an eDSL to write WebAssembly based smart contracts using the Rust programming language. The compilation target are blockchains built on the Substrate framework.</p>
<p>ink! 是 parity 官方编写的，可以提供一种 eDSL 的方式编写 Rust 合约，并编译为 Wasm 运行于 Contracts Pallet 模块上。</p>
<p>虽然 ink!自称为一种写合约的 eDSL，但是笔者更倾向于认为 ink!是使用 Rust 语言编写符合能满足 Contracts Pallet 运行的合约框架。</p>
<p>例如对于 EVM 而言，若把 EVM 的指令集看做一种规范（EVM 的指令集已经包含了 EVM 合约模型的信息），那么只要能编译到 EVM 指令集的语言都可以称为能运行在 EVM 上的合约语言，例如：</p>
<ul>
<li>Solidity</li>
<li>Vyper</li>
</ul>
<p>而 ink!这里同理。Contracts Pallet 要求是能满足运行 Contracts Pallet 合约模型的 Wasm 代码，因此任何能编译成满足这个 Wasm 合约模型的框架/语言/库都可以称为 Contracts Pallet 的合约语言。</p>
<p>ink!就是使用 Rust 语言，并在此基础上通过 Rust 的<strong>卫生宏系统</strong>设计了一套 eDSL，并使用该 eDSL 编写能满足 Contracts Pallet 要求的 Rust 代码。除 eDSL 之外，ink!还提供了适用于合约模型的<strong>存储集合类型</strong>，生成 Metadata（对应于 Solidity 的 ABI）等工具库。</p>
<p>ink!的官方文档见：</p>
<ul>
<li><a href="https://substrate.dev/docs/en/knowledgebase/smart-contracts/ink-fundamentals">ink! Concepts</a></li>
<li><a href="https://substrate.dev/substrate-contracts-workshop/#/">ink! Smart Contracts Tutorial</a></li>
<li><a href="https://paritytech.github.io/ink-docs/">ink! Documentation Portal</a></li>
</ul>
<h2><a class="header" href="#ink-到-contracts-pallet-的过程" id="ink-到-contracts-pallet-的过程">ink! 到 Contracts pallet 的过程</a></h2>
<p>parity 官方文档中提供了示例图：
<img src="https://paritytech.github.io/ink-docs/img/how-it-works.svg" alt="https://paritytech.github.io/ink-docs/how-it-works" /></p>
<p>由此图可知，编写 ink!合约并部署的过程需要</p>
<ul>
<li>ink! 依赖库：提供 ink!的 eDSL 框架以及提供相应的依赖组件</li>
<li>cargo-contract: 编译 ink!合约的工具</li>
<li>SDK：与链交互并将合约部署到链上的 SDK，parity 官方主要提供了<code>polkadot.js</code>，Patract 提供了 Himalia 工具包，包含<code>go</code>，<code>java</code>，<code>python</code>，<code>C#</code>的 SDK</li>
</ul>
<p>本章节将主要介绍 ink!以及<code>cargo-contract</code>的信息，关于 SDK 的信息放在后续章节介绍。</p>
<h1><a class="header" href="#ink-tutorial" id="ink-tutorial">ink! tutorial</a></h1>
<p>TODO</p>
<h1><a class="header" href="#ink-框架" id="ink-框架">ink! 框架</a></h1>
<p>ink!的所有主体功能都实现于 <a href="https://github.com/paritytech/ink/tree/master/crates"><code>ink/crates</code></a> 目录下：</p>
<ul>
<li>crates:
<ul>
<li>allocator：与Wasm相关，定义allocator，开发者绝大部分情况下无需关心</li>
<li>env：提供和链相交互的组件，总结来说就是和链相关的部分都会放在这里，包含
<ul>
<li>host function 部分</li>
<li>部分需要导入的类型、trait定义</li>
<li>event 的topic</li>
</ul>
</li>
<li>lang：eDSL过程宏的定义组件，合约的规范由这个地方决定</li>
<li>metadata：生成metadata的组件</li>
<li>prelude：合约编写过程中需要预先导入的包，包含一些标准库</li>
<li>primitives：操作状态存储的指针，开发者绝大部分情况下无需关心</li>
<li>storage：提供链存储的分配模型以及提供一些预定义好的存储集合类型</li>
</ul>
</li>
</ul>
<h1><a class="header" href="#ink-edsl基础元素" id="ink-edsl基础元素">ink! eDSL基础元素</a></h1>
<p>ink! eDSL设计的元素与Solidity的元素其实比较近似，因为Contracts Pallet的合约模型结构和EVM的合约模型就是比较近似的。</p>
<p>因此ink!的设计可以找到很多和Solidity相似的影子（Substrate 的 Runtime 设计同理）。后文描述ink特性时会尝试跟Solidity的特性进行对比，方便读者理解。</p>
<h2><a class="header" href="#edsl-的元素" id="edsl-的元素">eDSL 的元素</a></h2>
<p>由ink!文档或ink!提供的example，代码可以看出，ink!在Contracts Pallet的模型上，同样提出了以下三点基础元素：</p>
<ul>
<li><code>constructor</code>/<code>message</code></li>
<li><code>storage</code></li>
<li><code>event</code></li>
</ul>
<p>不过由于Rust过程宏的设计关系，可以看到ink!首先要求一个合约需要处于一个<code>mod</code>下，并且在这个<code>mod</code>的上面添加上<code>#[ink::contract]</code>宏：</p>
<pre><code class="language-rust ignore">#[ink::contract]
mod erc20 {
    // ...
}
</code></pre>
<p>这样，相当于告知ink!从这个mod里面的东西就是要依据ink的eDSL处理的部分。</p>
<h3><a class="header" href="#inkcontract" id="inkcontract"><code>#[ink::contract]</code></a></h3>
<p>因此当遇到宏<code>#[ink::contract]</code>，即表面这是在ink!所识别的“合约部分”。因此我们可以看到，很多<code>use xxx</code>的导入都会放到处于<code>#[ink::contract]</code>的<code>mod</code>作用域下。</p>
<p>并且当前ink!设计为，在一个<code>crate</code>包下，只能出现一个<code>#[ink::contract]</code>，因此代表着ink!认为一个合约的维度是以rust的<code>crate</code>为单位，即如果在同一个<code>crate</code>中，无论是在同一个文件（比如都在<code>lib.rs</code>下）或者是在不同的文件中定义了2个以上的被<code>#[ink::contract]</code>修饰的<code>mod</code>，例如：</p>
<pre><code class="language-rust ignore">#[ink::contract]
mod erc20 {
    // ...
}

#[ink::contract]
mod another_define {
    // ...
}
</code></pre>
<p>类比于solidity的：</p>
<pre><code class="language-solidity ignore">// a.sol 在同一个文件中定义多个 `contract`
contract A {

}
contract B {

}
</code></pre>
<p>那么在ink!的编译中会认为这种情况是非法的。</p>
<p>当然与之相对的，只要在当前<code>crate</code>中只有一个<code>#[ink::contract]</code>修饰的<code>mod</code>，其他<code>mod</code>该怎么正常使用就正常使用，<strong>因此ink!修饰的合约<code>crate</code>依然可以很好的做好代码隔离，增强可读性和可维护性</strong>。这个能力对于<strong>维护大型复杂合约比较重要</strong>，例如：</p>
<pre><code class="language-rust ignore">#[ink::contract]
mod erc20 {
    use crete::another_define::*;
}

mod another_define {
    // ...
}
</code></pre>
<p>例如如下实例：</p>
<pre><code class="language-rust ignore">mod fxck {
    use crate::erc20::Erc20;
    use ::ink_lang::Env; // 注意这里需要引入 `ink_lang::Env`
    impl Erc20 {
        pub fn tmp(&amp;self) {
            self.env().caller(); // 
        }
    }
}

#[ink::contract]
mod erc20 {
    #[ink(storage)]
    pub struct Erc20 { ... }

    impl Erc20 {
        #[ink(constructor)]
        pub fn new(initial_supply: Balance) -&gt; Self { ... }
        #[ink(message)]
        pub fn transfer(&amp;mut self, initial_supply: Balance) -&gt; Self {
            self.tmp(); // 调用在其他`mod`里定义的方法
        }
    }
}
</code></pre>
<p>这种模型可以做到一些在Solidity下做不到的代码隔离，增强可维护性。（因为Solidity的library只能用于纯函数计算）</p>
<p>总结而言，在ink!体系下：</p>
<ul>
<li>一个合约以一个<code>crate</code>的单位，一个<code>crate</code>内只能出现一个<code>#[ink::contract]</code>定义；</li>
<li><code>#[ink::contract]</code>修饰的<code>mod</code>代表合约的内容，同时也代表了<strong>合约的基础元素都必须定义到这个<code>mod</code>下</strong>；</li>
<li>除<code>#[ink::contract]</code>修饰的<code>mod</code>以外的部分（其他<code>mod</code>，函数，类型）皆遵循rust的规则，可以做好良好的代码隔离提升可维护性；</li>
<li>实践中可以将<code>#[ink::contract]</code>修饰的<code>mod</code>当做合约的入口，将实现的逻辑分散到其他<code>mod</code>下。</li>
</ul>
<p>以下使用“合约mod”表示被<code>#[ink::contract]</code>修饰的<code>mod</code></p>
<h3><a class="header" href="#storage" id="storage"><code>storage</code></a></h3>
<p>在合约mod中，一定需要定义一个结构体，且这个结构体被<code>#[ink(storage)]</code>所修饰，表示定义了该合约的存储。</p>
<p>同时这个被<code>#[ink(storage)]</code>修饰的结构体定义，<strong>也被视作一个可操作的合约实体</strong>，因此所有与合约相关的资源，类型，操作都会<strong>和这个结构体绑定在一起</strong>，当在合约调用合约的情景中，被调用的合约的类型也由这个结构体来表示。</p>
<p>因此这个结构体可以理解为是合约实体。</p>
<blockquote>
<p>虽然修饰<code>mod</code>的部分才是合约，但是因为<code>mod</code>在rust中只能代表作用域，因此为了实践使用，使用<code>#[ink(storage)]</code>修饰的结构体表示能够进行操作的合约实体。</p>
<p>在这种语境下，可以将<code>#[ink::contract]</code>修饰的<code>mod</code>理解为“开启了合约域”的概念，而<code>#[ink(storage)]</code>修饰的<code>stuct</code>是在这个合约域下的合约。</p>
</blockquote>
<p>这里ink!定义的storage的概念和Solidity中定义“存储”的概念一致，表示定义在这里的属性即是最终写到<strong>链上的状态</strong>。一切合约逻辑编写的目的最后都是为了对这里定义的状态的修改。</p>
<p>不过由于当前ink!采用使用一个结构体来承载合约状态的方案，因此当前这个合约所有的状态都只能定义在这个结构体中。当合约设计得比较大，比较复杂的时候会导致这里的可维护性下降。</p>
<p>定义storage的示例如下：</p>
<pre><code class="language-rust ignore">#[ink(storage)]
pub struct Erc20 {
    /// Total token supply.
    total_supply: Lazy&lt;Balance&gt;,
    /// Mapping from owner to number of owned token.
    balances: StorageHashMap&lt;AccountId, Balance&gt;,
    /// Mapping of the token amount which an account is allowed to withdraw
    /// from another account.
    allowances: StorageHashMap&lt;(AccountId, AccountId), Balance&gt;,
}
</code></pre>
<p>被<code>#[ink(storage)]</code>修饰的结构体在后文统称为合约结构体。</p>
<p>这里尤其需要注意几个特性：</p>
<ol>
<li>
<p>在该合约结构体内定义的属性的类型必须是实现过<code>SpreadLayout</code>的类型（或者更准确说是实现了<code>PackedLayout</code>的类型，因为<code>PackedLayout</code>是继承于<code>SpreadLayout</code>的定义）：</p>
<pre><code class="language-rust ignore">/// Types that can be stored to and loaded from the contract storage.
pub trait SpreadLayout {
}
</code></pre>
<blockquote>
<p>这里只能使用实现过这个trait的类型的理由很简单，因为storage和一般的类型不同，其必须含有“链”的信息在其中，因此不同的链的合约实现都必须有一个部分用于处理合约中的storage（即状态）的分配问题。</p>
<p>例如Solidity在编译过程给实际上是按storage在合约中定义的上下顺序，做偏移分配该状态的key。这里实现过<code>SpredLayout</code>或者说<code>PackedLayout</code>类型的都会有一个近似的过程来进行状态的分配。</p>
</blockquote>
<p>ink!对于一般类型已经都做过基础实现，但是<strong>对于集合类型（<code>Vec</code>，<code>HashMap</code>等）而言，由于合约的状态需要hook读写的过程</strong>，因此无法对集合类型实现这个<code>trait</code>。所以在ink!中，对标准库中常用的集合类型重新全部做了一次实现，且位于<code>#[ink(storage)]</code>修饰的结构体的属性类型，<strong>若使用集合类型时，必须使用ink!提供的集合类型</strong>。</p>
<blockquote>
<p>由于Solidity比较简陋，因此Solidity定义的存储map是无法进行遍历的。（由Solidity设计的缺陷导致）</p>
<p>ink!在设计的这块的时候进一步做了很多事情，因此ink!提供的集合类型<code>Vec</code>，<code>BTreeMap</code>，<code>HashMap</code>等等都是<strong>可以遍历</strong>的。相较于Solidity能实现的功能而言是相当大的进步。</p>
</blockquote>
</li>
<li>
<p>即便基于以上的设计，嵌套集合类型依然很难实现（因为Substrate的状态结构采用了k/v模型）。因此在设计中还是只能尽量避免嵌套集合类型。如果一定需要嵌套集合类型，需要将嵌套的层次打平（flat），将第二层的key和第一层的key合并一起，使用元组替代（相当于Substrate Runtime中的<code>double_map</code>）</p>
<pre><code class="language-Solidity ignore">// solidity
contract A {
    mapping (uint =&gt; mapping (uint =&gt; uint))
}
</code></pre>
<p>在ink!中类似的代码应该为:</p>
<pre><code class="language-rust ignore">#[ink(storage)]
pub struct Erc20 {
    // 注意这里的key采用了元组 `(AccountId, AccountId)`
    allowances: StorageHashMap&lt;(AccountId, AccountId), Balance&gt;,
}
</code></pre>
</li>
<li>
<p>storage中提供了一种<code>Lazy</code>的模型，允许开发者使用<code>Lazy</code>包裹一个类型，可以让状态数据在使用到的情况下再加载：</p>
<pre><code class="language-rust ignore">/// A lazy storage entity.
///
/// This loads its value from storage upon first use.
///
/// # Note
///
/// Use this if the storage field doesn't need to be loaded in some or most cases.
#[derive(Debug)]
pub struct Lazy&lt;T&gt;
where
    T: SpreadLayout,
{
    cell: LazyCell&lt;T&gt;,
}
</code></pre>
<p>使用方式：</p>
<pre><code class="language-rust ignore">#[ink(storage)]
pub struct Erc20 {
    /// Total token supply.
    total_supply: Lazy&lt;Balance&gt;,
}
</code></pre>
</li>
</ol>
<h3><a class="header" href="#constructormessage" id="constructormessage"><code>constructor</code>/<code>message</code></a></h3>
<p><code>constructor</code>/<code>message</code>就是触发合约状态变更的入口函数。也就是说<code>constructor</code>/<code>message</code>即是合约状态的状态转换函数。</p>
<p><code>constructor</code>/<code>message</code>只能修饰<strong>合约结构体的方法</strong>，不能用来修饰其他结构体的方法，或者其他纯函数。</p>
<p>在合约mod中，被<code>constructor</code>和<code>message</code>修饰的合约结构体的方法至少各有一个，若分别少于1个都会导致编译错误。</p>
<p>其中：</p>
<ul>
<li>
<p><code>constructor</code> 即对应着 Solidity 合约中的构造函数。当合约被部署的时候（在Contracts Pallet中当前代表着从已上传的合约代码中做<code>instantiate</code>的过程），会触发对应构造函数的调用。</p>
<blockquote>
<p>这里需要强调，构造函数的调用与合约实例化是2个概念的事情，这个过程在ink!和Contracts Pallet的协调过程中<strong>并非原子化</strong>。因此会出现构造函数没有被调用，但是合约地址会生成，也可以正常调用这个未调用过构造函数的合约实例的情况。</p>
<p>典型的例子是在调用<code>instantiate</code>的时候传入的错误编码的参数。</p>
</blockquote>
</li>
<li>
<p><code>message</code>即对应着 Solidity 合约中的 <code>public</code>/<code>external</code>等 的 call 方法。由于Rust可变/不可变方法的特性，<code>message</code>利用了<strong>这个特性来表示这个方法是否会修改合约的状态</strong>。</p>
<p>因此若<code>message</code>修饰的方法是</p>
<pre><code class="language-rust ignore">// 注意方法的第一个参数是`&amp;self`
#[ink(message)]
pub fn total_supply(&amp;self) -&gt; Balance {
    *self.total_supply
}
</code></pre>
<p>则表示这个方法的调用不会修改状态（由rust语法所控制），和以太坊一致，这类方法多用于rpc调用返回一个合约的存储，或返回一些基于存储的计算结果。</p>
<p>若修饰的是</p>
<pre><code class="language-rust ignore">// 注意方法的第一个参数是 `&amp;mut self`
pub fn transfer(&amp;mut self, to: AccountId, value: Balance) -&gt; Result&lt;()&gt; {
    let from = self.env().caller();
    self.transfer_from_to(from, to, value)
}
</code></pre>
<p>则表示这个方法的调用会修改状态，因此这个方法如果是以交易调用被打包的形式被调用执行时，会触发状态的改变。若是以rpc调用时，表示是模拟执行了一次。</p>
<p>同时在合约编译后会生成metadata.json（对应Solidity的ABI），在这个metadata中对于message部分会有一个<code>mutates</code>的字段来标示这个方法是否是可变的。</p>
</li>
</ul>
<h4><a class="header" href="#message的selector" id="message的selector">message的<code>selector</code></a></h4>
<p>Solidity对于合约方法的ABI的产生使用的是将方法名加上参数类型作为函数签名拼凑成为字符串然后做hash取前4字节。</p>
<pre><code class="language-text">call = &quot;func_name(param1_type,param2_type,...)&quot;
bytes4(keccak256(call), a, b)
</code></pre>
<p>在ink!中这种让合约区分调用触发点的概念叫做<code>selector</code>。</p>
<p>由于rust不支持函数重载，因此在ink!中采用了比较简陋的设计，直接对函数名字的字符串做hash取前4字节：</p>
<pre><code class="language-text">call = &quot;func_name&quot;
blake2_512(call)[0..4]
</code></pre>
<blockquote>
<p>笔者认为这种设计造成了其他合约语言设计的困扰。因为rust不支持重载不代表别的语言不支持重载。当前Solang将Solidity编译到Wasm的过程后，想和ink!的metadata做兼容，互相调用就会出现问题。</p>
</blockquote>
<p>另一方面<code>selector</code>也可以运行合约开发者自己定义的</p>
<pre><pre class="playground"><code class="language-rust json">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[ink(message, selector = &quot;0xCAFEBABE&quot;)]
pub fn was_it_ten(&amp;self) -&gt; bool { ... }
<span class="boring">}
</span></code></pre></pre>
<h4><a class="header" href="#message的payable" id="message的payable">message的<code>payable</code></a></h4>
<p>Solidity中对于方法会有一个<code>payable</code>的修饰符，用于表示这个方法可以接受一定金额。</p>
<p>因此在ink!中也提供<code>payable</code>来表示调用这个方法的同时是否可以附带转移一定的<strong>本币的金额</strong>。在ink!当前的设计中，若在调用一个非<code>payable</code>的message时同时附带了金额时，这个调用过程会认为是错误的。</p>
<p>默认情况下认为<code>paybale</code>是<code>false</code>的，只有当合约开发者指定了<code>payable</code>后才是<code>true</code>。</p>
<p>指定一个message是可调用的案例是：</p>
<pre><pre class="playground"><code class="language-rust json">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[ink(message, playable)]
pub fn was_it_ten(&amp;self) -&gt; bool { ... }
<span class="boring">}
</span></code></pre></pre>
<p>另一方面在metadata中，对于message部分会有一个<code>payable</code>的字段来标示这个方法是否是需要付费的。</p>
<h3><a class="header" href="#event" id="event"><code>event</code></a></h3>
<p><code>event</code>的概念在状态机模型中其实并不是必须的。但是由于<strong>区块链是一个异步系统</strong>，因此在发送交易去触发状态变更后，并不能马上知道变更结果，只能依赖监听某个元素来判定执行结果。<code>event</code>便是在Solidity的阶段设计的元素，这个设计同样被继承到了Substrate Runtime中，以及ink!中。</p>
<blockquote>
<p>笔者不觉得event是一个很好的设计，理论上有其他更好的方式，或者event的变种。event一定程度上会造成开发者的滥用。</p>
</blockquote>
<p>ink!的<code>event</code>在Contracts Pallet中最后是通过<code>host function</code>将合约定义的event打印到了链的event当中。</p>
<p>ink!的event设计和Solidity相比就没有什么特别的地方了，不过由于是在Wasm中运行的合约，因此打印合约的event需要通过<code>host function</code>与链进行交互，因此调用的方式需要通过<code>env()</code>去调用。</p>
<pre><code class="language-rust ignore">Self::env().emit_event(...);
// or use
self.env().emit_event(...);
</code></pre>
<h1><a class="header" href="#ink-跨合约调用" id="ink-跨合约调用">ink! 跨合约调用</a></h1>
<h1><a class="header" href="#ink-与solidity的对比" id="ink-与solidity的对比">ink! 与solidity的对比</a></h1>
<h1><a class="header" href="#cargo-contract" id="cargo-contract">cargo-contract</a></h1>
<h1><a class="header" href="#ink-当前的坑" id="ink-当前的坑">ink! 当前的坑</a></h1>
<h1><a class="header" href="#ask" id="ask">Ask!</a></h1>
<p><img src="https://camo.githubusercontent.com/207ae88065c356df521ad4c6cff4a68ef91ae963a9c65893dd0d9d991a4e00a8/68747470733a2f2f706174726163742e6e6574776f726b2f696d616765732f706174726163742d61736b2e706e67" alt="" /></p>
<p>Ask! 是由 Patract 设计的，基于 AssemblyScript 上构建的，能运行于<code>pallet-contracts</code>模块上的Wasm合约语言框架。</p>
<p>尽管 AssemblyScript 只是 typescript 的一个子集，但是有很多使用 typescript 作为开发语言的开发人员，因此这些开发人员学习 AssemblyScript 的成本非常低。 因此，Patract 认为 Ask! 项目具有很好的应用开发前景。与基于Rust的ink!相比，Patract 认为基于 typescript 的Ask! 可以有效降低合同开发者的门槛并丰富合同开发生态系统。</p>
<p>Ask! 使用和 ink! 采取宏设计eDSL这样类似的方式，通过在 AssemblyScript （后文称作AS）中提供注解，在AS的语法基础上提供了能适用于<code>pallet-contracts</code>合约模型上的功能。通过注解的这种实现方式，尽量隐藏了与合约相关的细节。另一方面 Ask! 的实现将会与 ink! 接近，在<strong>最终实现上将会最大程度保证与 ink! 合约的兼容</strong>。</p>
<blockquote>
<p>例如：
ink! 描述合约的外部调用接口采用 <code>#[ink(constructor)]</code>, <code>#[ink(message)]</code> 对合约结构体的方法进行修饰。
在 Ask! 中，将会采用 <code>@constructor</code>，<code>@action</code> 等注解修饰合约的类方法，实现类似的功能。</p>
</blockquote>
<h2><a class="header" href="#ask-开发进度" id="ask-开发进度">Ask! 开发进度</a></h2>
<p><strong>Ask! 当前还在开发当中，当前只完成了Kusama财政议案的v0.1版。当前的很多设计将来都有可能发生不兼容性改变。</strong></p>
<p>TODO： 添加议案链接及报告链接。</p>
<h1><a class="header" href="#tutorial" id="tutorial">tutorial</a></h1>
<blockquote>
<p>当前 Ask! 只进行了Kusama国库议案的第一期的开发。因此还未发布到npm等公开仓库中。</p>
</blockquote>
<h2><a class="header" href="#简单运行" id="简单运行">简单运行：</a></h2>
<ol>
<li>
<p>clone 项目</p>
<pre><code class="language-bash">$ git clone https://github.com/patractlabs/ask
</code></pre>
</li>
<li>
<p>案例合约</p>
<p>在Ask!项目中准备了一些案例合约例如<code>flipper</code>，<code>incrementer</code>等，在<code>/example</code>目录下。开发者可以直接参考这些项目，也可以通过新建一个typescript文件(*.ts)来执行下列过程。以下示例过程的最终代码位于<code>/example/solar</code> 目录下。</p>
<ol>
<li>
<p>新建文件 <code>solar.ts</code></p>
</li>
<li>
<p>定义合约存储</p>
<p>Ask! 采用注解 <code>@storage</code> 定义一个合约的存储。这个过程类似于ink!中的 <code>#[ink(storage)]</code>宏。例如在这个案例中，我们定义下面3个合约存储变量：</p>
<pre><code class="language-typescript">@storage
class Planets {
    name: string;
    radius: u32;
    isdwarf: boolean;
}
</code></pre>
</li>
<li>
<p>定义合约的范围及可调用方法：</p>
<p>Ask! 采用<code>@contract</code>注解来指定一个class为合约类。这个过程类似于ink!中的 <code>#[ink::contract]</code>宏。</p>
<pre><code class="language-typescript">@contract
class SolarSystem {
    // ...
}
</code></pre>
<p>Ask! 提供了<code>@constructor</code> 和 <code>@message</code> 注解修饰合约类中的方法，类似于ink!中的 <code>#[ink(constructor)]</code> 和 <code>#[ink(message)]</code>。</p>
<pre><code class="language-typescript">@contract
class SolarSystem {
    @constructor
    default(name: string) void { /*...*/ }

    @message(mutates = false, selector = &quot;0x0a0b0c0d&quot;)
    getRadius(): u32 { /*...*/ }
}
</code></pre>
</li>
<li>
<p>编译 Ask! 合约</p>
<ol>
<li>
<p>安装依赖环境：</p>
<p>进入Ask!项目的根目录，执行命令：</p>
<pre><code class="language-bash">$ npm install
</code></pre>
</li>
<li>
<p>编译</p>
<p>在 Ask! 项目的<strong>根目录</strong>下编译合约。假设当前合约的路径位于<code>examples/solar/solar.ts</code>（开发者可以替换为自己合约文件的路径），则编译命令是：</p>
<pre><code class="language-bash">./assembly/codegen/bin/ask examples/solar/solar.ts
</code></pre>
<p>执行了这个命令后，会在合约文件的目录下生成一个扩展文件<code>extension.ts</code>，且合约的编译产物位于合约文件目录下的<code>target</code>目录。</p>
</li>
<li>
<p>测试</p>
<p>开发者可以采用 Patract 提供的合约执行环境沙盒 <a href="ask/../europa/introduction.html">Europa</a> 进行合约的部署调用和测试。</p>
<p>启动 Europa后，开发者可以通过 <a href="https://polkadot.js.org/apps">https://polkadot.js.org/apps</a> 将<code>target</code>目录下的合约进行部署和调用，这个过程和 ink! 合约的操作过程一致。</p>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<h1><a class="header" href="#设计" id="设计">设计</a></h1>
<h2><a class="header" href="#ask-设计总览" id="ask-设计总览">Ask! 设计总览</a></h2>
<p>AssemblyScript 使用 asc 编译器将TypeScript（TS）文件编译为WebAssembly字节码。 但是，asc是通用编译工具，无法使用智能合约结构将TS文件直接编译为WASM字节码和元数据信息。因此为了使 asc 能够识别并解析 Ask! 提供的和合约相关的注解与特定语法，需要对 asc 进行修改。</p>
<h2><a class="header" href="#设计-1" id="设计-1">设计</a></h2>
<p>ask! 将提供 <code>Contract Framework</code>（在以下描述中称为 <code>Framework</code>）和<code>Contract PreProcessor</code>（在以下描述中称为<code>PreProcessor</code>）两个组件。 此外，我们还将提供一个名为ask-cli的支持工具（类似于ink!的<code>cargo-contract</code>），用于帮助建立和管理用Ask！编写的Wasm智能合约。</p>
<p>Ask!的功能按照如下实现：</p>
<ul>
<li>
<p><code>Framework</code>的主要功能是为链上API提供高级包装，然后提供用于通过注解类型编写合约的规范。它需要完成以下任务：</p>
<ul>
<li>定义基于注解的合约撰写规范</li>
<li>在元数据中定义合约接口的描述规范</li>
<li>封装合约与链之间数据交互的详细信息，例如合约存储中密钥生成规则的定义以及存储的读写</li>
<li>封装链上的功能组件，例如Balance，AccountId，Block，Crypto等。</li>
<li>根据合约的语义将AS合约编译为Wasm代码，并包含与FRAME合约的交互接口的链接符号。</li>
</ul>
</li>
<li>
<p><code>PreProcessor</code>的主要功能是解析框架中定义的注解，并为这些注解生成相应的逻辑代码。根据框架中的合约接口规范，生成元数据文件。这个部分需要完成以下任务：</p>
<ul>
<li>解析合约中的注解并生成相应的逻辑代码</li>
<li>解析合约接口和参数，并生成元数据文件</li>
<li>解析自定义合约语法（语法糖），并生成相应的逻辑代码</li>
<li>自动存储和加载数据</li>
</ul>
</li>
<li>
<p><code>ask-cli</code>的主要功能是在cli中管理Ask!项目，其中包括以下功能：</p>
<ul>
<li>创建ask!合约模板。</li>
<li>简化ask!在项目编译过程中，隐藏预处理和编译过程的详细信息。</li>
<li>管理<code>Framework</code>，<code>PreProcessor</code>和Compiler的版本依赖性。</li>
<li>检查所生成的Wasm代码的合法性。</li>
</ul>
</li>
</ul>
<h1><a class="header" href="#基础" id="基础">基础</a></h1>
<h1><a class="header" href="#example" id="example">example</a></h1>
<h1><a class="header" href="#solang" id="solang">Solang</a></h1>
<h1><a class="header" href="#redspot" id="redspot">Redspot</a></h1>
<p>Redspot是让ink!，Ask!等合约开发项目化，简化开发者对合约的测试和交互过程的合约集成构建工具。Redspot 的功能覆盖整个合约开发环节（开发-调试-测试-部署），并且可以允许开发者构建丰富的插件以扩展Redspot的功能，最大程度简化合约开发者的负担，自动化执行重复的过程。</p>
<p>Redspot的设计目标类似Ethereum 生态中的Truffle，但是会比 Truffle 具备更广泛的扩展功能。</p>
<p>Patract 认为Redspot必须是一个灵活的系统，因为<code>pallet-contracts</code>合约模块可以被直接，或在一定程度上的修改后集成到Substrate链中。因此，Redspot决定使用 <a href="https://github.com/nomiclabs/hardhat">hardhat</a> 作为Redspot核心架构，因为它具有出色的设计，允许开发人员使用插件来添加新功能。</p>
<p>因此 Redspot 从 hardhat fork 而来（基于MIT协议），并在其基础上移除了与以太坊相关的部分，并添加和Substrate及<code>pallet-contracts</code>模块相关的功能。在未来，Redspot将会基于hardhat的核心构建更多的功能。</p>
<h1><a class="header" href="#tutorial-1" id="tutorial-1">tutorial</a></h1>
<h2><a class="header" href="#环境准备" id="环境准备">环境准备</a></h2>
<h3><a class="header" href="#安装-node" id="安装-node">安装 Node</a></h3>
<p>我们要求node 版本&gt;= 12.0，如果不是，则可以访问nodejs网站并了解如何安装或升级。或者我们建议您使用nvm安装Node。Windows用户可以改用nvm-windows。</p>
<h3><a class="header" href="#ink-合约编译的工具链" id="ink-合约编译的工具链">ink! 合约编译的工具链</a></h3>
<ol>
<li>
<p>rust 环境。由于 ink! 合约需要rust 的 Wasm 工具链，且当前Wasm只能在nightly工具链下运行，因此开发者需要先准备 Wasm 编译环境：</p>
<pre><code class="language-bash">rustup install nightly
rustup component add rust-src --toolchain nightly
rustup target add wasm32-unknown-unknown --toolchain nightly
</code></pre>
</li>
<li>
<p>ink! 编译合约的工具<code>cargo-contract</code></p>
<p>请注意以下命令安装的是parity默认提供的官方 <code>cargo-contract</code> （当前最新为0.10.0版本）.</p>
<pre><code class="language-bash">cargo install cargo-contract --force
</code></pre>
<p>若与Europa的话可以采用由 Patract 提供的 <code>cargo-contract</code>，这个版中中提供了一个<code>-d/--debug</code>的可选命令</p>
<pre><code class="language-bash">cargo install cargo-contract --git https://github.com/patractlabs/cargo-contract --branch=v0.10.0 --force
</code></pre>
<p>当前若安装 <code>cargo-contract</code> 的时候没有添加feature <code>binaryen-as-dependency</code>，则需要在当前环境中准备<code>wasm-opt</code>。</p>
</li>
<li>
<p>安装 <code>wasm-opt</code> （可选）</p>
</li>
</ol>
<p>wasm-opt 来自仓库 <a href="https://github.com/WebAssembly/binaryen">https://github.com/WebAssembly/binaryen</a>。开发者可以直接在release中下载到对应平台的最新的编译产物。通过直接下载的编译产物请放置在能被任意访问的PATH路径下。</p>
<p>或者开发者也可以通过系统命令安装<code>wasm-opt</code></p>
<p>TODO 确定不同平台的安装方式</p>
<h3><a class="header" href="#准备能运行合约的区块链节点" id="准备能运行合约的区块链节点">准备能运行合约的区块链节点</a></h3>
<h4><a class="header" href="#1-jupiter" id="1-jupiter">1. Jupiter</a></h4>
<p>Jupiter <a href="https://github.com/patractlabs/jupiter">https://github.com/patractlabs/jupiter</a> 是 Patract 维护的，包含 Patract 合约设计规范并兼容最新 <code>pallet-contracts</code> 模块的合约测试网。</p>
<p>Jupiter 有三类节点：</p>
<ul>
<li>运行于 rococo 上的 Jupiter 合约平行链；</li>
<li>独立运行对外提供最新合约功能的 Jupiter 独立测试网；</li>
<li>适用于本地快速测试的 Jupiter 节点</li>
</ul>
<p>这三类节点的区别及编译安装等信息请参阅该项目的Readme。</p>
<h4><a class="header" href="#2-europa" id="2-europa">2. Europa</a></h4>
<p>Europa <a href="https://github.com/patractlabs/europa">https://github.com/patractlabs/europa</a> 是 Patract 设计的用于帮助合约开发者调试及测试合约的合约沙盒。该合约沙盒的定位类似于 Ethereum 生态中的 Ganache，但 Europa 的特性更多的体现在其提供了部署调用合约过程中的详细执行信息的日志，能够最大程度反应出合约模块这个“黑盒”的运行情况，对合约的开发者十分有帮助。</p>
<p>开发者可以简单的通过以下方式安装并启动Europa：</p>
<pre><code class="language-bash">cargo install europa --git https://github.com/patractlabs/europa --locked --force
europa --tmp
</code></pre>
<p>Europa 不同的版本及其他信息请参阅该项目的Readme。</p>
<h4><a class="header" href="#3-canvas" id="3-canvas">3. Canvas</a></h4>
<p>Canvas <a href="https://github.com/paritytech/canvas-node">https://github.com/paritytech/canvas-node</a> 是 parity 官方提供的具备 <code>pallet-contracts</code> 模块的合约测试链，这个测试链是一个 parity <code>ink!</code> &amp; <code>pallet-contracts</code> 开发组维护的测试网。</p>
<p>参与 canvas 网络的方式请参照该项目的 Readme。若目的只是为了在本地运行测试节点，可以执行如下命令：</p>
<pre><code class="language-bash">cargo install canvas-node --git https://github.com/paritytech/canvas-node.git --force --locked
canvas --dev --tmp
</code></pre>
<h2><a class="header" href="#创建-redspot-项目" id="创建-redspot-项目">创建 Redspot 项目</a></h2>
<h3><a class="header" href="#从模版安装" id="从模版安装">从模版安装</a></h3>
<p>Redspot 提供合约开发模版，可以让用户快速搭建起一个项目。目前仅支持安装 erc20 合约的模版。</p>
<p>如果要从模版创建一个新项目，可以选择使用 <code>npx</code> 。npx 是 npm (<em>npm 5.2+</em> ) 里自带的一个包执行器。执行以下命令将会拉取<strong>最新</strong>的Redspot，并以 erc20 为模板构建出 Redspot 项目。</p>
<pre><code>npx redspot-new erc20
</code></pre>
<blockquote>
<p>注意由于当前 ink! 变动频繁，因此Redspot还未提供从模板创建项目功能。开发者若需要其他项目模板，可以从 Redspot 的项目仓库 <a href="https://github.com/patractlabs/redspot">https://github.com/patractlabs/redspot</a> 中的 example 目录中拷贝到任意目录下，并更改例如项目名等配置。<strong>example 目录下的所有案例都已经是 Redspot 项目结构</strong>，因此不需要用户再执行<code>npx redspot-new</code>创建项目。</p>
</blockquote>
<p>若一个项目已经由 Redspot 创建，则该项目根目录下一定存在一个文件<code>redspot.config.ts</code>以标志这个项目是Redspot。同时相同目录下的<code>package.json</code>则控制了这个项目对应的Redspot的版本。</p>
<p>若合约开发者从github，或者example，或者其他情况下获取到了别的开发者已经构建好的Redspot项目，则进入到这个项目目录下并执行<code>yarn install</code>命令可以恢复出该Redspot项目使用的Redspot环境，例如如下案例：</p>
<pre><code class="language-bash"># copy the delegator multi-contract example from redspot repo to local dir
cp -r ./redpost/example/delegator ./
cd delegator
yarn install
</code></pre>
<p>默认的模版是已经配置了 typescript 。也推荐大家使用 typescript 进行开发。即使没有 typescript 经验，typescript 也是兼容 javascript 的，不定义任何类型，也可以正常运行，并且仍然能够拥有 typescript 强大的类型提示和错误提示功能。</p>
<h3><a class="header" href="#集成到已有的合约项目中" id="集成到已有的合约项目中">集成到已有的合约项目中</a></h3>
<p>Redspot 也可以很轻松的集成到已存在的合约项目中。我们以官方的 ink (https://github.com/paritytech/ink)仓库中的 <strong>examples</strong> 目录下的合约为例。</p>
<h4><a class="header" href="#编译合约" id="编译合约">编译合约</a></h4>
<p>首先克隆 ink 仓库并打开 ink 目录：</p>
<pre><code>git clone https://github.com/paritytech/ink.git
cd ink
</code></pre>
<p>然后我们在 ink 的根目录中创建以下三个文件：</p>
<p>redspot.config.ts:</p>
<pre><code class="language-typescript">import { RedspotUserConfig } from 'redspot/types';
import '@redspot/patract'; // 引入 @redspot/patract 插件
import '@redspot/chai'; // 引入 @redspot/chai 插件

export default {
  defaultNetwork: 'development', // 默认的 network
  contract: {
    ink: {
      toolchain: 'nightly',      // 指定编译合约时的 toolchain 版本
      sources: ['examples/**/*'] // 合约所在的目录
    }
  },
  networks: {
    // development 网络的配置
    development: {
      endpoint: 'ws://127.0.0.1:9944',
      types: {},
      gasLimit: '400000000000', // 设置默认的 gasLimit
      explorerUrl:
        'https://polkadot.js.org/apps/#/explorer/query/?rpc=ws://127.0.0.1:9944/'
    },
  },
  mocha: {
    timeout: 60000
  }
} as RedspotUserConfig;
</code></pre>
<p>package.json:</p>
<pre><code class="language-json">{
  &quot;name&quot;: &quot;examples&quot;,
  &quot;version&quot;: &quot;0.1.0&quot;,
  &quot;private&quot;: true,
  &quot;resolutions&quot;: {
    &quot;@polkadot/api&quot;: &quot;^3.10.2&quot;,
    &quot;@polkadot/api-contract&quot;: &quot;^3.10.2&quot;
  },
  &quot;dependencies&quot;: {
    &quot;@redspot/chai&quot;: &quot;^0.10.1&quot;,
    &quot;@redspot/patract&quot;: &quot;^0.10.1&quot;,
    &quot;@types/chai&quot;: &quot;^4.2.14&quot;,
    &quot;@types/mocha&quot;: &quot;^8.0.3&quot;,
    &quot;chai&quot;: &quot;^4.2.0&quot;,
    &quot;redspot&quot;: &quot;^0.10.1&quot;,
    &quot;typescript&quot;: &quot;^4.0.2&quot;
  },
  &quot;scripts&quot;: {
    &quot;build&quot;: &quot;npx redspot compile&quot;,
    &quot;test&quot;: &quot;npx redspot test&quot;
  }
}
</code></pre>
<p>tsconfig.json:</p>
<pre><code class="language-json">{
  &quot;compilerOptions&quot;: {
    &quot;target&quot;: &quot;es5&quot;,
    &quot;module&quot;: &quot;commonjs&quot;,
    &quot;strict&quot;: true,
    &quot;esModuleInterop&quot;: true,
    &quot;outDir&quot;: &quot;dist&quot;,
    &quot;noImplicitAny&quot;: false
  },
  &quot;include&quot;: [
    &quot;**/*.ts&quot;
  ],
  &quot;exclude&quot;: [
    &quot;node_modules&quot;
  ],
  &quot;files&quot;: [
    &quot;./redspot.config.ts&quot;,
  ]
}
</code></pre>
<p>然后安装 npm 依赖（推荐使用 <a href="https://classic.yarnpkg.com/en/docs/install">yarn</a> 作为包管理器）：</p>
<pre><code>yarn 或者 npm install
</code></pre>
<p>然后在项目的根目录运行命令 <code>npx redspot compile</code> 将会编译 examples 下的所有合约，现在我们执行以下命令：</p>
<pre><code>npx redspot compile examples/erc20
</code></pre>
<p>该命令会指定编译 erc20 合约。编译完成后，你可以在 artifacts 目录下找到编译的产物。</p>
<h4><a class="header" href="#部署合约" id="部署合约">部署合约</a></h4>
<p>现在我们可以通过 Redspot 运行一个部署脚本了，在 ink 根目录创建这个文件：</p>
<p>deploy.ts</p>
<pre><code class="language-typescript">import { network, patract } from &quot;redspot&quot;;

const { getContractFactory } = patract;
const { getSigners, api } = network;

async function run() {
    console.log(&quot;deploy erc20&quot;);

    await api.isReady;

    console.log(&quot;deploy erc201&quot;);

    const signers = await getSigners();
    const signer = signers[0];

    const contractFactory = await getContractFactory(&quot;erc20&quot;, signer);

    const contract = await contractFactory.deploy(&quot;new&quot;, &quot;1000000&quot;, {
        gasLimit: &quot;200000000000&quot;,
        value: &quot;10000000000000000&quot;,
    });

    console.log(
        &quot;Deploy successfully. The contract address: &quot;,
        contract.address.toString()
    );

    api.disconnect();
}

run().catch((err) =&gt; {
    console.log(err);
});

</code></pre>
<p>然后你确保已经在 <code>redspot.config.ts</code> 中正确配置了网络: </p>
<pre><code class="language-typescript">{
	...
	networks: {
    development: {
      endpoint: 'ws://127.0.0.1:9944', // 
      types: {},
      ...
    },
  },
}
</code></pre>
<p>现在可以运行 deploy.ts 文件了，加上 <code>--no-compile</code> 防止重复编译：</p>
<pre><code class="language-bash">npx redspot run ./deploy.ts --no-compile
</code></pre>
<p>合约部署成功后，你会得到类似这样的信息：</p>
<pre><code>Deploy successfully. The contract address:  5CqB5Mh9UdVbTE1Gt5PJfWSiCHydJaJsA31HjKGti1Z2fn78
</code></pre>
<h4><a class="header" href="#测试合约" id="测试合约">测试合约</a></h4>
<p>我们在 tests 目录下新增 erc20.test.ts 文件，用来测试 erc20 合约：</p>
<p>tests/erc20.test.ts</p>
<pre><code class="language-typescript">import BN from 'bn.js';
import { expect } from 'chai';
import { patract, network, artifacts } from 'redspot';

const { getContractFactory, getRandomSigner } = patract;

const { api, getSigners } = network;

describe('ERC20', () =&gt; {
  after(() =&gt; {
    return api.disconnect();
  });

  async function setup() {
    const one = new BN(10).pow(new BN(api.registry.chainDecimals[0]));
    const signers = await getSigners();
    const Alice = signers[0];
    const sender = Alice;
    const contractFactory = await getContractFactory('erc20', sender);
    const contract = await contractFactory.deploy('new', '1000');
    const abi = artifacts.readArtifact('erc20');
    const receiver = await getRandomSigner();

    return { sender, contractFactory, contract, abi, receiver, Alice, one };
  }

  it('Assigns initial balance', async () =&gt; {
    const { contract, sender } = await setup();
    const result = await contract.query.balanceOf(sender.address);
    expect(result.output).to.equal(1000);
  });

  it('Transfer emits event', async () =&gt; {
    const { contract, sender, receiver } = await setup();

    await expect(contract.tx.transfer(receiver.address, 7))
      .to.emit(contract, 'Transfer')
      .withArgs(sender.address, receiver.address, 7);
  });

  it('Can not transfer above the amount', async () =&gt; {
    const { contract, receiver } = await setup();

    await expect(contract.tx.transfer(receiver.address, 1007)).to.not.emit(
      contract,
      'Transfer'
    );
  });

  it('Can not transfer from empty account', async () =&gt; {
    const { contract, Alice, one, sender } = await setup();

    const emptyAccount = await getRandomSigner(Alice, one.muln(10000));

    await expect(
      contract.tx.transfer(sender.address, 7, {
        signer: emptyAccount
      })
    ).to.not.emit(contract, 'Transfer');
  });
});

</code></pre>
<p>运行测试命令：</p>
<pre><code>npx redspot test --no-compile
</code></pre>
<p>你将会得到以下类似结果：</p>
<pre><code>....
✓ Can not transfer from empty account (17912ms)

  4 passing (46s)
</code></pre>
<h2><a class="header" href="#项目开发" id="项目开发">项目开发</a></h2>
<p>进入新创建的Redspot的项目的根目录下，执行以下命令可查看当前 Redspot 支持的任务（Tasks）:</p>
<pre><code class="language-bash">npx redspot
</code></pre>
<blockquote>
<p>Task 的概念请参照该文档 <a href="redspot/./overview.html#Tasks">Tasks</a>。</p>
</blockquote>
<p>运行 <code>npx redspot --help</code> 查看帮助：</p>
<pre><code>Redspot version 0.10.1

Usage: redspot [GLOBAL OPTIONS] &lt;TASK&gt; [TASK OPTIONS]

GLOBAL OPTIONS:

  --config              A Redspot config file. 
  --help                Shows this message, or a task's help if its name is provided 
  --log-level           Set log levels 1-5 
  --max-memory          The maximum amount of memory that Redspot can use. 
  --network             The network to connect to. 
  --show-stack-traces   Show stack traces. 
  --tsconfig            Reserved redspot argument -- Has no effect. 
  --verbose             Enables Redspot verbose logging 
  --version             Shows redspot's version. 


AVAILABLE TASKS:

  check         Check whatever you need
  clean         Clears the cache and deletes all artifacts
  compile       Compiles the entire project, building all artifacts
  console       Opens a redspot console
  help          Prints this message
  run           Runs a user-defined script after compiling the project
  test          Runs mocha tests

To get help for a specific task run: npx redspot help [task]
</code></pre>
<p>可以看到帮助信息有两个部分，GLOBAL OPTIONS 和 TASKS。通过 TASK ，我们可以调用Redspot内置的任务或者自定义的任务。比如</p>
<p><code>npx redspot compile</code> 可以运行编译合约命令。</p>
<p>通常每个 TASK 都会提供自己的参数配置。通过 <code>npx redspot compile --help</code> 可以查看帮助信息：</p>
<pre><code>Redspot version 0.10.1

Usage: redspot [GLOBAL OPTIONS] compile [...sourcePattern]

POSITIONAL ARGUMENTS:

  sourcePattern	A glob string that is matched against (default: [])

compile: Compiles the entire project, building all artifacts

For global options help run: redspot help
</code></pre>
<p>对于 compile 命令，我们可以传入合约的路径来指定需要编译的合约，如：<code>npx redspot compile examples/erc20</code> 。</p>
<p><code>GLOBAL OPTIONS</code> 是 Redspot 运行时的全局的配置。它可以附加到任一 TASK 中。如 <code>npx redspot test --network substrate</code> 将指定连接到 substrate 网络（需要在 config 中配置 substrate 网络）。<code>npx redspot test --log-level 3</code> 将指定打印的日志的级别，默认为2 。我们也可以通过环境变量设置 <code>GLOBAL OPTIONS</code> ：</p>
<ul>
<li>设置 log level: <code>REDSPOT_LOG_LEVEL=5 npx redspot test</code> ,</li>
<li>设置 network: <code>REDSPOT_NETWORK=substrate npx redspot test</code>.</li>
</ul>
<p>下面我们来介绍一下内置的几个 TASK：</p>
<h3><a class="header" href="#compile" id="compile">Compile</a></h3>
<p>运行 <code>npx redspot compile</code> 命令将会进行合约编译。目前支持 <a href="https://github.com/paritytech/ink">ink </a> 合约和 <a href="https://github.com/hyperledger-labs/solang">solang</a> 合约的编译。编译 ink 合约时，请确保你已经安装了 <a href="https://github.com/paritytech/cargo-contract">cargo-contract</a> 。编译 solang 合约时，请确保你已经安装了 <a href="https://solang.readthedocs.io/en/latest/installing.html#building-solang-from-crates-io">solang cli</a>。在 <code>redspot.config.ts</code> 中，你可以配置编译的选项：</p>
<pre><code>{
	...
	contract: {
    ink: {
      toolchain: 'nightly', // 设置 cargo-contract 编译时的 toolchain
      sources: ['contracts/**/*'] // 配置查找合约文件的目录
    },
    solang: {
      sources: ['contracts/**/*.sol'] // 配置查找合约文件的目录
    }
  },
  paths: {
  	...
    artifacts: 'artifacts' // 指定存放合约编译产物的目录
    ...
  }，
  ...
}
</code></pre>
<p>compile 命令接收 sourcePattern 参数，可以覆盖配置文件中的 sources , 例子：</p>
<p><code>npx redspot compile examples/erc20</code></p>
<p>将仅在 <code>examples/erc20</code> 目录下查找合约。</p>
<p>编译完成后，可以在 <code>artifacts</code> 目录中找到编译的产物。 通常将会有两种格式，<code>[ContractName].contract</code> 和<code>[ContractName].json</code> ，他们之间唯一的区别就是 <code>.json </code> 中不包含 wasm，体积会小一些。你也可以使用自己的工具编译，然后将 <code>[ContractName].contract</code>文件复制到 artifacts 目录中。这样也不会影响到其他功能的使用。</p>
<h3><a class="header" href="#test" id="test">Test</a></h3>
<p>自动化测试在编写合约中至关重要。你可以使用 Redspot 进行单元测试。在运行测试命令前，你需要确保已经正确配置了需要连接的节点。Test 的相关配置如下：</p>
<pre><code>{
	defaultNetwork: &quot;development&quot;, // 默认连接的网络
	...
	networks: {
			development: {
          endpoint: &quot;ws://127.0.0.1:9944&quot;, // 链接的网络的url（websocket）
          types: {}, // 传递给 polkadotjs 使用的类型定义
          accounts: [&quot;//Alice&quot;, &quot;tomato mad peasant blush poem obtain inspire distance attitude mercy return marriage&quot;] // 用来签名的账号，默认为 ['//Alice', '//Bob', '//Charlie', '//Dave', '//Eve', '//Ferdie']
          gasLimit: &quot;400000000000&quot;, // 默认的 gaslimit
      },
	}，
	path: {
		tests: 'tests', // 查找测试文件的目录
	},
	mocha: {
		timeout: 60000, // mocha 测试时的超时时间
		...
	}
	...
}
</code></pre>
<p>你可以通过传入 network 选项，配置测试时连接的网络，例子：</p>
<p><code>REDSPOT_NETWORK=development npx redpost test  </code> </p>
<p>你也可以仅对单个文件进行测试<code>npx redspot test ./tests/[filename].ts</code>。设置 <code>--no-compile</code> 可以避免自动运行编译命令 <code>npx redspot test --no-compile</code>。</p>
<p>Test 默认使用 mocha 作为测试框架。你可以在 <code>redspot.config.ts</code>文件中配置mocha的选项。这里是所有支持的选项：https://mochajs.org/api/mocha 。</p>
<p>一个完整的测试文件如下：</p>
<pre><code class="language-typescript">import BN from 'bn.js';
import { expect } from 'chai';
import { patract, network, artifacts } from 'redspot';

const { getContractFactory, getRandomSigner } = patract;

const { api, getSigners } = network;

describe('ERC20', () =&gt; {
  after(() =&gt; {
    return api.disconnect();
  });

  async function setup() {
    const one = new BN(10).pow(new BN(api.registry.chainDecimals[0]));
    const signers = await getSigners();
    const Alice = signers[0];
    const sender = Alice;
    const contractFactory = await getContractFactory('erc20', sender);
    const contract = await contractFactory.deploy('new', '1000');
    const abi = artifacts.readArtifact('erc20');
    const receiver = await getRandomSigner();

    return { sender, contractFactory, contract, abi, receiver, Alice, one };
  }

  it('Assigns initial balance', async () =&gt; {
    const { contract, sender } = await setup();
    const result = await contract.query.balanceOf(sender.address);
    expect(result.output).to.equal(1000);
  });

  it('Transfer emits event', async () =&gt; {
    const { contract, sender, receiver } = await setup();

    await expect(contract.tx.transfer(receiver.address, 7))
      .to.emit(contract, 'Transfer')
      .withArgs(sender.address, receiver.address, 7);
  });

  it('Can not transfer above the amount', async () =&gt; {
    const { contract, receiver } = await setup();

    await expect(contract.tx.transfer(receiver.address, 1007)).to.not.emit(
      contract,
      'Transfer'
    );
  });

  it('Can not transfer from empty account', async () =&gt; {
    const { contract, Alice, one, sender } = await setup();

    const emptyAccount = await getRandomSigner(Alice, one.muln(10000));

    await expect(
      contract.tx.transfer(sender.address, 7, {
        signer: emptyAccount
      })
    ).to.not.emit(contract, 'Transfer');
  });
});
</code></pre>
<p>我们在 setup 函数中，创建了一个随机的账号，并且给这个账号分配了固定的余额。然后用这个账号进行各种测试，这样以保证每次得到的测试结果都是相同的。</p>
<p>在这个测试文件中，我们用到了两个 Redspot 的插件， @redspot/patract 和 @redspot/chai ，我们会在之后的文章中，详细介绍他们。</p>
<p>实际上，不是非得要用 <code>npx redspot test</code> 才能运行这个测试文件。Test 命令仅仅只是简单的对 mocha 命令封装了一下。你可以使用任何你喜欢的方式，运行测试代码。这中间没有魔法。比如，可以尝试着执行一下命令，运行测试用例：</p>
<p><code>TS_NODE_TRANSPILE_ONLY=true mocha -r ts-node/register tests/erc20.test.ts --timeout 60000</code> </p>
<p>其中我们使用 ts-node 编译运行 typescript 代码，因此需要加上 <code>-r ts-node/register</code> 。<code>TS_NODE_TRANSPILE_ONLY=true </code> 设置 ts-node 运行时忽略 typescript 类型错误。</p>
<h3><a class="header" href="#run" id="run">Run</a></h3>
<p>Run 命令可以用来运行任一 typescript 文件。设置 <code>--no-compile</code> 可以避免自动运行编译命令 <code>npx redspot run --no-compile</code>。</p>
<p>和 Test 一样，它也仅仅只是 <code>TS_NODE_TRANSPILE_ONLY=true node -r ts-node/register [filepath]</code>. 的简单封装而已。</p>
<p>通常我们可以使用 Run 来运行部署脚本：</p>
<pre><code class="language-typescript">import { network, patract } from &quot;redspot&quot;;

const { getContractFactory } = patract;
const { getSigners, api } = network;

async function run() {
    console.log(&quot;deploy erc20&quot;);

    await api.isReady;

    console.log(&quot;deploy erc201&quot;);

    const signers = await getSigners();
    const signer = signers[0];

    const contractFactory = await getContractFactory(&quot;erc20&quot;, signer);

    const contract = await contractFactory.deploy(&quot;new&quot;, &quot;1000000&quot;, {
        gasLimit: &quot;200000000000&quot;,
        value: &quot;10000000000000000&quot;,
    });

    console.log(
        &quot;Deploy successfully. The contract address: &quot;,
        contract.address.toString()
    );

    api.disconnect();
}

run().catch((err) =&gt; {
    console.log(err);
});

</code></pre>
<p>这其中使用了 <code>@redspot/patract</code> 插件。我们会在后面的文章中详细解释。</p>
<h3><a class="header" href="#console" id="console">Console</a></h3>
<p>你可以通过运行 <code>npx redspot console</code> 来启动一个node 的 <a href="https://nodejs.dev/learn/how-to-use-the-nodejs-repl"><em>REPL</em></a> 控制台。它内置了 Redspot Runtime Environment ，所以你在其中可以访问 Redspot 提供插件，配置，任务。我们会在后面有一个详细的说明。</p>
<p>可以在 https://github.com/patractlabs/redspot/tree/master/examples/ 查看更多示例。</p>
<h1><a class="header" href="#介绍-1" id="介绍-1">介绍</a></h1>
<h2><a class="header" href="#redspot-的架构" id="redspot-的架构">Redspot 的架构</a></h2>
<p>Redspot是围绕任务（Tasks）和插件（Plugins）的概念设计的。Redspot的大部分功能来自插件，作为开发人员，您可以自由选择要使用的插件。</p>
<h3><a class="header" href="#tasks" id="tasks">Tasks</a></h3>
<p>每次从cli运行Redspot时，您都在运行任务。例如执行命令 <code>npx redspot compile</code> 是运行编译任务。 要查看项目中当前可用的任务，请运行<code>npx redspot</code>。 通过运行<code>npx redspot help [task]</code>可以查看任何任务的帮助。</p>
<h3><a class="header" href="#plugins" id="plugins">Plugins</a></h3>
<p>Redspot默认情况下安装了一些插件，如果您需要手动安装或升级它们，请按照以下步骤操作。</p>
<p>例如希望安装<code>@redspot/patract</code> 和 <code>@redspot/chai</code> 插件，进入项目根目录后按照以下命令可以安装</p>
<pre><code class="language-bash">yarn add @redspot/patract @redspot/chai
</code></pre>
<p>在项目的目录中的redspot 配置文件<code>redspot.config.js</code>中添加</p>
<pre><code class="language-typescript">import { RedspotUserConfig } from 'redspot/types';
import '@redspot/patract';
import '@redspot/chai';

export default {
 ...
} as RedspotUserConfig;
</code></pre>
<h1><a class="header" href="#配置" id="配置">配置</a></h1>
<p>运行Redspot时，它将从当前工作目录开始搜索最接近的redspot.config.js文件。该文件通常位于项目的根目录中。</p>
<p>此文件中包含整个Redspot设置（例如配置，插件和自定义任务等）。</p>
<h2><a class="header" href="#配置选项" id="配置选项">配置选项</a></h2>
<p>要设置配置，需要从 redspot.config.ts 导出对象（object）：</p>
<pre><code class="language-typescript">import { RedspotUserConfig } from 'redspot/types';

export default {
  defaultNetwork: 'development',
  contract: {
    ink: {
      toolchain: 'nightly',
      sources: ['contracts/**/*']
    },
    solang: {
      sources: ['contracts/**/*.sol']
    }
  },
  networks: {
    development: {
      endpoint: 'ws://127.0.0.1:9944',
      types: {},
      gasLimit: '400000000000'
    },
    substrate: {
      endpoint: 'ws://127.0.0.1:9944',
      gasLimit: '400000000000',
      accounts: ['//Alice', &quot;tomato mad peasant blush poem obtain inspire distance attitude mercy return marriage&quot;, &quot;0x26aa394eea5630e07c48ae0c9558cef70a98fdbe9ce6c55837576c60c7af3850&quot;],
      types: {}
    }
  },
  paths: {
    artifacts: &quot;artifacts&quot;,
    tests: &quot;tests&quot;
  },
  mocha: {
    timeout: 60000
  }
} as RedspotUserConfig;
</code></pre>
<p>可以在 js 文件中，通过<code>config</code>获取到配置信息：</p>
<pre><code class="language-typescript">import { config } from &quot;redspot&quot;

console.log(config)
</code></pre>
<h2><a class="header" href="#defaultnetwork" id="defaultnetwork">defaultNetwork</a></h2>
<p>您可以通过配置中的 <code>defaultNetwork</code> 字段来自定义在运行Redspot时默认使用的网络。如果省略此配置，则其默认值为 <code>localhost</code>。</p>
<h2><a class="header" href="#networks" id="networks">networks</a></h2>
<p><code>networks</code> 配置字段是一个可选对象，网络名称映射到其配置。</p>
<p>默认的 <code>localhost</code> 的配置是:</p>
<pre><code class="language-typescript">{
  localhost: {
    gasLimit: &quot;400000000000&quot;,
    accounts: [&quot;//Alice&quot;, &quot;//Bob&quot;, &quot;//Charlie&quot;, &quot;//Dave&quot;, &quot;//Eve&quot;, &quot;//Ferdie&quot;],
    endpoint: &quot;ws://127.0.0.1:9944&quot;,
    types: {}
  }
}
</code></pre>
<p>也可以配置其他网络名称，例如配置<code>mainnet</code>，某个网络的名字<code>some_network_name</code>等。</p>
<pre><code class="language-typescript">{
    mainnet: {
        //...
    },
    some_network_name: {
        //...
    }
}
</code></pre>
<p>以下介绍针对<code>network</code> 部分的配置选项：</p>
<h3><a class="header" href="#networkgaslimit" id="networkgaslimit"><code>[network].gasLimit</code></a></h3>
<p>这个配置用于设置实例化或者通过交易调用合约的时候需要提供的<code>gaslimit</code>的默认值。这个值必须是整数，没有精度。</p>
<p>如果这个值过小，将会得到一个 <code>contracts.OutOfGas</code> 错误。最大的 gaslimit 是这条Substrate的链在Runtime中用于<code>DispatchClass::Normal</code>的最大值。（例如，在Substrate的node节点的配置中是 <code>NORMAL_DISPATCH_RATIO * MAXIMUM_BLOCK_WEIGHT = 75% * 2000000000000</code>）。</p>
<p>所以一般建议设置高一点。</p>
<h3><a class="header" href="#networkaccounts" id="networkaccounts"><code>[network].accounts</code></a></h3>
<p><code>accounts</code>应该是由 <a href="https://polkadot.js.org/docs/keyring/start/suri/"><code>suri</code></a> 或者 <a href="https://polkadot.js.org/docs/keyring/start/create/#adding-a-pair"><code>KeyringPair</code></a> 组成的一个列表。</p>
<p>accounts 默认为 [&quot;//Alice&quot;, &quot;//Bob&quot;, &quot;//Charlie&quot;, &quot;//Dave&quot;, &quot;//Eve&quot;, &quot;//Ferdie&quot;]。</p>
<p>具体请查见 runtime-environment </p>
<h3><a class="header" href="#networkendpoint" id="networkendpoint"><code>[network].endpoint</code></a></h3>
<p><code>endpoint</code>指明了在当前网络配置中开发者想要连接的节点。</p>
<p>当前，只支持 WebSockets 类型的 RPC 连接（即只支持 <code>wss://</code> 或者 <code>ws://</code>开头的链接协议）。</p>
<h3><a class="header" href="#networktypes" id="networktypes"><code>[network].types</code></a></h3>
<p>type 是<code>polkadotjs</code>中定义的概念。如果对此有任何疑问，您可以在此处<a href="https://polkadot.js.org/docs/api/start/types.extend/"><code>types.extend</code></a>看到。 您还可以设置<code>[network].typesbundle</code>，<code>[network].typesSpec</code>等。 通常，如果遇到类似于“No such variant in enum MultiSignature”的错误，也许应该考虑在 type 中添加 <code>{ Address: &quot;AccountId&quot;, LookupSource: &quot;AccountId&quot;}</code>， 请参阅 <a href="https://polkadot.js.org/docs/api/start/types.extend/#impact-on-extrinsics">impact-on-extrinsics</a>。</p>
<h2><a class="header" href="#contract" id="contract">contract</a></h2>
<p>在 contract 中，你可以设置编译器的选项，目前支持 <a href="https://github.com/paritytech/ink">ink</a> 和 <a href="https://github.com/hyperledger-labs/solang">solang</a>。你也可以将 ink合约 和 solang合约放在同一项目下一起编译。</p>
<p>查看多合约的编译示例 https://github.com/patractlabs/redspot/tree/master/examples/multi-contract 。</p>
<h3><a class="header" href="#contractinktoolchain" id="contractinktoolchain">[contract].ink.toolchain</a></h3>
<p>设置 <a href="https://github.com/paritytech/cargo-contract">cargo-contract</a> 编译合约时，所使用的 toolchain。通常都是 <code>nightly</code>。你也可以指定为 <code>nightly-YYYY-MM-DD</code></p>
<h3><a class="header" href="#contractinksources" id="contractinksources">[contract].ink.sources</a></h3>
<p>设置编译时查找的 ink 合约的目录。glob 语法。</p>
<h3><a class="header" href="#contractsolangsources" id="contractsolangsources">[contract].solang.sources</a></h3>
<p>设置编译时查找的 solang 合约的目录。glob 语法。</p>
<h2><a class="header" href="#paths" id="paths">Paths</a></h2>
<p>paths 可以设置  artifacts 和 tests 文件的目录名。通常情况下，你无需对此进行更改。</p>
<h2><a class="header" href="#mocha" id="mocha">mocha</a></h2>
<p>Redspot 使用 mocha 作为测试框架，这里的所有选项，都将传递给 mocha 。查看 https://mochajs.org/api/mocha ，获取更多的详情。</p>
<h1><a class="header" href="#runtime-environment" id="runtime-environment">Runtime Environment</a></h1>
<p>RedSpot 运行时环境(RSE)包含了 Redspot 所有公开的功能。</p>
<p>当你导入 Redspot (import &quot;redspot&quot;)的时候，即获得了一个 RSE 环境。</p>
<h2><a class="header" href="#访问-rse" id="访问-rse">访问 RSE</a></h2>
<p>env 有如下的属性：</p>
<pre><code>RuntimeEnvironment {
		config; // 用户的配置文件 
    redspotArguments; // 运行命令时的全局参数，包含 network , logLevel 等。
    run； // 运行命令的函数
    network; // 包含了 api , keyring 等属性。
    artifacts; // 管理合约编译的产物
}
</code></pre>
<p>在 Redspot Console 中，env 的这些属性会注入到全局变量中。你可以直接访问它们：</p>
<pre><code>&gt; network.name
'development'
</code></pre>
<p>在 js 或者 ts 文件中，你可以通过 <code>import env from 'redspot'</code> 来访问 RSE。</p>
<pre><code class="language-typescript">import { config, redspotArguments, run, network, artifacts } from 'redspot' 
</code></pre>
<h2><a class="header" href="#扩展-rse" id="扩展-rse">扩展 RSE</a></h2>
<p>一些插件可以扩展 RSE ，为 RSE 增加一些额外属性或方法。如 <code>@redspot/patract</code> 就扩展了 RSE ，提供了 patract 的实例。当引入 patract 插件后，你可以这样访问 patract 实例：</p>
<pre><code class="language-typescript">import { patract } from 'redspot' 
console.log(patract)
</code></pre>
<p>下面我们来详细介绍一下内置的 RSE 的中的各个属性：</p>
<h3><a class="header" href="#config" id="config">config</a></h3>
<p>Config 包含 redspot.config.ts 中的所有配置选项。并且包含了默认的设置。 它是一个 JSON 对象。</p>
<p>获取当前配置的默认连接的网络</p>
<pre><code class="language-typescript">import { config } from 'redspot' 
console.log(config.defaultNetwork);
</code></pre>
<h3><a class="header" href="#redspotarguments" id="redspotarguments">redspotArguments</a></h3>
<p>当前运行的命令的全局参数：</p>
<pre><code>&gt; redspotArguments
{
  network: undefined,
  showStackTraces: false,
  version: false,
  help: false,
  config: undefined,
  verbose: false,
  logLevel: '2',
  maxMemory: undefined,
  tsconfig: undefined
}
</code></pre>
<h3><a class="header" href="#run-1" id="run-1">run</a></h3>
<p>通过 run 函数，你可以在 js 或者 ts 文件中，调用 task ：</p>
<pre><code class="language-typescript">import { run } from 'redspot'

run('test') // 运行测试命令
run('test', { testFiles: './tests/erc20.test.ts'}) // 传入参数
</code></pre>
<h3><a class="header" href="#network" id="network">network</a></h3>
<p>Network 包含你当前正在运行的网络的信息。通过 network 可以获取到 api，keyring, signer 等。network 的类型定义：</p>
<pre><code class="language-typescript">export interface Network {
  name: string;
  config: NetworkConfig;
  provider: WsProvider;
  api: ApiPromise;
  registry: Registry;
  keyring: Keyring;
  getSigners(): Promise&lt;Signer[]&gt;;
  createSigner(pair: KeyringPair): Signer;
  gasLimit: BN;
}
</code></pre>
<h4><a class="header" href="#networkname" id="networkname">network.name</a></h4>
<p>当前正在使用的网络的名称</p>
<h4><a class="header" href="#networkconfig" id="networkconfig">network.config</a></h4>
<p>当前正在使用的网络的配置选项，等价于：<code>config.networks[network.name]</code></p>
<h4><a class="header" href="#networkprovider" id="networkprovider">network.provider</a></h4>
<p>相当于 polkadotjs 中的 <a href="https://polkadot.js.org/docs/api/start/create/#providers">wsprovider</a> 的实例。他们具有相同的接口。<code>redspot.config.ts</code>中配置的 endpoint 会被用于 network.provider 的实例化参数。</p>
<h4><a class="header" href="#networkregistry" id="networkregistry">network.registry</a></h4>
<p>相当于 polkadotjs 中的 Registry  的实例，用于管理类型的编解码。它也包含了用户在 <code>redspot.config.ts</code> 中配置的 <code>types</code> 类型定义。查看polkadotjs 文档，了解更多： https://polkadot.js.org/docs/api/start/types.create/。</p>
<h4><a class="header" href="#networkkeyring" id="networkkeyring">network.keyring</a></h4>
<p>相当于 polkadotjs 中的 Keyring 的实例。默认是 ss25519 类型。在 api 初始化完成后，会设置默认的 ss58 的值。查看更多关于 keyring: https://polkadot.js.org/docs/api/start/keyring。</p>
<h4><a class="header" href="#networkgetsigners" id="networkgetsigners">network.getSigners</a></h4>
<p>用户在 <code>redspot.config.ts</code> 中配置的 accounts ，会被解析成 Signer 。通过 getSigners 函数，可以获取所有的 signer。它是个数组与 accounts  中配置的账号对应。</p>
<p>获取到所有 signer：</p>
<pre><code class="language-typescript">import { network } from 'redspot';

network.getSigners().then((signers) =&gt; {
	console.log(signers[0].address)
})
</code></pre>
<p>实际上 signer 与 polkadot js 的 signer 是兼容的。signer 的类型定义：</p>
<pre><code class="language-typescript">export interface Signer {
   	address: string;
   api: ApiPromise;
   pair: KeyringPair;
   signPayload: (payload: SignerPayloadJSON) =&gt; Promise&lt;SignerResult&gt;;
}
</code></pre>
<p>你也可以将它用在 polkadotjs 中，进行交易签名：</p>
<pre><code class="language-typescript">import { network } from 'redspot';

const api = network.api

async run() {
  const signers = await network.getSigners()
  const from = signers[0]
  const to = signers[1]
  
  api.tx.balances.transfer(signer1.address, 100000000000).signAndSend({
  	signer: from
  })
}

</code></pre>
<h4><a class="header" href="#networkcreatesigner" id="networkcreatesigner">network.createSigner</a></h4>
<p>你可以通过 createSigner 函数生成一个 signer，它接收一个 keyringpair ，将其转化为 signer 实例：</p>
<pre><code class="language-typescript">const pair = keyring.createFromUri(uri)
const signer = network.createSigner(pair)
</code></pre>
<h4><a class="header" href="#networkgaslimit-1" id="networkgaslimit-1">network.gasLimit</a></h4>
<p>它来自于 config 中的 gaslimt，并且被解析成 bn 类型。</p>
<h3><a class="header" href="#artifacts" id="artifacts">artifacts</a></h3>
<p>通过 artifacts ，你可以访问和管理 abi。它的类型定义如下：</p>
<pre><code class="language-typescript">export interface Artifacts {
  readArtifact(contractName: string): Promise&lt;AbiMetadata&gt;;
  readArtifactSync(contractName: string): AbiMetadata;
  readAllArtifact(): Promise&lt;AbiMetadata[]&gt;;
  readAllArtifactSync(): AbiMetadata[];
  getArtifactPath(contractName: string): Promise&lt;string&gt;;
  getArtifactPathSync(contractName: string): string;
  artifactExists(contractName: string): Promise&lt;boolean&gt;;
  getArtifactPaths(): Promise&lt;string[]&gt;;
  copyToArtifactDir(paths: string[]): Promise&lt;void&gt;;
}
</code></pre>
<h4><a class="header" href="#artifactsreadartifact" id="artifactsreadartifact">artifacts.readArtifact</a></h4>
<p>通过合约名字，获取合约的 metadata，它会返回一个 JSON 对象:</p>
<pre><code class="language-typescript">{
  metadataVersion: string;
  source: {
    hash: string;
    language: string;
    compiler: string;
    wasm: string;
  };
  contract: {
    name: string;
    version: string;
    authors: string[];
  };
  types: any[];
  spec: {
    constructors: any[];
    docs: any[];
    events: any[];
    messages: any[];
  };
}
</code></pre>
<p>其中 wasm 就是合约编译出来的 wasm 文件。</p>
<h4><a class="header" href="#artifactsreadartifactsync" id="artifactsreadartifactsync">artifacts.readArtifactSync</a></h4>
<p><code>artifacts.readArtifact</code> 的同步版本。</p>
<h4><a class="header" href="#artifactsreadallartifact" id="artifactsreadallartifact">artifacts.readAllArtifact</a></h4>
<p>获取所有的合约的 metadata。</p>
<h4><a class="header" href="#artifactsreadallartifactsync" id="artifactsreadallartifactsync">artifacts.readAllArtifactSync</a></h4>
<p><code>artifacts.readAllArtifact</code> 的同步版本。</p>
<h4><a class="header" href="#artifactsgetartifactpath" id="artifactsgetartifactpath">artifacts.getArtifactPath</a></h4>
<p>获取指定合约的 metadata 的文件路径。</p>
<h4><a class="header" href="#artifactsgetartifactpathsync" id="artifactsgetartifactpathsync">artifacts.getArtifactPathSync</a></h4>
<p><code>artifacts.getArtifactPath</code> 的同步版本</p>
<h4><a class="header" href="#artifactsartifactexists" id="artifactsartifactexists">artifacts.artifactExists</a></h4>
<p>判断一个合约的 metadata 是否存在</p>
<h4><a class="header" href="#artifactsgetartifactpaths" id="artifactsgetartifactpaths">artifacts.getArtifactPaths</a></h4>
<p>获取所有合约的 metadata 的文件路径。</p>
<h4><a class="header" href="#artifactscopytoartifactdir" id="artifactscopytoartifactdir">artifacts.copyToArtifactDir</a></h4>
<p>将文件拷贝到 artifact 目录</p>
<h1><a class="header" href="#控制台console" id="控制台console">控制台console</a></h1>
<p>Redspot 提供了一个功能强大的控制台，允许开发者简单的使用命令与合约做操作，或调用位于<code>scripts</code>目录下的脚本做机械化的重复工作等等。</p>
<p>Redspot 的控制台还有很多丰富的特性：</p>
<ul>
<li>提供了<strong>强大的tab补全</strong>能力</li>
<li>控制台记录了命令历史，开发者能够查看<code>cache/console-history.txt</code>文件获取历史执行过的命令，也可以通过<code>↑</code>按键找到需要的历史命令。将来控制台也会提供快捷键索引历史命令的功能。</li>
</ul>
<h2><a class="header" href="#启动控制台" id="启动控制台">启动控制台</a></h2>
<pre><code class="language-bash">$ npx redspot console
# 若已经确定在`artifacts`目录下编译好的合约符合自己预期，则可以加上 --no-compile 参数不进行合约编译
$ npx redspot console --no-compile
</code></pre>
<p>此时执行<code>.help</code>命令可以看到相应的帮助：</p>
<pre><code class="language-bash">&gt; .help
.break    Sometimes you get stuck, this gets you out
.clear    Alias for .break
.editor   Enter editor mode
.exit     Exit the repl
.help     Print this help message
.load     Load JS from a file into the REPL session
.save     Save all evaluated commands in this REPL session to a file
&gt; 
</code></pre>
<h2><a class="header" href="#常用命令" id="常用命令">常用命令</a></h2>
<p>控制台默认导入了<code>redspot</code>库下的供合约交互的组件，如</p>
<ul>
<li><code>patract</code></li>
<li><code>network</code> </li>
<li>...</li>
</ul>
<p>与在<code>scripts</code>目录下的脚本一致，通过这些组件可以调用许多功能，如和合约交互，查询信息，查看网络等等。</p>
<h3><a class="header" href="#常用工作流" id="常用工作流">常用工作流</a></h3>
<p>举例：当前想要调试erc20合约。那么在合约编译好后，可以在<code>artifacts</code>目录下看到<code>erc20.json</code>和<code>erc20.wasm</code>文件。加载合约相关的操作需要以这里的文件名为标示。</p>
<p>例如如果仿照<code>scripts</code>目录下的<code>deploy.ts</code>部署脚本，我们可以直接在控制台执行部署合约并调用的命令：</p>
<pre><code class="language-typescript">var factory = await patract.getContractFactory('erc20'); // erc20与文件名一致
var contract = await factory.deployed('new', 10000000); // 上传代码并实例化这个合约
</code></pre>
<p>如果是已知一个合约的地址，想在先加载这个合约实例则可以通过：</p>
<pre><code class="language-typescript">var factory = await patract.getContractFactory('erc20'); // erc20与文件名一致
var contract = await factory.attach('16DHBsUan9GoedoTYJmbyBZJMmN39ZpKUPvYeAGMTXCgxLQe'); // 加载合约地址
</code></pre>
<p>此时这里的<code>contract</code>对象就是一个实例化好的对象。因此后续可以直接用这个<code>contract</code>对象与合约进行交互，例如调用一个转账功能：</p>
<pre><code class="language-typescript">var ret = await contract.transfer(&quot;15Jbynf3EcRqdHV1K14LXYh7PQFTbp5wiXfrc4kbMReR9KxA&quot;, 100)
ret.events // 打印events的信息
</code></pre>
<p>如果是为了通过rpc调用获取执行某个方法的结果：</p>
<pre><code class="language-typescript">var ret = await contract.balanceOf(&quot;15Jbynf3EcRqdHV1K14LXYh7PQFTbp5wiXfrc4kbMReR9KxA&quot;)
ret.output.toString()
</code></pre>
<p>如果这个过程是比较固定的，则可以把以上命令写到一个文件中放到<code>scripts</code>目录下，例如命名为<code>scripts/do_something.ts</code>：</p>
<pre><code class="language-typescript">var factory = await patract.getContractFactory('erc20');
var contract = await factory.deployed('new', 10000000); 
var ret = await contract.transfer(&quot;15Jbynf3EcRqdHV1K14LXYh7PQFTbp5wiXfrc4kbMReR9KxA&quot;, 100)
ret.events
</code></pre>
<p>然后使用以下命令即可自动化执行一系列过程：</p>
<pre><code class="language-typescript">.load scripts/do_something.ts
</code></pre>
<p>因此控制台辅助的功能如下：</p>
<p><img src="redspot/./imgs/process.jpg" alt="" /></p>
<h1><a class="header" href="#q--a" id="q--a">Q &amp; A</a></h1>
<h3><a class="header" href="#如何升级-redspot" id="如何升级-redspot">如何升级 Redspot</a></h3>
<p>redspot 仅仅是一本普通的 npm package 。所以升级方式和其他 npm package 一样。</p>
<p><code>npm upgrade</code> 升级所有依赖</p>
<p><code>npm upgrade redspot</code> 仅升级 redspot</p>
<p>如果你使用的是 yarn</p>
<p><code>yarn upgrade-interactive --latest</code>  将所有依赖升级到稳定版</p>
<p>你可以可以直接手动更改 package.json 中的版本号，然后重新安装依赖 ：</p>
<pre><code class="language-json">{
  &quot;name&quot;: &quot;erc20&quot;,
  &quot;version&quot;: &quot;0.1.0&quot;,
  &quot;private&quot;: true,
  &quot;dependencies&quot;: {
    &quot;@redspot/chai&quot;: &quot;^0.10.2-1&quot;,
    &quot;@redspot/gas-reporter&quot;: &quot;^0.10.2-1&quot;,
    &quot;@redspot/patract&quot;: &quot;^0.10.2-1&quot;,
    &quot;@types/chai&quot;: &quot;^4.2.14&quot;,
    &quot;@types/mocha&quot;: &quot;^8.0.3&quot;,
    &quot;chai&quot;: &quot;^4.2.0&quot;,
    &quot;redspot&quot;: &quot;^0.10.2-1&quot;,
    &quot;typescript&quot;: &quot;^4.0.2&quot;
  },
  &quot;scripts&quot;: {
    &quot;build&quot;: &quot;npx redspot compile&quot;,
    &quot;test&quot;: &quot;npx redspot test&quot;
  }
}
</code></pre>
<p>注意，最好同时将所有的插件升级到最新版。</p>
<h3><a class="header" href="#使用-erc20-trait-时无法调用合约" id="使用-erc20-trait-时无法调用合约">使用 erc20-trait 时，无法调用合约</a></h3>
<p>由于 erc20-trait 多了命名空间，所以在调用的时候也必须加上命名空间。例子：</p>
<pre><code class="language-typescript">// erc20
contractFactory.deploy(&quot;new&quot;, &quot;1000000&quot;)
// erc20-trait
contractFactory.deploy(&quot;baseErc20,new&quot;, &quot;1000000&quot;)

// erc20
contract.query.balanceOf(someaddress)
// erc20-trait
contract.query[&quot;baseErc20,balanceOf&quot;](someaddress)

// erc20
contract.tx.transfer(receiver.address, 7))
// erc20-trait
contract.tx[&quot;baseErc20,transfer&quot;](receiver.address, 7))
</code></pre>
<h3><a class="header" href="#如何保证线上私钥的安全避免上传到-github" id="如何保证线上私钥的安全避免上传到-github">如何保证线上私钥的安全，避免上传到 github</a></h3>
<p>可以使用环境变量配置 account，如：</p>
<pre><code class="language-typescript">// redspot.config.ts
import { RedspotUserConfig } from 'redspot/types';


export default {
 ...
  network: {
    mainnet: {
      ...
      account: [process.env.ACCOUNT]
      ...
    }
  }
} as RedspotUserConfig;
</code></pre>
<p>运行脚本：</p>
<pre><code class="language-bash">REDSPOT_NETWORK=mainnet ACCOUNT=&quot;//Alice&quot; npx redspot run ./scripts/deploy.ts
</code></pre>
<p>你也可以使用 <a href="https://github.com/motdotla/dotenv">dotenv </a> 等工具。</p>
<h1><a class="header" href="#插件" id="插件">插件</a></h1>
<p>Redspot 的核心功能包括 Redspot runtime environment 和编译合约，运行测试，运行脚本这几个任务。</p>
<p>其他诸如与合约的测试套件，合约交互，访问合约，设置不同的链的配置，等功能均有插件提供。用户可以自行选择需要使用的插件。引入一个插件很简单。将它作为一个 npm 的依赖添加。然后在 <code>redspot.config.ts</code> 中加入：</p>
<pre><code class="language-typescript">import { RedspotUserConfig } from 'redspot/types';
import '@redspot/patract'; // 引入 @redspot/patract 插件
import '@redspot/chai'; // 引入 @redspot/chai 插件

export default {
 ...
} as RedspotUserConfig;
</code></pre>
<p>下面我们介绍一下官方提供的几个插件：</p>
<h2><a class="header" href="#redspotpatract" id="redspotpatract">@redspot/patract</a></h2>
<p>该插件会扩展 Redspot runtime environment ，并添加 patract 属性，可以这样访问 patract 实例：</p>
<pre><code class="language-typescript">import { patract } from 'redspot' 
</code></pre>
<p>patract 的类型定义如下：</p>
<pre><code class="language-typescript">interface Patract {
     Contract: Contract;
     ContractFactory: ContractFactory;
    /**
     * Generating Contract Instance from Contract Addresses
     *
     * @param contractName Contract name
     * @param address contract address
     * @param signer The account used to sign, or the first account in the user configured if it is undefined.
     * @returns Contract Instance
     */
    getContractAt(
      contractName: string,
      address: AccountId | string,
      signer?: Signer
    ): Promise&lt;Contract&gt;;
    /**
     * Return the contract factory
     *
     * @param contractName Contract name
     * @param signer The account used to sign, or the first account in the user configured if it is undefined.
     * @returns Contract Factory Instance
     */
    getContractFactory(
      contractName: string,
      signer?: Signer
    ): Promise&lt;ContractFactory&gt;;
    /**
     *  Generate a random account and transfer token to it
     *
     * @param from This account will be transferred to the new account
     * @param amount The amount transferred to the new account
     * @returns New Account
     */
    getRandomSigner(
      from?: Signer,
      amount?: BN | number | string | BigInt
    ): Promise&lt;Signer&gt;;
  
  };
</code></pre>
<h4><a class="header" href="#getrandomsignerfrom-amount-promisesigner" id="getrandomsignerfrom-amount-promisesigner"><code>getRandomSigner(from, amount): Promise&lt;Signer&gt;</code></a></h4>
<p>getRandomSigner 是一个工具函数，用于创建生成随机的signer，并且从 from 传递一些初始的金额给它。</p>
<h4><a class="header" href="#getcontractfactorycontractname-signer--promisecontractfactory" id="getcontractfactorycontractname-signer--promisecontractfactory"><code>getContractFactory(contractName, signer?):  Promise&lt;ContractFactory&gt;</code></a></h4>
<p>该函数将通过合约名字和 signer ，创建一个 contractFactory 的实例。</p>
<p>注意合约必须已编译成功。能够在 artifacts 找到对于的 metadata 文件。</p>
<h4><a class="header" href="#getcontractatcontractname-address-signer-promisecontract" id="getcontractatcontractname-address-signer-promisecontract"><code>getContractAt(contractName, address, signer): Promise&lt;Contract&gt;</code></a></h4>
<p>通过合约名字，合约地址和 signer，创建一个 Contract 实例。</p>
<p>注意合约必须已编译成功。能够在 artifacts 找到对于的 metadata 文件。</p>
<p>###ContractFactory</p>
<p>ContractFactory 主要用于合约的部署：</p>
<pre><code class="language-typescript">import { patract } from 'redspot'
const { getContractFactory, getRandomSigner } = patract;

const signers = await getSigners();
const contractFactory = await getContractFactory('erc20', signers[0]);
const contract = await contractFactory.deploy('new', '1000');
</code></pre>
<h4><a class="header" href="#new-contractfactoryaddress-contractmetadata-api-signer" id="new-contractfactoryaddress-contractmetadata-api-signer"><code>new ContractFactory(address, contractMetadata, api, signer) </code></a></h4>
<p>通过合约地址，metadata，api  和  signer 创建一个 contractFactory  实例。</p>
<h4><a class="header" href="#contractfactorydeployconstructororid-args--overrides---promisecontract" id="contractfactorydeployconstructororid-args--overrides---promisecontract"><code>contractFactory.deploy(constructorOrId, ...args[ , overrides ]):  Promise&lt;Contract&gt;</code></a></h4>
<p>constructorOrId 是需要调用的合约的 contructor 的名字，注意对于一些使用了 <code>trait</code> 的合约，contructor  的名字应该是类似这样：</p>
<pre><code class="language-typescript">const contract = await contractFactory.deploy('baseErc20,new', '1000');
</code></pre>
<p>args 是你所使用的 contructor 需要传入参数列表。</p>
<p>overrides 是可选项，可以用于指定 gasLimit, value, signer, salt 等。</p>
<pre><code class="language-typescript">const contract = await contractFactory.deploy('baseErc20,new', '1000', {
  gaslimit: '1000000000000000000',
  salt: 'jkqwezlkwklqreqw',
  signer: signers[1],
  value: '3213321000000000000000000'
});
</code></pre>
<p>gasLimit 指这次交易能够使用的最大的 gas 值。</p>
<p>salt 用于合约的地址的生成。部署人，部署参数和 salt 一致的话，将会生成同一个合约地址。</p>
<p>signer 创建 contractFactory 时，会有一个 signer 参数，用于默认的交易签名。 signer 项目可以覆盖默认的签名账户。</p>
<p>value 指传递给即将创建的合约的金额。</p>
<p>请注意，<code>@redspot/patract</code> 不会处理数字金额精度，需要用户自行处理。</p>
<h4><a class="header" href="#contractfactorydeployedconstructororid-args--overrides---promisecontract" id="contractfactorydeployedconstructororid-args--overrides---promisecontract"><code>contractFactory.deployed(constructorOrId, ...args[ , overrides ]):  Promise&lt;Contract&gt;</code></a></h4>
<p>该方法和 <code>contractFactory.deploy</code> 类似，唯一的区别是，<code>deployed</code> 会预先检查即将生成的合约地址是否存在，如果存在不会去尝试部署，而是直接使用该合约地址创建 <code>Contract</code> 实例。</p>
<h4><a class="header" href="#contractfactoryinstantiateconstructororid-args--overrides---promisecontractaddress" id="contractfactoryinstantiateconstructororid-args--overrides---promisecontractaddress"><code>contractFactory.instantiate(constructorOrId, ...args[ , overrides ]):  Promise&lt;ContractAddress&gt;</code></a></h4>
<p>如果 wasm 已上传到链上，你可以直接调用 <code>contractFactory.instantiate</code> 实例化合约。它的参数与 <code>deploy</code> 一致，但返回的是合约地址。</p>
<h4><a class="header" href="#contractfactoryinstantiateconstructororid-args--overrides---promisecontractaddress-1" id="contractfactoryinstantiateconstructororid-args--overrides---promisecontractaddress-1"><code>contractFactory.instantiate(constructorOrId, ...args[ , overrides ]):  Promise&lt;ContractAddress&gt;</code></a></h4>
<p>如果 wasm 已上传到链上，你可以直接调用 <code>contractFactory.instantiate</code> 实例化合约。它的参数与 <code>deploy</code> 一致，但返回的是合约地址。</p>
<h4><a class="header" href="#contractfactoryattachaddresscontract" id="contractfactoryattachaddresscontract"><code>contractFactory.attach(address)：Contract</code></a></h4>
<p>使用指定的合约地址生成 <code>Contract</code> 实例</p>
<p>####<code>contractFactory.connect(signer)：contractFactory</code></p>
<p>使用指定的 signer，创建一个新的 contractFactory 实例</p>
<h3><a class="header" href="#contract-1" id="contract-1">Contract</a></h3>
<h4><a class="header" href="#new-contractaddress-contractmetadata-api-signer" id="new-contractaddress-contractmetadata-api-signer"><code>new Contract(address, contractMetadata, api, signer) </code></a></h4>
<p>通过合约地址，合约的metadata，api  和  signer 创建一个 contractFactory  实例。</p>
<h4><a class="header" href="#contractquerymessagenameargs-overrides" id="contractquerymessagenameargs-overrides"><code>contract.query.MessageName(...args[, overrides])</code></a></h4>
<p>与 polkadotjs 中类似， contract.query[MessageName] 能够调用 <code>contracts.call</code> rpc。如在 erc20 合约中，获取账户余额：</p>
<pre><code class="language-typescript">const result = await contract.query.balanceOf(someaddress)
</code></pre>
<p>返回值的类型如下：</p>
<pre><code class="language-typescript">export interface ContractCallOutcome {
    debugMessage: Text;
    gasConsumed: u64;
    output: Codec | null;
    result: ContractExecResultResult;
}
</code></pre>
<p>它和 polkadotjs api-contract 中是一致。</p>
<p>overrides 是可选项，可以用于指定 gasLimit, value 等。</p>
<pre><code class="language-typescript">const contract = await contract.query.balanceOf('baseErc20,new', '1000', {
	gasLimit：'1231231231233123123'
  value: '3213321000000000000000000'
  signer： signers[1]
});
</code></pre>
<p>gasLimit value 指的是 <code>contracts.call</code> rpc 中的 gasLimit 和 value 。signer 可以指定 <code>contracts.call</code> 的 origin 地址。</p>
<h4><a class="header" href="#contractestimategasmessagenameargs-overrides" id="contractestimategasmessagenameargs-overrides"><code>contract.estimateGas.MessageName(...args[, overrides])</code></a></h4>
<p>该函数与 <code>contract.query.MessageName</code> 类似，但返回值是预估将要消耗的 gas</p>
<pre><code class="language-typescript">const result = await contract.estimateGas.balanceOf(someaddress)
result // BN(232130000000)
</code></pre>
<h4><a class="header" href="#contracttxmessagenameargsoverrides" id="contracttxmessagenameargsoverrides"><code>contract.tx.MessageName(...args[,overrides])</code></a></h4>
<p>通过  <code>contract.tx.MessageName</code> 可以执行合约的交易。 如：</p>
<pre><code class="language-typescript">const result = await contract.tx.transfer(someddress, 7)
</code></pre>
<p>和 polkadotjs 不同，该函数会返回一个 promise ， 会等到 交易上链，或者出错才被 resolved。</p>
<p>返回值类型如下：</p>
<pre><code class="language-typescript">export interface TransactionResponse {
  from: string;
  txHash?: string;
  blockHash?: string;
  error?: {
    message?: any;
    data?: any;
  };
  result: SubmittableResult;
  events?: DecodedEvent[];
}

export interface DecodedEvent {
  args: Codec[];
  name: string;
  event: AbiEvent;
}
</code></pre>
<p>你可以直接通过 <code>result.events</code> 获取已解析的合约的事件。如果执行出错，你可以通过 <code>result.error.message</code> 获取错误信息。</p>
<p>overrides 是可选项，可以用于指定 gasLimit，value，signer  等。</p>
<pre><code class="language-typescript">const contract = await contract.tx.transfer(someddress, 7, {
  gasLimit：'1231231231233123123'
  value: '3213321000000000000000000'
  signer： signers[1]
});
</code></pre>
<p>ggasLimit 指这次交易能够使用的最大的 gas 值。</p>
<p>value 指传递给即将创建的合约的金额。</p>
<p>signer 用于覆盖默认的 signer。</p>
<h4><a class="header" href="#contractattachaddresscontract" id="contractattachaddresscontract"><code>contract.attach(address)：Contract</code></a></h4>
<p>使用指定的合约地址生成 <code>Contract</code> 实例</p>
<p>####<code>contract.connect(signer)：contractFactory</code></p>
<p>使用指定的 signer，创建一个新的 contract 实例</p>
<h2><a class="header" href="#redspotchai" id="redspotchai">@redspot/chai</a></h2>
<p>该插件提供了一组便于编写合约测试用例的匹配器，灵感来自于 <a href="https://ethereum-waffle.readthedocs.io/en/latest/matchers.html">waffle</a> 。</p>
<p>引入 @redspot/chai。该插件会自动修改 chai 匹配器，无需手动调用。</p>
<pre><code>// redspot.config.ts

import { RedspotUserConfig } from 'redspot/types';
import '@redspot/chai'; 

export default {
 ...
} as RedspotUserConfig;
</code></pre>
<p>使用 @redspot/chai 的完整例子：</p>
<pre><code class="language-typescript">import BN from 'bn.js';
import { expect } from 'chai';
import { patract, network, artifacts } from 'redspot';

const { getContractFactory, getRandomSigner } = patract;

const { api, getSigners } = network;

describe('ERC20', () =&gt; {
  after(() =&gt; {
    return api.disconnect();
  });

  async function setup() {
    const one = new BN(10).pow(new BN(api.registry.chainDecimals[0]));
    const signers = await getSigners();
    const Alice = signers[0];
    const sender = Alice;
    const contractFactory = await getContractFactory('erc20', sender);
    const contract = await contractFactory.deploy('new', '1000');
    const abi = artifacts.readArtifact('erc20');
    const receiver = await getRandomSigner();

    return { sender, contractFactory, contract, abi, receiver, Alice, one };
  }

  it('Assigns initial balance', async () =&gt; {
    const { contract, sender } = await setup();
    const result = await contract.query.balanceOf(sender.address);
    expect(result.output).to.equal(1000);
  });

  it('Transfer adds amount to destination account', async () =&gt; {
    const { contract, receiver } = await setup();
    await expect(() =&gt;
      contract.tx.transfer(receiver.address, 7)
    ).to.changeTokenBalance(contract, receiver, 7);

    await expect(() =&gt;
      contract.tx.transfer(receiver.address, 7)
    ).to.changeTokenBalances(contract, [contract.signer, receiver], [-7, 7]);
  });

  it('Transfer emits event', async () =&gt; {
    const { contract, sender, receiver } = await setup();

    await expect(contract.tx.transfer(receiver.address, 7))
      .to.emit(contract, 'Transfer')
      .withArgs(sender.address, receiver.address, 7);
  });

  it('Can not transfer above the amount', async () =&gt; {
    const { contract, receiver } = await setup();

    await expect(contract.tx.transfer(receiver.address, 1007)).to.not.emit(
      contract,
      'Transfer'
    );
  });

  it('Can not transfer from empty account', async () =&gt; {
    const { contract, Alice, one, sender } = await setup();

    const emptyAccount = await getRandomSigner(Alice, one.muln(10000));

    await expect(
      contract.tx.transfer(sender.address, 7, {
        signer: emptyAccount
      })
    ).to.not.emit(contract, 'Transfer');
  });
});

</code></pre>
<p>chai 还有更多的内置的用法，参见 chai 文档： https://www.chaijs.com/。</p>
<h3><a class="header" href="#equal" id="equal">equal</a></h3>
<p>@redspot/chai 会修改默认的 equal 的匹配方式。默认的 equal 不支持匹配对象。但 @redspot/chai 可以：</p>
<pre><code class="language-typescript">expect(new BN(1000)).to.equal(1000) // true
expect(AccountId).to.equal('5Gdjkw....') // true
expect(Uint8Array([1,2,3])).to.equal('0x010203') // true
</code></pre>
<p>对于 BN 类型，equal 对调用 <code>new BN(expected).eq(actual)</code> 判断是否相等</p>
<p>对于 polkadotjs 中定义的类型，equal 会调用 <code>Type.eq(actual)</code> 判断是否相等</p>
<p>对于 uint8Array 类型，equal 会将他们都转化为 hex ，再比较是否相等</p>
<p>其他类型则采用默认的判断方式，判断是否相等</p>
<h3><a class="header" href="#changetokenbalance" id="changetokenbalance">changeTokenBalance</a></h3>
<p>该匹配器可以检测 erc20 的余额变化，内部会调用 balanceOf 接口判断余额。由于 erc20-trait 的获取余额接口是 <code>baseErc20,balanceOf</code> </p>
<p>所以并不适用于 erc20-trait 。</p>
<pre><code class="language-typescript">await expect(() =&gt;
  contract.tx.transfer(receiver.address, 7)
).to.changeTokenBalance(contract, receiver, 7);

await expect(() =&gt;
  contract.tx.transfer(receiver.address, 7)
).to.changeTokenBalances(contract, [contract.signer, receiver], [-7, 7]);
</code></pre>
<h3><a class="header" href="#emit" id="emit">emit</a></h3>
<p>该匹配器可以检测合约是否发出事件，如检测是否有 Transfer 事件被 emit：</p>
<pre><code class="language-typescript">await expect(contract.tx.transfer(receiver.address, 7))
    .to.emit(contract, 'Transfer')
</code></pre>
<p>检测该事件是否包含指定的参数：</p>
<pre><code class="language-typescript">await expect(contract.tx.transfer(receiver.address, 7))
    .to.emit(contract, 'Transfer')
    .withArgs(sender.address, receiver.address, 7);
</code></pre>
<p>不期待发出事件</p>
<pre><code class="language-typescript">await expect(
  contract.tx.transfer(sender.address, 7, {
    signer: emptyAccount
  })
).to.not.emit(contract, 'Transfer');

</code></pre>
<h2><a class="header" href="#redspotgas-reporter" id="redspotgas-reporter">@redspot/gas-reporter</a></h2>
<p>该插件会在测试完成时，打印出所调用的合约的交易的 gas 使用量：</p>
<p><img src="https://user-images.githubusercontent.com/7029338/101343840-7700ab00-38e9-11eb-80a0-c6b6d38a9640.png" alt="" /></p>
<p>和 @redspot/chai 一样，只需要在引入 @redspot/gas-reporter 后，在 redspot.config.ts 中加入：</p>
<pre><code>// redspot.config.ts

import { RedspotUserConfig } from 'redspot/types';
import '@redspot/gas-reporter'; 

export default {
 ...
} as RedspotUserConfig;
</code></pre>
<p>即可自动运行。</p>
<h1><a class="header" href="#redspotchai-1" id="redspotchai-1">@redspot/chai</a></h1>
<h1><a class="header" href="#redspotgas-reporter-1" id="redspotgas-reporter-1">@redspot/gas-reporter</a></h1>
<h1><a class="header" href="#redspotpatract-1" id="redspotpatract-1">@redspot/patract</a></h1>
<h1><a class="header" href="#europa" id="europa">Europa</a></h1>
<p>Europa是一个运行<code>FRAME Contracts pallet</code>并<strong>模拟节点的沙盒环境</strong>，同时也是一个运行Substrate runtime的框架。</p>
<ol>
<li>将Europa作为合约调试的沙盒（sandbox）时，Europa修改了<code>FRAME Contracts pallet</code>模块以跟踪合约执行过程，能够给合约开发人员提供<strong>丰富的合约执行中的信息，让合约的执行过程不再是一个黑盒</strong>，帮助合约开发人员调试Wasm合约；</li>
<li>使用Europa作为Substrate的框架（framework）时，你可以在不受Wasm编译问题的干扰下做Substrate Runtime开发（多用于实验性功能）。</li>
</ol>
<h2><a class="header" href="#作为substrate-runtime的框架" id="作为substrate-runtime的框架">作为Substrate runtime的框架</a></h2>
<ol>
<li>
<p>Europa移除了一些不必要的功能模块，例如WASM executor，p2p等，仅保留了native的执行环境。</p>
</li>
<li>
<p>使用了<code>manual_seal</code>的出块方式（当收到新交易时就触发出块），使开发者不必受共识出块的影响，能更专注于合约的开发调试与日志分析。</p>
</li>
<li>
<p>提供了<code>state-kv</code>数据库，记录了每个区块的状态变更。</p>
<pre><code class="language-bash"># print the modified state kvs for block 1
$ ./target/debug/europa state-kv 1 -d europa_database
Nov 12 15:53:27.699  INFO modified state for block:0x6c119a8f7de42e330aca8b9d3587937aacbbc203cc21650b60644c2f2d33e7fb    
Nov 12 15:53:27.699  INFO       key:26aa394eea5630e07c48ae0c9558cef702a5c1b19ab7a04f536c519aca4983ac|value:[DELETED]    
Nov 12 15:53:27.699  INFO       key:26aa394eea5630e07c48ae0c9558cef70a98fdbe9ce6c55837576c60c7af3850|value:05000000
# ... 
</code></pre>
</li>
<li>
<p>Europa除了提供Substrate框架中的基础rpc之外，还有一些特殊的rpc：</p>
<ul>
<li><code>europa_forwardToHeight (params: [height: NumberOf&lt;B&gt;])</code>：将区块快进到指定高度，对于测试跟区块高度相关的功能非常有帮助。</li>
<li><code>europa_backwardToHeight (params: [height: NumberOf&lt;B&gt;])</code>：将区块回退到指定高度，主要用来恢复状态。</li>
<li><code>europa_modifiedStateKvs (params: [number_or_hash: NumberOrHash&lt;B&gt;])</code>：提供区块高度或者区块哈希，查询对应区块中的状态变更。</li>
</ul>
</li>
<li>
<p>Europa除了使用<code>-d/--base-path</code>的可选项命令划分不同的工作目录，还能使用<code>-w/--workspace</code>在工作目录下声明不同的工作空间。</p>
</li>
</ol>
<h2><a class="header" href="#作为frame-contracts-pallet的沙盒环境" id="作为frame-contracts-pallet的沙盒环境">作为<code>FRAME Contracts pallet</code>的沙盒环境</a></h2>
<p>当开发合约时，Europa为开发者提供了<strong>更加详细的日志信息</strong>来辅助合约开发者定位问题，包括contracts执行日志与wasm执行栈。同时这个沙盒环境也具备上述Europa框架的功能，例如可以使用<code>europa_forwardToHeight</code>等rpc来控制合约的执行情况。</p>
<p>合约错误可能出现在三处：<code>ink!</code>层、合约内部业务逻辑、<code>pallet_contracts</code>层。有了这些详细的日志，使得开发者在调试时能够快速定位问题，特别是在合约间互相调用的情况下，Europa能够大幅度提升开发体验。</p>
<p>目前，在Europa上有两个自定义的ChainExtension可供使用，分别是Contract logger和ZKP feature。</p>
<h2><a class="header" href="#本章重点" id="本章重点">本章重点</a></h2>
<p>由于本书主要关注点是Substrate的Wasm合约，因此后面章节的Europa相关的介绍均围绕与使用Europa合约调试相关。</p>
<h1><a class="header" href="#europa-tutorial" id="europa-tutorial">Europa tutorial</a></h1>
<p>Europa 作为一个模拟具备合约功能的节点沙盒环境，其接口（主要是rpc）对于大部分第三方工具都保持兼容，因此可以将Europa视为一个独立的节点进行操作。</p>
<h2><a class="header" href="#搭建开发环境" id="搭建开发环境">搭建开发环境</a></h2>
<p>Europa的环境与正常使用节点调试合约的环境无异，唯一的差别在于若需要打印Wasm的backtrace时，需要使用Patract提供的一个fork版本的<code>cargo-contract</code>，直到parity（官方）的<code>cargo-contract</code>合并Patract提交的功能之前。若不需要打印合约执行崩溃时的Wasm backtract，则使用官方提供的<code>cargo-contract</code>即可。</p>
<ul>
<li>
<p>编译并运行 Europa 节点</p>
<pre><code class="language-bash">$ git clone --recurse-submodules https://github.com/patractlabs/europa.git
## or do following commands
$ git clone https://github.com/patractlabs/europa.git
$ cd europa/vendor
$ git submodule update --init --recursive
</code></pre>
<p>也直接使用<code>cargo install</code>的方式安装Europa。（注意要添加上<code>--locked</code>以使用Europa当前依赖的Substrate版本）</p>
<pre><code class="language-bash">$ cargo install europa --git=https://github.com/patractlabs/europa.git --force --locked
</code></pre>
<p>运行Europa：</p>
<pre><code class="language-bash">$ ./target/release/europa --log=runtime=debug -d ./europa_database
# 若没有需要保留数据的需求，也可以使用`--tmp`运行Europa
$ ./target/release/europa --log=runtime=debug --tmp
</code></pre>
</li>
<li>
<p>安装 <a href="https://github.com/patractlabs/cargo-contract">PatractLabs's <code>cargo-contract</code></a> （可选，若需要Wasm合约执行崩溃时的backtrace时才需要）</p>
<pre><code>$ cargo install cargo-contract --git https://github.com/patractlabs/cargo-contract --branch=v0.10.0 --force
</code></pre>
<p>如果开发者已经安装了官方的<code>cargo-contract</code>并且不想覆盖安装，可以采取手动编译的方式：</p>
<pre><code class="language-bash">$ git clone https://github.com/patractlabs/cargo-contract --branch=v0.10.0
$ cd cargo-contract
$ cargo build --release
</code></pre>
</li>
<li>
<p>编译合约</p>
<p><code>--debug</code>选项是Patract的<code>cargo-contract</code>提供的，若使用parity提供的<code>cargo-contract</code>则下面执行命令中都不需要<code>--debug</code>的选项。</p>
<pre><code class="language-bash">$ cargo-contract build --debug
# or
$ cargo +nightly contract build --debug
</code></pre>
<p><code>-d/--debug</code>能够在<code>target/ink</code>目录下<strong>替换</strong>原本的<code>*.wasm</code>及<code>*.contract</code>文件，替换后的Wasm、Contract文件关闭了编译过程中的代码优化条件，且包含了&quot;name section&quot;部分，用来帮助分析wasm调用栈的信息。</p>
<blockquote>
<p>如果在编译合约的时候没有使用Patract仓库中的<code>cargo-contract</code>并携带<code>-d/--debug</code>参数进行合约编译，则在合约执行过程中若出现wasm panic时，可能出现如下日志：</p>
<pre><code>wasm_error: Error::WasmiExecution(Trap(Trap { kind: Unreachable }))
   wasm backtrace:
   |  &lt;unknown&gt;[...]
   |  &lt;unknown&gt;[...]
   ╰─&gt;&lt;unknown&gt;[...]
</code></pre>
</blockquote>
<blockquote>
<p>添加了<code>-d/--debug</code>后产生的编译产物一般比原产物大几百倍（例如原产物2.5k，新产物700k），因为新产物没有进行优化，且保留了大量调试信息。因此开发者也可以通过产物大小粗略判定是否是添加了<code>-d/--debug</code>选项后的产物。</p>
</blockquote>
</li>
</ul>
<h2><a class="header" href="#部署合约-1" id="部署合约-1">部署合约</a></h2>
<p>开发者可以使用<a href="https://redspot.patract.io/zh-CN/tutorial/">Redspot</a>或者<a href="https://polkadot.js.org/apps/#/explorer">Substrate Protal</a>来部署合约。</p>
<p>注意，Europa的<code>extending types</code>如下：</p>
<pre><code class="language-json">{
  &quot;LookupSource&quot;: &quot;MultiAddress&quot;,
  &quot;Address&quot;: &quot;MultiAddress&quot;
}
</code></pre>
<p>例如使用Redspot部署，使用apps执行交易和查看状态。</p>
<p>Redspot部署一个合约：</p>
<pre><code class="language-bash">$ npx redspot run scripts/deploy.js
</code></pre>
<p>获取到部署成功的合约地址，在apps上添加一个已存在的合约：</p>
<p><img src="europa/./imgs/add_exist.png" alt="add_exist" /></p>
<h2><a class="header" href="#分析日志" id="分析日志">分析日志</a></h2>
<p>使用Europa部署及执行合约的过程中会有如下详细信息的打印，这些信息是合约执行中的信息，可以方便的帮助开发人员定位合约中出现的问题。通过这些信息，合约的执行过程就不再是一个黑盒了。</p>
<p>日志的打印效果举例：</p>
<pre><code class="language-bash">1: NestedRuntime {
    ext_result: [success] ExecReturnValue { flags: 0, data:  },
    caller: d43593c715fdd31c61141abd04a99fd6822c8558854ccde39a5684e7a56da27d (5GrwvaEF...),
    self_account: 0144d6fc570d7bddda6f8e36141f179cd172324599b556ef514193f3105865f6 (5C6NMXaS...),
    selector: 0x9bae9d5e,
    args: 0x40420f00000000000000000000000000,
    value: 10000000000000000,
    gas_limit: 200000000000,
    gas_left: 190018947968,
    env_trace: [
        seal_input(Some(0x9bae9d5e40420f00000000000000000000000000)),
        seal_caller(Some(0xd43593c715fdd31c61141abd04a99fd6822c8558854ccde39a5684e7a56da27d)),
        ...
       seal_set_storage((Some(0x0300000001000000000000000000000000000000000000000000000000000000), Some(0x000000000000000000000000))),
    ],
    sandbox_result_ok: Value(
        I32(
            0,
        ),
    ),
    nest: [],
}
</code></pre>
<h3><a class="header" href="#contract执行日志" id="contract执行日志">Contract执行日志</a></h3>
<p>上面列举的日志案例，我们可以简单分析出以下信息：</p>
<ul>
<li><code>ext_result</code>： 可以表面这次合约调用执行的执行结果（通过交易调用与rpc调用都属于合约调用）；</li>
<li><code>caller</code>： 表面了调用者的公钥，合约调用合约则为父合约的公钥（与EVM的模型一致）；</li>
<li><code>self_account</code>：表面本合约的地址；</li>
<li><code>selector</code>: 被调用的方法的selector，通过这个属性可以判断出这次的调用是合约的哪个方法；</li>
<li><code>args</code>，<code>value</code>，<code>gas_limit</code>，<code>gas_limit</code>等表明了这次执行的相关参数及gas消耗；</li>
<li><code>env_trace</code>及<code>sandbox_result_ok</code>：表面了合约Wasm执行与<code>pallet-contracts</code>之间的交互信息，及Wasm执行器最终的结果（Wasm执行器结果与合约执行结果是不同概念）</li>
<li><code>nest</code>：描述了合约调用合约的关系，由于这里为空，表面这次调用只涉及一个合约执行。详细介绍见后文；</li>
</ul>
<p>由此可见，Europa提供的合约日志能够清晰的表面一次合约调用中的很多详细信息。若合约的开发者对合约模块<code>pallet-contracts</code>比较了解，则可以获得许多重要的调试信息以辅助定位合约问题。若合约开发者对合约模块了解较少，则例如<code>selector</code>，<code>caller</code>，<code>nest</code>等信息也能给合约开发过程中带来很大帮助，减少调试合约的时间。</p>
<p><strong>注意，当在apps上查看contracts中的messages时，apps会自动调用合约只读的messages获取当前合约的一些值，导致Europa会出现一些读取调用的日志，干扰正常判断。因此开发者需要辨别清楚哪块日志才是自己所需要的。</strong> 若使用发送请求都是能被自己控制的第三方客户端，则没有这方面的顾虑。</p>
<blockquote>
<p>开发者使用apps发送请求时，在Europa中辨别出需要日志的小tip：</p>
<p><code>1: NestedRuntime {}</code> 块下有一个<code>selector</code>字段，表示该次合约执行所使用的selector。开发者可以在metadata.json 中的<code>messages</code>部分中，获知当前调用的方法名对应的selector是什么，例如：</p>
<pre><code class="language-json">&quot;messages&quot;: [
    {
      &quot;name&quot;: [
        &quot;flip&quot;
      ],
      &quot;selector&quot;: &quot;0x633aa551&quot;
    }
]
</code></pre>
<p>因此可以通过<code>selector</code>字段与日志中的<code>selector</code>进行比对，判定出当前通过apps发出的合约调用所对应的日志部分。</p>
</blockquote>
<h3><a class="header" href="#wasmi-panic-backtrace" id="wasmi-panic-backtrace">wasmi panic backtrace</a></h3>
<p>假设在<code>ink!</code>中编写合约的方法如下：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[ink(message)]
pub fn transfer(&amp;mut self, to: AccountId, value: Balance) -&gt; Result&lt;()&gt; {
    let from = self.env().caller();
    self.transfer_from_to(from, to, value)?;
    panic!(&quot;123&quot;);
    Ok(())
}
<span class="boring">}
</span></code></pre></pre>
<p>调用该方法时，Europa中会打印如下日志（请注意当前该合约需要使用Patract的<code>cargo-contract</code>才会打印Wasm的Backtrace）：</p>
<pre><code class="language-bash">1: NestedRuntime {
	ext_result: [failed] ExecError { error: DispatchError::Module {index:5, error:17, message: Some(&quot;ContractTrapped&quot;), orign: ErrorOrigin::Caller }}
    caller: d43593c715fdd31c61141abd04a99fd6822...(5GrwvaEF...),
    self_account: b6484f58b7b939e93fff7dc10a654af7e.... (5GBi41bY...),
    selector: 0xfae3a09d,
    args: 0x1cbd2d43530a44705ad088af313e18f80b5....,
    value: 0,
    gas_limit: 409568000000,
    gas_left: 369902872067,
    env_trace: [
        seal_value_transferred(Some(0x00000000000000000000000000000000)),
        seal_input(Some(0xfae3a09d1cbd.....)),
        seal_get_storage((Some(0x0100000000000....), Some(0x010000000100000001000000))),
        # ...
        seal_caller(Some(0xd43593c715fdd31c61141abd...)),
        seal_hash_blake256((Some(0x696e6b20686173....), Some(0x0873b31b7a3cf....))),
      	# ...  
        seal_deposit_event((Some([0x45726332303a....00000000000]), Some(0x000..))),
    ],
	trap_reason: TrapReason::SupervisorError(DispatchError::Module { index: 5, error: 17, message: Some(&quot;ContractTrapped&quot;) }),
    wasm_error: Error::WasmiExecution(Trap(Trap { kind: Unreachable }))
        wasm backtrace: 
        |  core::panicking::panic[28]
        |  erc20::erc20::_::&lt;impl erc20::erc20::Erc20&gt;::transfer[1697]
        |  &lt;erc20::erc20::_::__ink_Msg&lt;[(); 2644567034]&gt; as ink_lang::traits::MessageMut&gt;::CALLABLE::{{closure}}[611]
        |  core::ops::function::FnOnce::call_once[610]
        |  &lt;erc20::erc20::_::_::__ink_MessageDispatchEnum as ink_lang::dispatcher::Execute&gt;::execute::{{closure}}[1675]
        |  ink_lang::dispatcher::execute_message_mut[1674]
        |  &lt;erc20::erc20::_::_::__ink_MessageDispatchEnum as ink_lang::dispatcher::Execute&gt;::execute[1692]
        |  erc20::erc20::_::&lt;impl ink_lang::contract::DispatchUsingMode for erc20::erc20::Erc20&gt;::dispatch_using_mode[1690]
        |  call[1691]
        ╰─&gt;&lt;unknown&gt;[2387]
    ,
    nest: [],
}
</code></pre>
<p>从Europa的日志中，我们可以分析出如下调用过程：</p>
<pre><code class="language-bash">call -&gt; dispatch_using_mode -&gt; ... -&gt; transfer -&gt; panic 
</code></pre>
<p>因此合约开发者可以定位到产生这次panic的原因是因为<code>transfer</code>这个函数中出现了<code>panic</code>导致。</p>
<p>以上为简单的日志分析说明，更多特殊的情况将在后面的“示例”章节中介绍。</p>
<h2><a class="header" href="#自定义chainextensions" id="自定义chainextensions">自定义ChainExtensions</a></h2>
<h3><a class="header" href="#ink-logger" id="ink-logger">ink logger</a></h3>
<p>查看<a href="https://github.com/patractlabs/ink-log">ink-log</a>。</p>
<h3><a class="header" href="#zkp-feature" id="zkp-feature">ZKP feature</a></h3>
<p>查看 <a href="https://github.com/patractlabs/zkmega">zkMega</a>，相关合约示例<a href="https://github.com/patractlabs/metis/tree/master/groth16">metis/groth16</a>。</p>
<h1><a class="header" href="#europa-合约执行日志信息解释" id="europa-合约执行日志信息解释">Europa 合约执行日志信息解释</a></h1>
<p>当前Europa的<code>pallet-contract</code>中记录合约执行信息的结构体如下所示。注释简要说明了每个属性代表记录的信息：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Record the contract execution context.
pub struct NestedRuntime {
	/// Current depth
    depth: usize,
	/// The current contract execute result
	ext_result: ExecResultTrace,
	/// The value in sandbox successful result
	sandbox_result_ok: Option&lt;ReturnValue&gt;,
	/// Who call the current contract
    caller: AccountId32,
	/// The account of the current contract
    self_account: Option&lt;AccountId32&gt;,
	/// The input selector
    selector: Option&lt;HexVec&gt;,
	/// The input arguments
    args: Option&lt;HexVec&gt;,
	/// The value in call or the endowment in instantiate
    value: u128,
	/// The gas limit when this contract is called
    gas_limit: Gas,
	/// The gas left when this contract return
    gas_left: Gas,
	/// The host function call stack
    env_trace: EnvTraceList,
	/// The error in wasm
    wasm_error: Option&lt;WasmErrorWrapper&gt;,
	/// The trap in host function execution
    trap_reason: Option&lt;TrapReason&gt;,
	/// Nested contract execution context
    nest: Vec&lt;NestedRuntime&gt;,
}
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#该结构对应的日志示例" id="该结构对应的日志示例">该结构对应的日志示例：</a></h2>
<pre><code class="language-bash">1: NestedRuntime {
    ext_result: [success] ExecReturnValue { flags: 0, data:  },
    caller: d43593c715fdd31c61141abd04a99fd6822c8558854ccde39a5684e7a56da27d (5GrwvaEF...),
    self_account: 0144d6fc570d7bddda6f8e36141f179cd172324599b556ef514193f3105865f6 (5C6NMXaS...),
    selector: 0x9bae9d5e,
    args: 0x40420f00000000000000000000000000,
    value: 10000000000000000,
    gas_limit: 200000000000,
    gas_left: 190018947968,
    env_trace: [
        seal_input(Some(0x9bae9d5e40420f00000000000000000000000000)),
        seal_caller(Some(0xd43593c715fdd31c61141abd04a99fd6822c8558854ccde39a5684e7a56da27d)),
        ...
       seal_set_storage((Some(0x0300000001000000000000000000000000000000000000000000000000000000), Some(0x000000000000000000000000))),
    ],
    sandbox_result_ok: Value(
        I32(
            0,
        ),
    ),
    nest: [],
}
</code></pre>
<h2><a class="header" href="#日志字段说明" id="日志字段说明">日志字段说明：</a></h2>
<ul>
<li>
<p><code>1: NestedRuntime</code>：调用深度为1的合约执行日志。</p>
</li>
<li>
<p><code>ext_result</code>：合约在<code>pallet-contract</code>层的执行结果，有<code>[success]</code>和<code>[failed]</code>两种情况。</p>
<ul>
<li><code>[success]</code>只能说明在<code>pallet-contract</code>层是执行成功的，但是合约本身的业务逻辑可能是抛出Error的。<code>ExecResultValue {flag:0, data: 0x...}</code>中的data值也许是合约的返回值，也许是合约内定义的Error的枚举值。</li>
<li><code>[failed]</code>后面会跟随一个<code>ExecError {.. }</code>，错误信息是定义在<code>pallet-contracts</code>中的。</li>
</ul>
</li>
<li>
<p><code>caller</code>：该合约的调用者，可能是用户，也可能是另外一个合约账户。当该值为<code>0x000...</code>时，是被rpc调用的。</p>
</li>
<li>
<p><code>self_account</code>：当前合约账户。</p>
</li>
<li>
<p><code>selector</code>：传递给合约的函数标识，在合约的metadata.json中查询到对应关系。</p>
</li>
<li>
<p><code>args</code>：传递给合约调用函数的参数。</p>
</li>
<li>
<p><code>value</code>：给当前合约转账数量。</p>
</li>
<li>
<p><code>gas_limit</code>：当前合约最多可以使用的gas数量。</p>
</li>
<li>
<p><code>gas_left</code>：退出当前合约时，还剩余的gas数量。</p>
</li>
<li>
<p><code>env_trace</code>：在当前合约执行过程中，host_function的调用栈，详细地给出了每个function的参数。以<code>seal_call</code>为例，如果input为Some(xxx)而output为None，那么可能是在合约互相调用过程中出错了。</p>
</li>
<li>
<p><code>trap_reason</code>：在执行host_function过程中，遇到trap的原因。</p>
<ul>
<li>Return &amp; Termination &amp; Restoration：是合约执行的正常退出策略，不是Error。</li>
<li>SupervisorError：定义在<code>pallet_contracts</code>中的DispatchError。</li>
</ul>
</li>
<li>
<p><code>wasm_error</code>：如果合约内部出现了wasm执行错误，会将wasm调用栈打印在该字段中。当且仅当<code>ext_result</code>是<code>[failed]</code>。</p>
</li>
<li>
<p><code>sandbox_result_ok</code>：假如在host_function执行过程中没有<code>trap</code>，并且没有<code>wasm_error</code>，那么认为合约执行成功，打印该字段。该字段携带一个<code>ReturnValue</code>的信息，在<code>ink!</code>中，如果返回的value值不为0，那么可能是出现了一个<code>ink!</code>内定义的Error，需要查询相应的<a href="https://github.com/paritytech/ink/blob/abd5cf14c0883cb2d5acf81f2277aeec330aa843/crates/lang/src/error.rs#L66-L80"><code>DispatchError</code></a>。</p>
</li>
<li>
<p><code>nest</code>：嵌套调用的合约日志。如果当前合约调用了其他合约，被调用合约的执行日志会被嵌套在该字段之中。</p>
<p>该部分详细解释请参照后续章节“合约嵌套调用”部分。</p>
</li>
</ul>
<h2><a class="header" href="#合约嵌套调用" id="合约嵌套调用">合约嵌套调用</a></h2>
<p>合约间的互相调用，日志如下：</p>
<ul>
<li>在合约A中，调用合约B之后再调用合约C</li>
</ul>
<p><img src="europa/./imgs/call_other_1.png" alt="call_other_1" /></p>
<p>日志如下：</p>
<pre><code class="language-bash">1: NestedRuntime {
	self_account: A,
	nest:[
		2: NestedRuntime {
			self_account: B,
			nest:[],
		},
		2: NestedRuntime {
			self_account: C,
			nest:[],
		}
	]
}
</code></pre>
<ul>
<li>在合约A中，调用合约B，在合约B中，调用合约C</li>
</ul>
<p><img src="europa/./imgs/call_other_2.png" alt="call_other_2" /></p>
<p>日志如下：</p>
<pre><code class="language-bash">1: NestedRuntime {
	self_account: A,
	nest:[
		2: NestedRuntime {
			self_account: B,
			nest:[
				3: NestedRuntime {
				self_account: C,
				nest:[],
			}
			],
		}  
	]
}
</code></pre>
<h1><a class="header" href="#europa-调试示例" id="europa-调试示例">Europa 调试示例</a></h1>
<h2><a class="header" href="#duplicate-topics" id="duplicate-topics">Duplicate topics</a></h2>
<ol>
<li>
<p>checkout <code>ink!</code> to commit <code>8e8fe09565ca6d2fad7701d68ff13f12deda7eed</code></p>
<pre><code class="language-bash">$ cd ink
$ git checkout 8e8fe09565ca6d2fad7701d68ff13f12deda7eed -b tmp
</code></pre>
</li>
<li>
<p>在<code>ink/examples/erc20/lib.rs:L90</code> 在<code>Transfer</code>事件中把value改为 <code>0_u128</code></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[ink(constructor)]
pub fn new(initial_supply: Balance) -&gt; Self {
     //...
     Self::env().emit_event(Transfer {
        from: None,
        to: Some(caller),
        // change this from `initial_supply` to `0_u128`
        value: 0_u128.into() // initial_supply,
     });
     instance
}
<span class="boring">}
</span></code></pre></pre>
</li>
<li>
<p>执行 <code>cargo +nightly contract build --debug</code> 来编译合约</p>
</li>
<li>
<p>使用 <a href="https://redspot.patract.io/en/tutorial/">RedSpot</a> or <a href="https://polkadot.js.org/apps"><code>Polkadot/Substrate Portal</code></a> 部署合约 ( 注意这里必须使用 erc20.wasm，而不是erc20-opt.wasm，否则无法正常打印wasm backtrace)</p>
</li>
</ol>
<p>在部署过程中，你会遇到 <code>DuplicateTopics</code> ，Europa日志如下：</p>
<pre><code class="language-bash">1: NestedRuntime {
    #...
    env_trace: [
        seal_input(Some(0xd183512b0)),
		#...    
		seal_deposit_event((Some([0x45726332303a3a5472616e736....]), None)),
    ],
    trap_reason: TrapReason::SupervisorError(DispatchError::Module { index: 5, error: 23, message: Some(&quot;DuplicateTopics&quot;) }),
    wasm_error: Error::WasmiExecution(Trap(Trap { kind: Host(DummyHostError) }))
    	wasm backtrace: 
    	|  ink_env::engine::on_chain::ext::deposit_event[1623]
    	|  ink_env::engine::on_chain::impls::&lt;impl ink_env::backend::TypedEnvBackend for ink_env::engine::on_chain::EnvInstance&gt;::emit_event[1564]
    	|  ink_env::api::emit_event::{{closure}}[1563]
    	|  &lt;ink_env::engine::on_chain::EnvInstance as ink_env::engine::OnInstance&gt;::on_instance[1562]
    	|  ink_env::api::emit_event[1561]
    	|  erc20::erc20::_::&lt;impl ink_lang::events::EmitEvent&lt;erc20::erc20::Erc20&gt; for ink_lang::env_access::EnvAccess&lt;&lt;erc20::erc20::Erc20 as ink_lang::env_access::ContractEnv&gt;::Env&gt;&gt;::emit_event[1685]
        # ...
        # ...
    	|  deploy[1691]
    	╰─&gt;&lt;unknown&gt;[2385]
    ,
    nest: [],
}
</code></pre>
<p>在日志中，你可以发现：</p>
<ol>
<li>在<code>env_trace</code>中最后一条记录是<code>seal_deposit_event</code>而不是<code>seal_return</code>。如果合约执行正常，最后一条记录应当是<code>seal_return</code>。</li>
<li><code>seal_deposit_event</code>的第二个参数为<code>None</code>，这意味着这个host_function没有被正常执行。<a href="https://github.com/patractlabs/substrate/blob/3624deb47cabe6f6cd44ec2c49c6ae5a29fd2198/frame/contracts/src/wasm/runtime.rs#L1399">相关实现</a>。</li>
<li>结合wasm backtrace，可以看到栈顶为<code>deposit_event</code>。</li>
</ol>
<p>综上，可以断定错误出现在<code>seal_deposit_event</code>这个host_function中。</p>
<h2><a class="header" href="#balance类型不一致" id="balance类型不一致">Balance类型不一致</a></h2>
<p>假设链上的Balance定义为u64，而<code>ink!</code>中Balance定义为u128，部署了一个普通的erc20合约。</p>
<p>读取<code>total_supply</code>时，Europa中日志如下：</p>
<pre><code class="language-bash">1: NestedRuntime {
    ext_result: [failed] ExecError { error: DispatchError::Module { index: 5, error: 17, message: Some(&quot;ContractTrapped&quot;) }, origin: ErrorOrigin::Caller },
    caller: 0000000000000000000000000000000000000000000000000000000000000000 (5C4hrfjw...),
    self_account: 2fe715301c9609c0c5ab75b24f2d8ad7dbe9671d7aebfeed80ed8963bc017955 (5D9Wkfa3...),
    selector: 0xdb6375a8,
    args: None,
    value: 0,
    gas_limit: 4999999999999,
    gas_left: 4999865113466,
    env_trace: [
        seal_value_transferred(Some(0x0000000000000000)),
    ],
    wasm_error: Error::WasmiExecution(Trap(Trap { kind: Unreachable }))
    	wasm backtrace:
    	|  core::panicking::panic_fmt.48[1956]
    	|  core::result::unwrap_failed[1057]
    	|  core::result::Result&lt;T,E&gt;::expect[1060]
    	|  ink_lang::dispatcher::deny_payment[1878]
    	|  call[1906]
    	╰─&gt;&lt;unknown&gt;[2614]
    ,
    nest: [],
}
</code></pre>
<p>调用<code>tranfer</code>时，Europa中日志如下：</p>
<pre><code class="language-bash">1: NestedRuntime {
    ext_result: [failed] ExecError { error: DispatchError::Module { index: 5, error: 17, message: Some(&quot;ContractTrapped&quot;) }, origin: ErrorOrigin::Caller },
    caller: 0000000000000000000000000000000000000000000000000000000000000000 (5C4hrfjw...),
    self_account: 2fe715301c9609c0c5ab75b24f2d8ad7dbe9671d7aebfeed80ed8963bc017955 (5D9Wkfa3...),
    selector: 0xdb6375a8,
    args: None,
    value: 0,
    gas_limit: 4999999999999,
    gas_left: 4999865113466,
    env_trace: [
        seal_value_transferred(Some(0x0000000000000000)),
    ],
    wasm_error: Error::WasmiExecution(Trap(Trap { kind: Unreachable }))
    	wasm backtrace:
    	|  core::panicking::panic_fmt.48[1956]
    	|  core::result::unwrap_failed[1057]
    	|  core::result::Result&lt;T,E&gt;::expect[1060]
    	|  ink_lang::dispatcher::deny_payment[1878]
    	|  call[1906]
    	╰─&gt;&lt;unknown&gt;[2614]
    ,
    nest: [],
}
</code></pre>
<p>可以发现，无论是读取还是写入操作，都会出现<code>call -&gt; deny_payment -&gt; expect</code>这样的调用过程。原因是在<code>ink!</code>中，有如下代码：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[no_mangle]
fn call() -&gt; u32 {
    if true {
     ::ink_lang::deny_payment::&lt;&lt;Erc20 as ::ink_lang::ContractEnv&gt;::Env&gt;()
    		.expect(&quot;caller transferred value even though all ink! message deny payments&quot;)
    }
    ::ink_lang::DispatchRetCode::from(
        &lt;Erc20 as ::ink_lang::DispatchUsingMode&gt;::dispatch_using_mode(
            ::ink_lang::DispatchMode::Call,
        ),
    )
    .to_u32()
}

pub fn deny_payment&lt;E&gt;() -&gt; Result&lt;()&gt;
where
    E: Environment,
{
    let transferred = ink_env::transferred_balance::&lt;E&gt;()
        .expect(&quot;encountered error while querying transferred balance&quot;);
    if transferred != &lt;E as Environment&gt;::Balance::from(0u32) {
        return Err(DispatchError::PaidUnpayableMessage)
    }
    Ok(())
}
<span class="boring">}
</span></code></pre></pre>
<p>在<code>ink!</code>中，对于<code>off_chain</code>和<code>on_chain</code>，出现<code>expect</code>的时机是不同的。在<code>off_chain</code>中，是由于<code>ink_env::transferred_balance::&lt;E&gt;()</code>不能正确decoded。在<code>on_chain</code>中，由于<code>transferred!=0</code>导致<code>deny_payment</code>返回Error，在<code>call</code>中才出现<code>expect</code>。</p>
<p>由此可见，当前<code>ink!</code>在<code>off_chain</code>和<code>on_chain</code>中对某些情况是不完全一致的，造成调试的困扰。</p>
<h1><a class="header" href="#europa-wasm-executor" id="europa-wasm-executor">Europa Wasm executor</a></h1>
<p>TODO：未完成</p>
<p>Europa 提供了不同的 Wasm 执行器执行合约。当前提供了<code>wasmi</code>与<code>wasmtime</code>。</p>
<h1><a class="header" href="#europa-的wasm-backtrace" id="europa-的wasm-backtrace">Europa 的Wasm Backtrace</a></h1>
<p><code>pallet-contracts</code>的执行包含“合约模型”中的执行与Wasm中的执行。其中</p>
<ul>
<li>合约模型中的执行过程通过Wasm的 host_function 转移到了 <code>pallet-contracts</code> 模块中执行，若出现panic或者错误定位可以让节点的runtime以Native运行的形式来定位。</li>
<li>Wasm 中的执行过程由于处于Wasm虚拟机中，因此对于外界而言是黑盒，若内部执行过程出现了崩溃异常，只能由Wasm执行器对外展示。</li>
</ul>
<p>Europa 的 <code>pallet-contracts</code> 模块当前支持2种执行器：</p>
<ul>
<li><code>wasmi</code>：由parity研发的Wasm解释器，当Wasm执行出现panic时只会返回错误，没有Backtrace。Patract fork 了parity的wasmi，在原基础上添加了执行栈的跟踪与打印。当Wasm的执行过程出现Panic的时候，将当前的执行栈及相应信息通过错误一并返回。</li>
<li><code>wasmtime</code>：Wasm的JIT执行器，已经自带了执行崩溃时的Backtrace。</li>
</ul>
<h2><a class="header" href="#europa-能打印出-wasm-backtrace-的条件" id="europa-能打印出-wasm-backtrace-的条件">Europa 能打印出 Wasm Backtrace 的条件</a></h2>
<p>Wasm能够打印Backtrace，要求合约编译出的Wasm文件里有“name section”段。由于parity提供的<code>cargo-contract</code>已经封装了许多操作，因此<strong>在当前</strong>其默认操作中是以最优优化方式去编译合约，在这个过程中会去除掉“name section”段。另一方面<code>cargo-contract</code>也没有提供对应的接口或选项允许开发者调整合约编译使用的优化条件及是否保留一些调试信息。因此Patract只能提供一个修改版本的<code>cargo-contract</code>，开发者使用这个修改版的<code>cargo-contract</code>可编译出携带“name section”段的合约Wasm文件。</p>
<p>另一方面release的编译中会对原代码有优化，通过优化后的Backtrace来定位bug有可能会受到干扰，因此最好能降低优化等级，这样崩溃时的Backtrace才会最大可能性和原代码相匹配。</p>
<h2><a class="header" href="#安装-patract-仓库下的cargo-contract" id="安装-patract-仓库下的cargo-contract">安装 Patract 仓库下的<code>cargo-contract</code></a></h2>
<ol>
<li>
<p>安装 <a href="https://github.com/patractlabs/cargo-contract">PatractLabs's <code>cargo-contract</code></a></p>
<pre><code>$ cargo install cargo-contract --git https://github.com/patractlabs/cargo-contract --branch=v0.10.0 --force
</code></pre>
<blockquote>
<p>由于当前 parity 的 <code>cargo-contract</code> 发布的版本为 <code>v0.10.0</code>，因此我们Patract 基于这个版本添加了功能。若将来<code>cargo-contract</code>继续升级，Patract 也会继续维护。</p>
</blockquote>
<p>通过这种方式安装的 <code>cargo-contract</code> 将会<strong>覆盖</strong>已安装过的的<code>cargo-contract</code>。因此请注意留意当前环境中的<code>cargo-contract</code>来自哪个仓库，以防止定位问题时收到干扰。</p>
<p>执行命令：</p>
<pre><code class="language-bash">$ cargo install --list | grep cargo-contract
cargo-contract v0.10.0 (https://github.com/patractlabs/cargo-contract?branch=v0.10.0#106081f1):
cargo-contract
</code></pre>
<p>可通过列出的结果判定当前环境中的<code>cargo-contract</code>安装来自什么源。例如上面的结果即来自Patract。若没有括号及其中的内容则表示来自<code>crates.io</code>。</p>
</li>
<li>
<p>如果开发者已经安装了官方的<code>cargo-contract</code>并且不想覆盖安装，可以采取手动编译的方式。</p>
<pre><code class="language-bash">$ git clone https://github.com/patractlabs/cargo-contract --branch=v0.10.0
$ cd cargo-contract
$ cargo build --release
</code></pre>
<p>编译好后可以将编译的产物移动到任意可以被全局访问的路径，并重命名（以防和已安装过的cargo-contract冲突）。</p>
<pre><code class="language-bash">$ cp target/release/cargo-contract &lt;to any path&gt;/patract-cargo-contract
</code></pre>
<p>后续在 ink! 合约的编译过程中则使用 <code>patract-cargo-contract xxx</code> 替代 <code>cargo +nighlty contract xxx</code> 执行相应命令。（请注意这种方式要求 default toolchain 为 nightly）</p>
</li>
</ol>
<h2><a class="header" href="#使用-patract-的-cargo-contract-生成携带-name-section-段的-wasmcontract-文件" id="使用-patract-的-cargo-contract-生成携带-name-section-段的-wasmcontract-文件">使用 Patract 的 cargo-contract 生成携带 “name section” 段的 <code>*.wasm/*.contract</code> 文件</a></h2>
<p>Patract 的 <code>cargo-contract</code> 提供 <code>-d/--debug</code> 选项。当执行一下命令时：</p>
<pre><code class="language-bash">$ cargo +nightly contract build
</code></pre>
<p>生成的<code>*.wasm/*.contract</code> 文件与parity官方的<code>cargo-contract</code>执行结果一致。</p>
<p>当执行以下命令时：</p>
<pre><code class="language-bash">$ cargo +nightly contract build --debug
</code></pre>
<p>则生成的<code>*.wasm/*.contract</code> 文件就是没有经过优化，且携带“name section”段的<code>*.wasm/*.contract</code> 文件。相当于通过这种方式生成的文件<strong>替换</strong>了原本生成逻辑生成的文件。</p>
<p><strong>请注意通过这种模式生成的编译产物，一般情况下其大小是原产物的几百倍</strong>。因此开发者可以留意生成产物的大小粗略判定是通过那种编译方式生成的编译产物。</p>
<p>例如如下示例：</p>
<pre><code class="language-bash">$ cd target/ink
$ ls -h
-rw-rw-r-- 1 root root 1.5M 3月  12 16:01 flipper.contract
-rw-rw-r-- 1 root root 6.1K 3月  12 15:34 flipper.contract.old
-rw-rw-r-- 1 root root 732K 3月  12 16:00 flipper.wasm
-rw-rw-r-- 1 root root 2.5K 3月  12 15:34 flipper.wasm.old
-rw-rw-r-- 1 root root 2.1K 3月  12 16:01 metadata.json
</code></pre>
<p>带<code>*.old</code> 文件表示是由parity版本的<code>cargo-contract</code>生成（第一次编译后重命名过），反之的同名文件是由Patract的<code>cargo-contract</code>并加上了<code>--debug</code>命令生成。可以看到新文件比老文件大许多倍。而<code>metadata.json</code>则是没有变化的。</p>
<h2><a class="header" href="#wasm-backtrace-解释" id="wasm-backtrace-解释">Wasm Backtrace 解释</a></h2>
<p>TODO：待完成</p>
<h2><a class="header" href="#实验性功能" id="实验性功能">实验性功能</a></h2>
<h3><a class="header" href="#wasm-backtrace-打印行号只支持wasmtime" id="wasm-backtrace-打印行号只支持wasmtime">Wasm Backtrace 打印行号（只支持Wasmtime）</a></h3>
<p>TODO：该部分未完成</p>
<p>启动Europa的时候添加<code>WASMTIME_BACKTRACE_DETAILS=1</code>或者将这个变量设置成环境变量：</p>
<pre><code class="language-bash">WASMTIME_BACKTRACE_DETAILS=1 europa --tmp
# or use
export WASMTIME_BACKTRACE_DETAILS=1
europa --tmp # run europa in normal way
</code></pre>
<p>那么在europa的日中的<code>wasm_error</code>部分，将会出现崩溃栈对应原代码中的行号：</p>
<pre><code class="language-bash">wasm_error: Error::Trap(
    Trap {
        code: TrapCode::UnreachableCodeReached,
        trace: [
            &quot;wasm trap: unreachable&quot;,
            &quot;wasm backtrace:&quot;,
            &quot;    0: 0x31b2 - &lt;unknown&gt;!core::panicking::panic::he000af669cfcac01&quot;,
            &quot;    1: 0x3c8c - &lt;unknown&gt;!flipper::flippter::_::&lt;impl flipper::flippter::Flippter&gt;::flip::h12b84979a77ae484&quot;,
            &quot;    2: 0x10fa - core::result::Result&lt;T,E&gt;::map_err::h576871030fe833d4&quot;,
            &quot;                    at /home/clearloop/.cargo/registry/src/github.com-1ecc6299db9ec823/parity-scale-codec-2.0.1/src/codec.rs:1199:31&quot;,
            &quot;    3: 0x10d6 - core::result::Result&lt;T,E&gt;::map_err::h576871030fe833d4&quot;,
            &quot;                    at /home/clearloop/.cargo/registry/src/github.com-1ecc6299db9ec823/parity-scale-codec-2.0.1/src/codec.rs:1198&quot;,
            &quot;    4: 0x3966 - &lt;unknown&gt;!&lt;flipper::flippter::_::_::__ink_MessageDispatchEnum as ink_lang::dispatcher::Execute&gt;::execute::{{closure}}::hf35b139aaf5fba3b&quot;,
            &quot;    5: 0x3941 - &lt;unknown&gt;!ink_lang::dispatcher::execute_message_mut::hf62eb790d230d371&quot;,
            &quot;    6: 0x3c12 - &lt;unknown&gt;!&lt;flipper::flippter::_::_::__ink_MessageDispatchEnum as ink_lang::dispatcher::Execute&gt;::execute::heae3e5bbfc02afa0&quot;,
            &quot;    7: 0x3a7a - &lt;unknown&gt;!flipper::flippter::_::&lt;impl ink_lang::contract::DispatchUsingMode for flipper::flippter::Flippter&gt;::dispatch_using_mode::h8e0c4495e09cd910&quot;,
            &quot;    8: 0x3ba3 - &lt;unknown&gt;!call&quot;,
            &quot;    9: 0xf704 - &lt;unknown&gt;!&lt;wasm function 638&gt;&quot;,
            &quot;&quot;,
        ],
    },
),
</code></pre>
<p>在这段backtrace日志中，一些能解析出行号的部分将会在那一行的最后附加错误栈中的函数对应的行号，例如：</p>
<pre><code class="language-bash">&quot;2: 0x10fa - core::result::Result&lt;T,E&gt;::map_err::h576871030fe833d4&quot;,
            &quot;                    at /home/clearloop/.cargo/registry/src/github.com-1ecc6299db9ec823/parity-scale-codec-2.0.1/src/codec.rs:1199:31&quot;
</code></pre>
<p>中的<code>codec.rs:1199:31</code>部分即表示该错误栈中的这一帧对应于<code>codec.rs</code>这个文件的行<code>1199</code>，列<code>31</code>。其余行由于解析还不充分或者是由于代码由宏生成，因此还没有行号。</p>
<h1><a class="header" href="#zkmega" id="zkmega">zkMega</a></h1>
<p>zkMega is a zero-knowledge proof tool set building for the Polkadot ecology. </p>
<ul>
<li>Polkadot Treasury report for v0.1: https://polkadot.polkassembly.io/post/221. </li>
</ul>
<h2><a class="header" href="#zk-rollup-introduction" id="zk-rollup-introduction">ZK Rollup Introduction</a></h2>
<p>Compared with the privacy function, the performance improvement brought by Rollup is the
early application direction of zero-knowledge proof. At present, the Layer 2 expansion
plan of the blockchain is to transfer a considerable part of the on-chain workload to 
off-chain to complete, and the most watched one is ZK Rollup. The essence of ZK Rollup 
is to compress the application on-chain state and store it in a Merkle tree, and move 
the state transition funtions to off-chain. At the same time, the correctness of the 
off-chain state transition process is guaranteed through the proof of zkSNARK. Compared 
with the high cost of directly processing state changes on the chain, the ZK Proof's 
on-chain smart contract verification is extremely cost low. At the same time, the 
compressed information will also be submitted to the chain together with the proof, 
which ensures data availability and obtains the same level of security as Layer 1.</p>
<p>The Ethereum Layer 2 protocols related to ZK Rollup are: <a href="https://zksync.io/">zkSync</a>, <a href="https://aztec.network/">aztec</a>, 
etc. Their contract verification modules share a part of the elliptic curve's basic algorithms. 
In 2017, Ethereum integrated three basic cryptographic calculation units of the alt
bn128 curve in the form of pre-compiled contracts, which are <a href="https://github.com/ethereum/EIPs/blob/master/EIPS/eip-196.md">EIP196</a>’s ADD and Scalar_MUL 
algorithms, and <a href="https://github.com/ethereum/EIPs/blob/master/EIPS/eip-197.md">EIP197</a>’s Pairing algorithm. On top of this, due to the lack of rapid 
upgrade capabilities of Ethereum, the community can only encapsulate some  tool libraries 
through costly Solidity contracts. On top of these basic contract  libraries, many DApps can combine 
ZK Rollup technology to achieve some innovations, such as <a href="https://loopring.org/">loopring</a>, <a href="https://gitcoin.co/">gitcoin</a> 
and <a href="https://uniswap.org/">uniswap</a> etc. However, in the past 3 years, ZK technology has further developed, 
such as the more practical <a href="https://electriccoin.co/blog/new-snark-curve/">BLS curve</a>, and <a href="https://eprint.iacr.org/2019/953/20190827:165656">PLONK algorithm</a> etc. 
Ethereum has not yet supported it.</p>
<h2><a class="header" href="#what-zkmega-does" id="what-zkmega-does">What zkMega does</a></h2>
<p>zkMega 目的是为了给Wasm合约生态<strong>引入零知识原语</strong>，类似于 Ethereum，开发者可以在合约生态中基于零知识原语构建出零知识的dapp及服务于部分Layer2的需求。因此 zkMega 在链的角度上实现的功能为几个基本的 零知识原语 的调用接口。而后续将会继续提供链下开发零知识合约功能的工具包组件等。</p>
<p>zkMega 首先会实现链上的零知识的接口调用功能，并提供合约示例。零知识的接口调用功能分为 Runtime 的实现以及 <code>pallet-contracts</code>合约接口的实现。而 <code>pallet-contracts</code>的实现本质上是通过<code>ChainExtentions</code>调用了Runtime的实现。</p>
<p>而 zkMega 实现零知识的方式是使用了 arkwork 的零知识实现库，该库可以编译成 Wasm 被使用。因此 zkMega 做了对于 Native 执行零知识调用与 Wasm 中执行零知识调用的性能对比（benchmark）。基于Substrate的链引入 zkMega 时，可以根据自己是否愿意导出 zkMega 使用的零知识的 host_function，来以 Wasm 或是 Native 的形式运行零知识的计算过程。详情请参照文档 <a href="zkmega/./benchmark.html">benchmark</a>。</p>
<p>在<code>pallet-contracts</code>的模块引入了 zkMega 的链中，部署于<code>pallet-contracts</code>中的合约模块可以通过<code>ChainExtentions</code>在合约中调用链里 zkMega 提供的零知识的功能。由于<code>ChainExtentions</code>是通过<code>func_id</code>来区分调用的方法，因此 Patract 希望通过 <a href="https://github.com/patractlabs/pips">Patract/pallet-contracts/Polkadot Improvement Proposals (PIPs)</a> 来协定 func_id 与参数。因此 Patract 通过 Pip-101 <a href="https://github.com/patractlabs/PIPs/blob/main/PIPs/pip-101.md">Function ids for Patract Labs zkMega</a> 来约定 zkMega 在 <code>ChainExtentions</code> 部分使用的 <code>func_id</code>。</p>
<p>另一方面 zkMega 为了丰富开发人员的基础库，仿照 Ethereum 生态中的 <code>libsnark</code> 库，提供了例如 <code>MIMC</code>，<code>Merkle Tree</code> 等实用公共函数。这些库可以直接在ink!中被调用。详情可以参考 <a href="zkmega/./example.html">example</a>。</p>
<h2><a class="header" href="#license" id="license">LICENSE</a></h2>
<p>Apache-2.0</p>
<h1><a class="header" href="#tutorial-2" id="tutorial-2">tutorial</a></h1>
<h2><a class="header" href="#基于-substrate-的链引入-zkmega-的零知识原语" id="基于-substrate-的链引入-zkmega-的零知识原语">基于 Substrate 的链引入　zkMega 的零知识原语</a></h2>
<p>具备<code>pallet-contracts</code>的链集成 zkMega 可以参照 Jupiter 的集成方式: <a href="https://github.com/patractlabs/jupiter/blob/master/primitives/chain-extension/src/lib.rs">https://github.com/patractlabs/jupiter/blob/master/primitives/chain-extension/src/lib.rs</a></p>
<p>其主要步骤主要分为以下几步：</p>
<ol>
<li>
<p>设计一个实现于 <code>ChainExtension</code> 的结构体</p>
</li>
<li>
<p>在<code>ChainExtension</code>的<code>call</code>的实现中判断 <code>func_id</code> 的范围，按照 <a href="https://github.com/patractlabs/PIPs/blob/main/PIPs/pip-101.md">PIP-101</a> 中的描述，当前使用 zkMega 需要的范围为 <code>0x01000000..=0x010000ff</code>。因此可以在实现中引入：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>match func_id {
        // 0x01000000-0x010000ff Patract ZKP Support
        0x01000000..=0x010000ff =&gt; {

        }
}
<span class="boring">}
</span></code></pre></pre>
</li>
<li>
<p>然后在 <code>0x01000000..=0x010000ff</code> 的代码块中引入 gas 计费的方式。不同的链可能会对 zkMega 调用的方法设计不同的计费方式。在Jupiter的案例中仅最简单的设计了一个固定消耗gas的方式：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let simple_weight = match func_id &amp; 0x01 {
        0 =&gt; 100_000,   // add, In ethereum: 500
        1 =&gt; 8_000_000, // 80x then add, In ethereum: 40000
        2 =&gt; {/* ...*/ }
        _ =&gt; return Err(DispatchError::Other(&quot;Unimplemented Patract ZKP func_id&quot;));
    };
env.charge_weight(simple_weight)?;
<span class="boring">}
</span></code></pre></pre>
</li>
<li>
<p>根据链自身需要 Native 的调用还是 Wasm 的调用进行不同的实现：</p>
<p>例如如果该链只想支持 Wasm 的调用，则使用如下方式：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>zkmega_arkworks::call(&amp;func_id, &amp;input);
<span class="boring">}
</span></code></pre></pre>
<p>若该链希望将调用放到 Native 上执行，则可以类似于Jupiter一致，设计 <code>runtime_inferface</code> 包裹<code>zkmega_arkworks::call</code> 的调用，将调用过程放到 std 下编译。然后在 <code>ChainExtensions</code>的实现中调用 <code>runtime_interface</code> 导出的方法即可。</p>
</li>
</ol>
<h2><a class="header" href="#合约中调用-zkmega-的零知识原语的接口" id="合约中调用-zkmega-的零知识原语的接口">合约中调用 zkMega 的零知识原语的接口</a></h2>
<p>合约中使用 zkMega 就比较简单。首先在合约依赖中引入<code>megaclite-arkworks</code></p>
<pre><code class="language-toml">[dependencies]
megaclite-arkworks = { git = &quot;https://github.com/patractlabs/zkmega&quot;, features = [ &quot;ink&quot; ], default-features = false }
</code></pre>
<p>请注意引入 zkMega 库的时候需要使用 <code>ink</code> feature。</p>
<p>之后在合约里即可以使用 zkMega 提供的方法：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>megaclite_arkworks::verify(...);
<span class="boring">}
</span></code></pre></pre>
<p>如果是比较底层的调用，则可以直接通过<code>call</code>来调用：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let func_id = /*id defined in PIP-101*/
megaclite_arkworks::verify(func_id, ...);
<span class="boring">}
</span></code></pre></pre>
<h1><a class="header" href="#contract-2" id="contract-2">Contract</a></h1>
<blockquote>
<p>Currently we (Patract) support zkMega in testnet Jupiter (<a href="https://github.com/patractlabs/jupiter">https://github.com/patractlabs/jupiter</a>) and contract debug 
sandbox Europa (<a href="https://github.com/patractlabs/europa">https://github.com/patractlabs/europa</a>). And any substrate based chain which uses <code>pallet-contracts</code> v3.0.0 could integrate zkMega.</p>
<p>if the <code>pallet-contracts</code> Wasm contract chain use zkMega, then the following contract could run normally in those chain.</p>
</blockquote>
<h2><a class="header" href="#example-1" id="example-1">Example</a></h2>
<p>TODO this example is wrong for current version!</p>
<pre><code class="language-rust ignore">#![cfg_attr(not(feature = &quot;std&quot;), no_std)]

#[ink::contract]
mod altbn128 {
    use ink_env::zk_snarks::AltBn128;
    use ink_prelude::string::String;

    #[ink(storage)]
    pub struct Altbn128 {
        value: String,
    }

    impl Altbn128 {
        #[ink(constructor)]
        pub fn new(init_value: String) -&gt; Self {
            Self { value: init_value }
        }

        #[ink(constructor)]
        pub fn default() -&gt; Self {
            Self::new(&quot;hello, world&quot;.into())
        }

        #[ink(message)]
        pub fn bn_256_add(&amp;mut self) {
            let mut result = [0; 64];
            ink_env::inflect_add::&lt;AltBn128&gt;(&amp;[], &amp;[], &amp;mut result);
            self.value = ink_prelude::format!(&quot;0x{:x?}&quot;, result);
        }

        #[ink(message)]
        pub fn get(&amp;self) -&gt; String {
            ink_prelude::format!(&quot;{}&quot;, &amp;self.value)
        }
    }
}
</code></pre>
<h1><a class="header" href="#example-2" id="example-2">Example</a></h1>
<h2><a class="header" href="#call-curves-in-ink" id="call-curves-in-ink">Call curves in ink!</a></h2>
<table><thead><tr><th>curve</th><th>add</th><th>mul</th><th>pairing</th></tr></thead><tbody>
<tr><td>bls12_377</td><td>0x01000000</td><td>0x01000001</td><td>0x01000002</td></tr>
<tr><td>bls12_381</td><td>0x01000010</td><td>0x01000011</td><td>0x01000012</td></tr>
<tr><td>bn254</td><td>0x01000020</td><td>0x01000021</td><td>0x01000022</td></tr>
<tr><td>bw6_761</td><td>0x01000030</td><td>0x01000031</td><td>0x01000032</td></tr>
</tbody></table>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let result = ink_env::call_chain_extension(func_id, &amp;Vec::from(input))?
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#mimc" id="mimc">MIMC</a></h2>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use zkp_u256::{U256, Zero};
use merkle_tree::mimc::{mimc,mimc_with_key}
let message = U256::from_decimal_str(&quot;49&quot;).unwrap();
let in_key = U256::zero();
assert_eq!(
    mimc(b&quot;1&quot;),
    mimc_with_key(vec![&amp;message], &amp;in_key)
);
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#merkle-tree" id="merkle-tree">Merkle Tree</a></h2>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use merkle_tree::MerkleTree;
let mut mt = MerkleTree::default();
let message = b&quot;49&quot;;
let (leaf, index) = mt.insert(message).unwrap();
assert_eq!(mt.update(), mt.get_root());
let merkle_proof = mt.get_proof(index);
assert!(mt.verify_merkle_proof(leaf, merkle_proof, index));

let message = b&quot;50&quot;;
let (leaf, index) = mt.insert(message).unwrap();
assert_eq!(mt.update(), mt.get_root());
let merkle_proof = mt.get_proof(index);
assert!(mt.verify_merkle_proof(leaf, merkle_proof, index));

let message = b&quot;51&quot;;
let (leaf, index) = mt.insert(message).unwrap();
assert_eq!(mt.update(), mt.get_root());
let merkle_proof = mt.get_proof(index);
assert!(mt.verify_merkle_proof(leaf, merkle_proof, index));
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#eddsa" id="eddsa">EDDSA</a></h2>
<blockquote>
<p>TODO</p>
</blockquote>
<h1><a class="header" href="#benchmark" id="benchmark">Benchmark</a></h1>
<p>We have constructed <a href="https://github.com/patractlabs/zkmega/tree/master/crates/arkworks/src/tests">the tests of zkMega curves</a> in <a href="https://github.com/patractlabs/substrate/blob/features/curve-benchmark/bin/node-template/pallets/template/src/lib.rs">pallet-template</a> which imports the 
curves from zkMega directly(<em>Wasm</em>) and with <a href="https://github.com/patractlabs/substrate/blob/features/curve-benchmark/bin/node-template/io/src/lib.rs">runtime-interface</a>(<em>Native</em>).</p>
<h2><a class="header" href="#building" id="building">Building</a></h2>
<pre><code class="language-bash"># Clone the branch `curve-benchmark` of our fork
git clone https://github.com/patractlabs/jupiter.git \
    --branch features/runtime-interfaces \
    --depth =1

# Build the template
cargo build -p jupiter-dev --all-features --release

# Check the command benchmark works fine
# ./target/release/jupiter-dev benchmark -p pallet_template -e wasm_bls_12_381_add
./target/release/jupiter-dev benchmark -p pallet_template -e wasm_bls_12_381_add

</code></pre>
<h2><a class="header" href="#result" id="result">Result</a></h2>
<table><thead><tr><th>memory</th><th>processor</th></tr></thead><tbody>
<tr><td>64GiB System memory</td><td>AMD Ryzen 9 5900X 12-Core Processor</td></tr>
</tbody></table>
<p>Here we test the curevs on ubuntu LTS 20.04, Time is measured in us</p>
<table><thead><tr><th>Curve</th><th>Native</th><th>Time(us)</th><th>WASM</th><th>Time(us)</th><th>Speed(Native/WASM)</th></tr></thead><tbody>
<tr><td>bls12_377(~9.5x)</td><td>native_bls12_377_add</td><td>9.588</td><td>wasm_bls12_377_add</td><td>29.02</td><td>~3x</td></tr>
<tr><td></td><td>native_bls12_377_mul</td><td>183.1</td><td>wasm_bls12_377_mul</td><td>1893</td><td>~10x</td></tr>
<tr><td></td><td>native_bls12_377_pairing_two</td><td>1732</td><td>wasm_bls12_377_pairing_two</td><td>15310</td><td>~7x</td></tr>
<tr><td></td><td>native_bls12_377_mimc_verify</td><td>7484</td><td>wasm_bls12_377_mimc_verify</td><td>64680</td><td>~9x</td></tr>
<tr><td>bls12_381(~10x)</td><td>native_bls12_381_add</td><td>13.9</td><td>wasm_bls12_381_add</td><td>28.31</td><td>~2x</td></tr>
<tr><td></td><td>native_bls12_381_mul</td><td>177.1</td><td>wasm_bls12_381_mul</td><td>1879</td><td>~10x</td></tr>
<tr><td></td><td>native_bls12_381_pairing_two</td><td>1438</td><td>wasm_bls12_381_pairing_two</td><td>14770</td><td>~10x</td></tr>
<tr><td></td><td>native_bls12_381_mimc_verify</td><td>6411</td><td>wasm_bls12_381_mimc_verify</td><td>63260</td><td>~10x</td></tr>
<tr><td>bn254(~5x)</td><td>native_bn254_add</td><td>5.631</td><td>wasm_bn254_add</td><td>16.05</td><td>~3x</td></tr>
<tr><td></td><td>native_bn254_mul</td><td>107.7</td><td>wasm_bn254_mul</td><td>534.3</td><td>~5x</td></tr>
<tr><td></td><td>native_bn254_pairing_two</td><td>1150</td><td>wasm_bn254_pairing_two</td><td>5061</td><td>~5x</td></tr>
<tr><td></td><td>native_bn254_mimc_verify</td><td>4178</td><td>wasm_bn254_mimc_verify</td><td>19850</td><td>~5x</td></tr>
<tr><td>bw6_761(~13x)</td><td>native_bw6_761_add</td><td>30.35</td><td>wasm_bw6_761_add</td><td>26.79</td><td>\</td></tr>
<tr><td></td><td>native_bw6_761_mul</td><td>963.8</td><td>wasm_bw6_761_mul</td><td>14630</td><td>~15x</td></tr>
<tr><td></td><td>native_bw6_761_pairing_two</td><td>5715</td><td>wasm_bw6_761_pairing_two</td><td>60960</td><td>~10x</td></tr>
<tr><td></td><td>native_bw6_761_mimc_verify</td><td>20330</td><td>wasm_bw6_761_mimc_verify</td><td>299800</td><td>~15x</td></tr>
</tbody></table>
<pre><code class="language-bash"># 1. Under the jupiter repo
# 2. Has compiled jupiter-dev
sh ./benchmark.sh
</code></pre>
<h1><a class="header" href="#himalia" id="himalia">Himalia</a></h1>
<p>Himalia 是 Patract 构建的一系列不同语言的访问链<code>pallet-contracts</code>合约模块的sdk库的总称。对于Substrate而言，已经存在了一些面向不同语言的访问链的sdk。但是由于<code>pallet-contracts</code>模块的特殊性，需要继续构建基于访问链的sdk上的访问合约模块的sdk。其特殊性主要表现在：</p>
<ul>
<li>合约的部署与调用（包含rpc调用与交易调用）需要依据合约的metadata.json（类似于Solidity的abi文件）提供的信息组装参数的顺序的与编码，而链的metadata只能告知链的sdk该链上存在合约模块的<code>instantiate</code>，<code>call</code>等方法，不可能告知某个合约的调用参数的信息。因此对于合约，需要构建能解析并支持合约metadata的功能。</li>
<li>合约的Event也需要依据合约的metadata.json进行解析。因此若使用链的sdk，只能监听到出现了合约模块的event，但是却无法解析出event中的内容。因此需要提供合约的sdk支持event的监听。</li>
<li>合约的状态（存储）位于子树，且其key的编码与分配方式与runtime不一致。合约存储的key的编码分配方式与该合约所使用的合约语言框架有关（例如Ask!的实现有可能与ink!不一样），因此需要针对不同的合约语言框架实现对应的存储解析方式。同时这个解析过程也十分依赖合约本身提供的metadata。</li>
<li>合约的开发者为广大的项目方，而链的开发者大部分情况下为开发链的项目方。因此在管理私钥的场景方面会出现比较大的区别。很多情况下与链高权限相关的私钥管理为节点自身，数量比较少且门槛高，或者很多情况下都依托于多签或者投票控制。而合约的开发者很广泛，后台安全管理质量参差不齐，另一方面很多合约都只有一个私钥进行控制。因此在对于合约模块的调用上，在私钥管理方面更需要一个高安全低门槛的解决方案。因此合约sdk可以在这些场景上做特殊处理，以减少合约开发者安全管理的门槛。</li>
</ul>
<p>因此 Himalia 是有十分重要的存在理由的。Himalia的定位类似于 Ethereum 生态里的 Web3J, Web3py 等等。</p>
<h2><a class="header" href="#项目仓库地址" id="项目仓库地址">项目仓库地址</a></h2>
<p>当前 Himalia 提供的不同语言的合约sdk有如下版本：</p>
<ul>
<li>go: https://github.com/patractlabs/go-patract</li>
<li>python: https://github.com/patractlabs/py-patract</li>
<li>java: 还未实现</li>
<li>c#(.net): 还未实现 </li>
</ul>
<h1><a class="header" href="#tutorial-3" id="tutorial-3">tutorial</a></h1>
<p>Himalia 用于与链的合约部分交互的sdk，需要首先启动一个节点才能进行后续的执行过程。</p>
<p>对于有<code>pallet-contracts</code>功能的节点，我们推荐使用 Europa 作为节点的替代。更多的信息请参阅Europa的<a href="himalia/./europa.html">文档</a>。</p>
<p>Europa 可以以一下命令简单安装使用：</p>
<pre><code class="language-bash">git install --recurse-submodules https://github.com/patractlabs/europa.git --force --locked
europa --tmp
</code></pre>
<p>另一方面也可以使用 Patract 的测试网 <a href="https://github.com/patractlabs/jupiter">Jupiter</a>，或者 Parity 提供的合约测试网 <a href="https://github.com/paritytech/canvas-node.git">Canvas-node</a></p>
<h2><a class="header" href="#go" id="go">go</a></h2>
<p>PatractGo 依赖于 <a href="https://github.com/centrifuge/go-substrate-rpc-client">GSRPC</a>。Go 版本的 Himalia 项目叫做 <a href="https://github.com/patractlabs/go-patract">go-patract</a></p>
<p>在安装了 PatractGo 之后，可以采用如下方式快速部署，调用一个合约。完整案例请参考 <a href="https://github.com/patractlabs/go-patract/blob/master/contracts/erc20/transfer_test.go">transfer_test</a></p>
<h3><a class="header" href="#部署合约-2" id="部署合约-2">部署合约</a></h3>
<pre><code class="language-go">// read the code wasm from file
codeBytes, err := ioutil.ReadFile(&quot;/path/to/contracts.wasm&quot;)
if err != nil {
    return err
}
// create the api
cApi, err := rpc.NewContractAPI(env.URL())

// read the abi(metadata) for contract
metaBz, err := ioutil.ReadFile(&quot;/path/to/contracts_metadata.json&quot;)
cApi.WithMetaData(metaBz)

// create context with from auth, like Alice
ctx := api.NewCtx(context.Background()).WithFrom(authKey)

// put code
_, err = cApi.Native().PutCode(ctx, codeBytes)

codeHash := readCodeHash() // get code hash

var codeBz []byte

if err := cApi.Native().Cli.GetStorageLatest(&amp;codeBz,
    &quot;Contracts&quot;, &quot;PristineCode&quot;,
    []byte(codeHash), nil); err != nil {
        return err
    }

	var endowment uint64 = 1000000000000

// Instantiate
_, contractAccount, err := cApi.Instantiate(ctx,
    types.NewCompactBalance(endowment),
    types.NewCompactGas(test.DefaultGas),
    contracts.CodeHashERC20,
    types.NewU128(totalSupply),
)    
</code></pre>
<h3><a class="header" href="#调用合约" id="调用合约">调用合约</a></h3>
<h4><a class="header" href="#rpc-call" id="rpc-call">rpc call</a></h4>
<p>调用 <code>total_supply</code> 获取当前的总共供应量。</p>
<pre><code class="language-go">var res types.U128

err := a.CallToRead(ctx,
    &amp;res,
    a.ContractAccountID,
    []string{&quot;total_supply&quot;},
)
</code></pre>
<h4><a class="header" href="#交易调用" id="交易调用">交易调用</a></h4>
<p>调用 <code>transfer</code> 转移一笔资金。</p>
<pre><code class="language-go">toParam := struct {
    Address AccountID
}{
    Address: to,
}

valueParam := struct {
    Value U128
}{
    Value: amt,
}

return a.CallToExec(ctx,
    a.ContractAccountID,
    types.NewCompactBalance(0),
    types.NewCompactGas(test.DefaultGas),
    []string{&quot;transfer&quot;},
    toParam, valueParam,
)
</code></pre>
<h2><a class="header" href="#python" id="python">python</a></h2>
<p>PatractPy 依赖于 <a href="https://github.com/polkascan/py-substrate-interface">py-substrate-interface</a>Python 版本的 Himalia 项目叫做 <a href="https://github.com/patractlabs/py-patract">py-patract</a></p>
<h3><a class="header" href="#安装" id="安装">安装</a></h3>
<pre><code class="language-bash">pip3 install -U patract-interface 
</code></pre>
<p>在 python 脚本中即可使用</p>
<pre><code class="language-bash">from patractinterface import ContractFactory, ContractAPI

// ... So something ...
</code></pre>
<h3><a class="header" href="#快速使用" id="快速使用">快速使用</a></h3>
<pre><code class="language-python">import os
from substrateinterface import SubstrateInterface, Keypair
from patractinterface.contract import ContractAPI, ContractFactory
from patractinterface.observer import ContractObserver

def main():
    # use [europa](https://github.com/patractlabs/europa) as test node endpoint, notice `type_registry` should set correctly.
    substrate=SubstrateInterface(url='ws://127.0.0.1:9944', type_registry_preset=&quot;default&quot;, type_registry={'types': {'LookupSource': 'MultiAddress'}})
    # load deployer key
    alice = Keypair.create_from_uri('//Alice')
    bob = Keypair.create_from_uri('//Bob')
    # 1. load a contract from WASM file and metadata.json file (Those files is complied by [ink!](https://github.com/paritytech/ink))
    # in this example, we use `ink/example/erc20` contract as example.
    contract = ContractFactory.create_from_file(
            substrate=substrate, # should provide a subtrate endpoint
            code_file= os.path.join(os.path.dirname(__file__), 'res', 'erc20.wasm'),
            metadata_file= os.path.join(os.path.dirname(__file__), 'res', 'erc20.json')
        )
    # upload code to chain directly
    res = contract.put_code(alice)
    print(&quot;update code hash{} res:{}&quot;.format(contract.code_hash.hex(), res.is_succes))
    # 2. instantiate the uploaded code as a contract instance
    erc20_ins = contract.new(alice, 1000000 * (10 ** 15), endowment=2*10**10, gas_limit=20000000000, deployment_salt=&quot;0x12&quot;)
    # 2.1 create a observer to listen event
    observer = ContractObserver(erc20_ins.contract_address, erc20_ins.metadata, substrate)
    # 3. send a transfer call for this contract
    res = erc20_ins.transfer(alice, bob.ss58_address, 100000, gas_limit=20000000000)
    print('transfer res', res.is_succes)

    def on_transfer(num, evt):
        print(&quot;on_transfer in {} : {} {} {}&quot;.format(num, evt['from'], evt['to'], evt['value']))

    def on_approval(num, evt):
        print(&quot;on_approval in {} : {} {} {}&quot;.format(num, evt['owner'], evt['spender'], evt['value']))
    # 4 set event callback 
    observer.scanEvents(handlers={
        'Transfer': on_transfer,
        'Approve': on_approval
    })

if __name__ == &quot;__main__&quot;:
    main()
    pass
</code></pre>
<h1><a class="header" href="#go-patract" id="go-patract">go-patract</a></h1>
<h2><a class="header" href="#intruduction" id="intruduction">Intruduction</a></h2>
<p>Most contract behaviors are highly related to context. In addition to interacting with the chain, user-oriented contract applications also need to provide users with current relevant context status information:</p>
<pre><code>+--DAPP-Front-End--------------+        +---Chain-------------------------+
|                              |        |                                 |
| +----+  +------------------+ |        | +-------+     +-------+         |
| |    |  |                  | | Commit | |       |     |       |         |
| |    |  |   Polkadot-JS    +------------&gt; Node  +----&gt;+ Node  |         |
| |    +-&gt;+                  | |   Tx   | |       |     |       |         |
| |    |  |                  | |        | +-------+     +----+-++         |
| |    |  +------------------+ |        |                    ^ |          |
| | UI |                       |        +---------------------------------+
| |    |  +------------------+ |                             | |
| |    |  |                  | |        +--DAPP-Server--------------------+
| |    |  |                  | |  Push  | +--------+     +-----v-------+  |
| |    +&lt;-+   Model          +&lt;-----------+        +-----+             |  |
| |    |  |                  | |        | | Server |     |  PatractGo  |  |
| |    |  |                  +------------&gt;        +-----+             |  |
| +----+  +------------------+ | Query  | +----+---+     +-----+-------+  |
+------------------------------+        |      |               |          |
                                        |      |         +-----v-------+  |
                                        |      |         |             |  |
                                        |      +--------&gt;+   DataBase  |  |
                                        |                |             |  |
                                        |                +-------------+  |
                                        |                                 |
                                        +---------------------------------+
</code></pre>
<p>PatractGo is mainly responsible for implementing micro-services in a DApp. Unlike querying the state of the chain API, PatractGo can monitor the calls and events generated by the specified contract. Developers can obtain the state storage based on this information to maintain consistent state with the chain. Through data services based on a typical API-DB architecture, the front-end DApp can efficiently and concisely obtain the state on the chain as context information.</p>
<p>Based on the API of chain nodes, PatractGo obtains block information and summarizes and filters it, and sends contract-related messages and events based on metadata analysis to the handler protocol specified by the developer. For example, for a typical ERC20 contract, the developer can use the channel to subscribe to all transfer events that occur, and then synchronize them into the database, so that other microservices can provide services corresponding to the token data of the account, such as querying the current token holding distribution and other logics.</p>
<p>Therefor, PatractGo will achieve the following support:</p>
<ul>
<li>Complete the secondary packaging of the contract module interface, complete operations such as <code>put_code</code>, <code>call</code>, <code>instantiate</code>, etc.</li>
<li>Parse the metadata.json information of the contract, and support the automatic generation of http service interface for the metadata corresponding contract</li>
<li>Scanning and monitoring support of the contract status on the chain for statistics and analysis</li>
<li>Basic command line tool support for native interaction with the contract, mainly used to test the security of the contract</li>
<li>SDK development examples for ERC20 contract support</li>
</ul>
<h2><a class="header" href="#design" id="design">Design</a></h2>
<p>PatractGo consists of the following packages:</p>
<ul>
<li><code>patractgo/metadata</code> contract metadata processing, and metadata-based contract processing</li>
<li><code>patractgo/rpc/native</code> re-encapsulation of the contract module interface to provide the contract-related interaction based on chain RPC</li>
<li><code>patractgo/rpc</code> implement the interaction with the contract based on metadata</li>
<li><code>patractgo/rest</code> implements an http service based on metadata to interact with the contract</li>
<li><code>patractgo/observer</code> Monitoring and Scanning support for contract status on the chain</li>
<li><code>patractgo/contracts/erc20</code> supports ERC20 contracts and examples</li>
<li><code>patractgo/tools</code> some tools for contracts develop</li>
</ul>
<p>Currently, we haven't designed the module which could <strong>auto-gen code</strong> for a contract based on a metadata, thus we provide
<code>patractgo/contracts/erc20</code> as an example to show how to warp a contract as a go source file.</p>
<p>This <strong>auto contract code generator</strong> feature would be developed with <code>java-patract</code> repo later (in next version), <strong>for their have same logic to generate the code for contracts</strong>.</p>
<h1><a class="header" href="#py-patract" id="py-patract">py-patract</a></h1>
<p>PatractPy is a contract SDK to support the development of Python scripts that interact with contracts, including automated scripts to support testing. Unlike PatractGo, PatractPy is mainly for script development, so PatractPy mainly completes contract-related RPC interfaces, and completes contract deployment and instantiation-related operations.</p>
<p>PatractPy will provide support for <a href="https://github.com/patractlabs/europa">europa</a> env, which is a good environment for contract exec sandbox,
With PatractPy, we can write contract unittest by python, which is more friendly to developer and can easy use other test tools.</p>
<p>PatractPy will be based on <a href="https://github.com/polkascan/py-substrate-interface">polkascan's Python Substrate Interface</a>, which is a Python sdk for Substrate.</p>
<p>Element Group for disscusion: https://app.element.io/#/room/#PatractLabsDev:matrix.org</p>
<p>PatractPy will achieve the following support:</p>
<ul>
<li>Some support that missing in <a href="https://github.com/polkascan/py-substrate-interface">polkascan's Python Substrate Interface</a>, which is needed for contracts</li>
<li>Provide Scanning and monitoring support for contract to do statistics and analysis</li>
<li>Provide a SDK development example for ERC20 contract</li>
<li>Support For unittest to canvas or <a href="https://github.com/patractlabs/europa">europa</a> env.</li>
</ul>
<h2><a class="header" href="#basic-apis-for-contracts" id="basic-apis-for-contracts">Basic Apis For Contracts</a></h2>
<p>As <a href="https://github.com/polkascan/py-substrate-interface">polkascan's Python Substrate Interface</a> has provide some support to contract api, so we not need to important the api for contract calls, but there is some api to add:</p>
<ul>
<li><code>SubstrateSubscriber</code> is a subscriber support to subscribe data changes in chain, for example, the events in chain.</li>
<li><code>get_contract_event_type</code> add event decode support for contracts.</li>
</ul>
<p>The basic api split into 2 parts:</p>
<ul>
<li>Contract, include:
<ul>
<li>contractExecutor: This api could construct an extrinsic to call a contract, would be packed into a block and change state.</li>
<li>contractReader: This api could construct a rpc request to call a contract, do not pack into a block and do not change any state.</li>
<li>contractCreator: This api is used for <code>instantiate</code> a contract and holding the WASM code and metadata, receive following parameters:
<ul>
<li><code>gas_limit</code></li>
<li><code>endowment</code></li>
<li><code>deployment_salt</code> (<code>salt</code> parameter in <code>instantiate</code>)</li>
</ul>
</li>
<li>ContractAPI: This api is used for <code>call</code> a contract, is a wrapper for <code>contractExecutor</code> and <code>contractReader</code>, developers could use this api to react with contracts. This api could create a instance depends on the metadata, auto generate the contract access functions based on the contract. And the auto-gen functions receive the parameters which defined in contracts, besides receive following common parameters:
<ul>
<li><code>gas_limit</code></li>
<li><code>value</code> (notice, if current call's <code>payable</code> is false, this <code>value</code> must be <code>0</code>)</li>
</ul>
</li>
<li>ContractFactory: This api is used for constructing a contract instance in python, and developer could use this instance to access contract. This is a wrapper for <code>contractCreator</code> and <code>ContractAPI</code></li>
</ul>
</li>
<li>Observer, include:
<ul>
<li>ContractObserver: This api is used for listen the events in contracts. </li>
</ul>
</li>
</ul>
<p>All methods which belong to the instance of <code>ContractAPI</code> and <code>ContractFactory</code> <strong>receive a keypair as the first parameter</strong>, as the sender for this operation. And from the second parameter, receive the parameters defined in contracts.</p>
<h3><a class="header" href="#contractfactory-and-contractapi-is-used-to-react-with-contracts" id="contractfactory-and-contractapi-is-used-to-react-with-contracts"><code>ContractFactory</code> and <code>ContractAPI</code> is used to react with contracts</a></h3>
<p>we add a factory to put code and deploy contracts to chain:</p>
<pre><code class="language-python">factory = ContractFactory.create_from_file(
    substrate=substrate, 
    code_file=os.path.join(os.path.dirname(__file__), 'constracts', 'ink', 'erc20.wasm'),
    metadata_file=os.path.join(os.path.dirname(__file__), 'constracts', 'ink', 'erc20.json')
)

res = factory.put_code(alice) # alice is the keypair for `//Alice`
print(res.is_succes)

# this api is `ContractAPI`
api = factory.new(alice, 1000000 * (10 ** 15), endowment=10**15, gas_limit=1000000000000)
print(api.contract_address) # contract_address is the deployed contract
</code></pre>
<p>The factory will generate constructors from metadata file.</p>
<p>We add api by metadata for Contract, api will auto generate caller for contract from metadata:</p>
<pre><code class="language-python"># create a ContractAPI from an existed contract address
api = ContractAPI(contract_address, contract_metadata, substrate)

# api will auto generate caller for contract from metadata
alice_balance_old = api.balance_of(bob, alice.ss58_address) # bob is the keypair for `//Bob`

res = api.transfer(alice, bob.ss58_address, 100000, gas_limit=20000000000)
logging.info(f'transfer res {res.error_message}')
print(res.is_succes)

alice_balance = api.balance_of(bob, alice.ss58_address)
logging.info(f'transfer alice_balance {alice_balance}')

bob_balance = api.balance_of(bob, bob.ss58_address)
logging.info(f'transfer bob_balance {bob_balance}')
</code></pre>
<p>The api will generate exec and read api from metadata file, for example:</p>
<pre><code class="language-json">      {
        &quot;args&quot;: [
          {
            &quot;name&quot;: &quot;owner&quot;,
            &quot;type&quot;: {
              &quot;displayName&quot;: [
                &quot;AccountId&quot;
              ],
              &quot;type&quot;: 5
            }
          }
        ],
        &quot;docs&quot;: [
          &quot; Returns the account balance for the specified `owner`.&quot;,
          &quot;&quot;,
          &quot; Returns `0` if the account is non-existent.&quot;
        ],
        &quot;mutates&quot;: false,
        &quot;name&quot;: [
          &quot;balance_of&quot;
        ],
        &quot;payable&quot;: false,
        &quot;returnType&quot;: {
          &quot;displayName&quot;: [
            &quot;Balance&quot;
          ],
          &quot;type&quot;: 1
        },
        &quot;selector&quot;: &quot;0x56e929b2&quot;
      },
</code></pre>
<p>In api, can call by:</p>
<pre><code class="language-python">bob_balance = api.balance_of(bob, bob.ss58_address)
logging.info(f'transfer bob_balance {bob_balance}')
</code></pre>
<h3><a class="header" href="#contractobserver-is-used-to-listen-contracts-events" id="contractobserver-is-used-to-listen-contracts-events"><code>ContractObserver</code> is used to listen contracts events</a></h3>
<p>ContractObserver can observer events for a contract:</p>
<pre><code class="language-python">substrate=SubstrateInterface(url=&quot;ws://127.0.0.1:9944&quot;, type_registry_preset='canvas')
contract_metadata = ContractMetadata.create_from_file(
    metadata_file=os.path.join(os.path.dirname(__file__), 'constracts', 'ink', 'erc20.json'),
    substrate=substrate
)
observer = ContractObserver(&quot;0x8eaf04151687736326c9fea17e25fc5287613693c912909cb226aa4794f26a48&quot;, contract_metadata, substrate)

# for some handlers (callbacks)
observer.scanEvents()
</code></pre>
<p>The handler function can take the erc20 support as a example.</p>
<h2><a class="header" href="#special-case-erc20-api" id="special-case-erc20-api">Special case: ERC20 API</a></h2>
<p>Except react contract by <code>ContractAPI</code>, developers could create the wrapper by themself to react with corresponding contract. <code>py-contract</code> create an <code>ERC20 API</code> as an example to show this.</p>
<p>ERC20 api provide a wapper to erc20 contract exec, read and observer events, it can be a example for contracts api calling.</p>
<pre><code class="language-python">
# init api
substrate=SubstrateInterface(url=&quot;ws://127.0.0.1:9944&quot;, type_registry_preset='canvas')

contract_metadata = ContractMetadata.create_from_file(
    metadata_file=os.path.join(os.path.dirname(__file__), 'constracts', 'ink', 'erc20.json'),
    substrate=substrate
)

alice = Keypair.create_from_uri('//Alice')
bob = Keypair.create_from_uri('//Bob')

# erc20 api
erc20 = ERC20.create_from_contracts(
    substrate= substrate, 
    contract_file= os.path.join(os.path.dirname(__file__), 'constracts', 'ink', 'erc20.wasm'),
    metadata_file= os.path.join(os.path.dirname(__file__), 'constracts', 'ink', 'erc20.json')
)

# deplay a erc20 contract
erc20.put_and_deploy(alice, 1000000 * (10 ** 15))

# read total supply
total_supply = erc20.totalSupply()

# transfer
erc20.transfer_from(alice,
    from_acc=alice.ss58_address, 
    to_acc=bob.ss58_address, 
    amt=10000)

erc20.transfer(alice, bob.ss58_address, 10000)

# get balance
alice_balance = erc20.balance_of(alice.ss58_address)

# approve
erc20.approve(alice, spender=bob.ss58_address, amt=10000)

# get allowance
alice_allowance = erc20.allowance(alice.ss58_address, bob.ss58_address)

</code></pre>
<p><code>ERC20Observer</code> is a event observer for erc20 contract:</p>
<pre><code class="language-python">observer = ERC20Observer.create_from_address(
    substrate = substrate, 
    contract_address = contract_address,
    metadata_file= os.path.join(os.path.dirname(__file__), 'constracts', 'ink', 'erc20.json')
)

def on_transfer(num, evt):
    logging.info(&quot;on_transfer in {} : {} {} {}&quot;.format(num, evt['from'], evt['to'], evt['value']))

def on_approval(num, evt):
    logging.info(&quot;on_approval in {} : {} {} {}&quot;.format(num, evt['owner'], evt['spender'], evt['value']))


observer.scanEvents(on_transfer = on_transfer, on_approval = on_approval)
</code></pre>
<h3><a class="header" href="#observer-for-contracts" id="observer-for-contracts">Observer For Contracts</a></h3>
<p><code>ContractObserver</code> is a observer to listen events by contract with a given address:</p>
<pre><code class="language-python">observer = ContractObserver.create_from_address(
    substrate = substrate, 
    contract_address = 'contract_address',
    metadata_file= os.path.join(os.path.dirname(__file__), 'constracts', 'ink', 'erc20.json')
)

def on_transfer(num, evt):
    logging.info(&quot;on_transfer in {} : {} {} {}&quot;.format(num, evt['from'], evt['to'], evt['value']))

def on_approval(num, evt):
    logging.info(&quot;on_approval in {} : {} {} {}&quot;.format(num, evt['owner'], evt['spender'], evt['value']))

observer.scanEvents(from_num, to_num, {
    'Transfer': on_transfer,
    'Approve': on_approval
})
</code></pre>
<p><code>handlers</code> is a hander dictionary by name to hander function.</p>
<h2><a class="header" href="#unittest-node-environment" id="unittest-node-environment">Unittest Node Environment</a></h2>
<p>PatractPy can support write contract unittest by node environment.</p>
<p>At First We need install <a href="https://github.com/patractlabs/europa">europa</a>.</p>
<pre><code class="language-python">from patractinterface.contracts.erc20 import ERC20
from patractinterface.unittest.env import SubstrateTestEnv

class UnittestEnvTest(unittest.TestCase):
    @classmethod
    def setUp(cls):
        # start env or use canvas for a 6s block
        cls.env = SubstrateTestEnv.create_europa(port=39944)
        cls.env.start_node()

        cls.api = SubstrateInterface(url=cls.env.url(), type_registry_preset=cls.env.typ(), type_registry=cls.env.types())
        cls.alice = Keypair.create_from_uri('//Alice')
        cls.bob = Keypair.create_from_uri('//Bob')

        cls.erc20 = ERC20.create_from_contracts(
            substrate= cls.substrate, 
            contract_file= os.path.join(os.path.dirname(__file__), 'constracts', 'ink', 'erc20.wasm'),
            metadata_file= os.path.join(os.path.dirname(__file__), 'constracts', 'ink', 'erc20.json')
        )
        cls.erc20.put_and_deploy(alice, 1000000 * (10 ** 15))

        return

    def tearDown(cls):
        cls.env.stop_node()

    def test_transfer(self):
        self.erc20.transfer_from(alice,
            from_acc=alice.ss58_address, 
            to_acc=bob.ss58_address, 
            amt=10000)
        # some more test case

if __name__ == '__main__':
    unittest.main()
</code></pre>
<p>By example, we can use python to write testcase for some complex logics, by <a href="https://github.com/patractlabs/europa">europa</a>, we can test the contracts for python scripts.</p>
<h1><a class="header" href="#metis" id="metis">Metis</a></h1>
<p>Metis 是 Patract 主导的合约标准实现及示例案例库。在这个仓库里，将会对 ink!, Ask! 等能运行于<code>pallet-contracts</code>的合约语言框架提供对应的合约标准的实现及通用案例。</p>
<p>Metis 类似于 Ethereum 生态中的 OpenZepplin-contracts，给合约开发者提供可复用的轮子，不必从零开始编写合约代码。新接触波卡生态尝试合约开发的开发者，在经过简单基础知识的学习后，可以借助本仓库的代码快速搭建出常见的应用。</p>
<blockquote>
<p>由于当前ink!合约还未稳定，Ask!合约还在开发当中，因此两个平台都还未进行标准的制定。因此当前在Metis中提供的的实现是一些模仿Solidity中的EIP相关的标准的模仿实现。</p>
</blockquote>
<h1><a class="header" href="#overview" id="overview">Overview</a></h1>
<h2><a class="header" href="#仓库地址" id="仓库地址">仓库地址</a></h2>
<p><a href="https://github.com/patractlabs/metis">https://github.com/patractlabs/metis</a></p>
<h2><a class="header" href="#项目结构" id="项目结构">项目结构</a></h2>
<p>metis 项目分为以下三个模块: <code>trait</code>、<code>stubs</code>、<code>impls</code>。</p>
<h3><a class="header" href="#trait" id="trait">trait</a></h3>
<p><code>trait</code> 模块包含了常用的合约标准定义，如:erc20、erc721 等。 ink! 合约通过定义 <code>#[ink::trait_definition]</code> 的方式实现类似 solidity <code>interface</code> 的特性以此来定义通用共享的合约接口。</p>
<p>metis 根据开发实践经验制定了一些运用比较广泛的 <code>trait_definition</code> 的合约标准。 开发者只需要将 metis 中定义的 <code>trait</code> 包添加到自己项目的依赖中, 
并像实现 rust trait 一样实现 <code>#[ink::trait_definition]</code> 中定义的方法，就可以实现一个通用的标准合约。</p>
<h4><a class="header" href="#example-3" id="example-3">example</a></h4>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use ink_lang as ink;

#[ink::trait_definition]
pub trait IErc20 {
    /// Creates a new ERC-20 contract and initializes it with the initial supply for the instantiator.
    #[ink(constructor)]
    fn new(initial_supply: Balance) -&gt; Self;

    /// Returns the total supply.
    #[ink(message)]
    fn total_supply(&amp;self) -&gt; Balance;

    /// Transfers 'amount' from caller to 'to'.
    #[ink(message, payable)]
    fn transfer(&amp;mut self, to: AccountId, amount: Balance);
}
<span class="boring">}
</span></code></pre></pre>
<h3><a class="header" href="#stubs" id="stubs">stubs</a></h3>
<p><code>stubs</code> 模块是对 <code>trait</code> 模块中定义的<code>trait definition</code>合约的 <code>桩 (stub)</code> 实现。 stub 的用途主要是跨合约调用时将合约地址组装成合约对象，通过合约对象可以调用合约地址对应的链上合约方法。</p>
<p>熟悉 solidity 的同学都知道 solidity 是通过 interface 来实现合约间调用，如：<code>interfaceContract _interfaceContract = interfaceContract(_addr);</code>，所以看到这里可能有疑问：既然 ink! 已经实现了通过 <code>#[ink::trait_definition]</code> 来实现合约接口，
为什么不使用<code>trait</code> 来实现跨合约调用，而需要 <code>stub</code> 呢？ 这确实是 parity 官方下一步需要实现的特性，但目前还不支持，有兴趣的同学可以跟踪官方的实现（https://github.com/paritytech/ink/issues/631）。</p>
<p>因此 metis 通过提供合约的桩（stub）,来实现跨合约调用的功能, 开发者可以将 stub 合约引入项目中来实现跨合约调用。</p>
<blockquote>
<p>接口定义的结构与合约完全一样，但未定义任何函数实现，仅声明它们。 这种类型的声明通常称为 <code>stub</code>；</p>
</blockquote>
<h4><a class="header" href="#example-4" id="example-4">example</a></h4>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use ink_lang as ink;

#[ink::contract]
mod erc20 {
    use ierc20::IErc20;

    #[ink(storage)]
    pub struct Erc20Stub {}

    impl IErc20 for Erc20Stub {
        #[ink(constructor)]
        fn new(initial_supply: Balance) -&gt; Self { unimplemented!() }

        #[ink(message)]
        fn total_supply(&amp;self) -&gt; Balance { unimplemented!() }

        #[ink(message, payable)]
        fn transfer(&amp;mut self, to: AccountId, amount: Balance) { unimplemented!() }
    }
}
<span class="boring">}
</span></code></pre></pre>
<h3><a class="header" href="#impls" id="impls">impls</a></h3>
<p>impls 模块里提供了合约的开发实现案例， 其中包括以上提及的 <code>trait</code> 、<code>stubs</code> 模块中包的使用， 以及 zkp 等特性的合约案例。</p>
<h4><a class="header" href="#example-5" id="example-5">example</a></h4>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use ink_lang as ink;

#[ink::contract]
mod erc20 {
    use ierc20::IErc20;

    #[ink(storage)]
    pub struct Erc20 {
        total_supply: Balance,
        // more fields ...
    }

    impl IErc20 for Erc20 {
        #[ink(constructor)]
        fn new(initial_supply: Balance) -&gt; Self {
            // implementation ...
        }

        #[ink(message)]
        fn total_supply(&amp;self) -&gt; Balance {
            // implementation ...
        }

        #[ink(message, payable)]
        fn transfer(&amp;mut self, to: AccountId, amount: Balance) {
            // implementation ...
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<h1><a class="header" href="#erc20" id="erc20">ERC20</a></h1>
<p>metis 提供了完全符合 <code>ERC20</code> 标准的 <a href="https://github.com/patractlabs/metis/tree/master/traits/token/erc20">trait_definition</a> 、<a href="https://github.com/patractlabs/metis/tree/master/stubs/token/erc20">合约间调用 stub</a> 
以及 <a href="https://github.com/patractlabs/metis/tree/master/impls/token/erc20">erc20合约</a> 的标准实现。</p>
<p>下面详细介绍下 metis 提供的 erc20 trait 和 stub 的使用方法。</p>
<h2><a class="header" href="#trait-definition" id="trait-definition">Trait Definition</a></h2>
<p>通过 <code>#[ink::trait_definition]</code> 处理宏，开发者可以定义自己的 trait definitions，然后可以由 ink! 智能合约实现。 这允许为不同的具体实现定义共享的智能合约接口。 注意这种 <code>#[ink::trait_definition]</code> 可以在任何地方定义，甚至可以在另一个 crate 中定义！</p>
<h3><a class="header" href="#erc20-trait-源码解析" id="erc20-trait-源码解析">erc20 trait 源码解析</a></h3>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span>#![cfg_attr(not(feature = &quot;std&quot;), no_std)]

<span class="boring">fn main() {
</span>// 注意：这里需要导出 tarit 定义供其他包使用
pub use self::erc20::{Error, IErc20, Result};
pub mod events {
    // pub use crate::erc20::{Transfer, Approval};
}

use ink_lang as ink;
#[ink::contract]
mod erc20 {
    use ink_lang as ink;
    use ink_prelude::string::String;
    /// The ERC-20 result type.
    pub type Result&lt;T&gt; = core::result::Result&lt;T, Error&gt;;

    /// Event emitted when a token transfer occurs.
    #[ink(event)]
    pub struct Transfer {
        #[ink(topic)]
        pub from: Option&lt;AccountId&gt;,
        #[ink(topic)]
        pub to: Option&lt;AccountId&gt;,
        #[ink(topic)]
        pub value: Balance,
    }
    /// Event emitted when an approval occurs that `spender` is allowed to withdraw
    /// up to the amount of `value` tokens from `owner`.
    #[ink(event)]
    pub struct Approval {
        #[ink(topic)]
        pub owner: AccountId,
        #[ink(topic)]
        pub spender: AccountId,
        #[ink(topic)]
        pub value: Balance,
    }

    /// The ERC-20 error types.
    #[derive(Debug, PartialEq, Eq, scale::Encode, scale::Decode)]
    #[cfg_attr(feature = &quot;std&quot;, derive(scale_info::TypeInfo))]
    pub enum Error {
        /// Returned if not enough balance to fulfill a request is available.
        InsufficientBalance,
        /// Returned if not enough allowance to fulfill a request is available.
        InsufficientAllowance,
    }

    /// Trait implemented by all ERC-20 respecting smart contracts.
    #[ink::trait_definition]
    pub trait IErc20 {
        /// Creates a new ERC-20 contract with the specified initial supply.
        #[ink(constructor)]
        fn new(
            initial_supply: Balance,
            name: Option&lt;String&gt;,
            symbol: Option&lt;String&gt;,
            decimals: Option&lt;u8&gt;,
        ) -&gt; Self;

        /// Returns the token name.
        #[ink(message)]
        fn token_name(&amp;self) -&gt; Option&lt;String&gt;;

        /// Returns the token symbol.
        #[ink(message)]
        fn token_symbol(&amp;self) -&gt; Option&lt;String&gt;;

        /// Returns the token decimals.
        #[ink(message)]
        fn token_decimals(&amp;self) -&gt; Option&lt;u8&gt;;
        /// Returns the total token supply.
        #[ink(message)]
        fn total_supply(&amp;self) -&gt; Balance;
        /// Returns the account balance for the specified `owner`.
        #[ink(message)]
        fn balance_of(&amp;self, owner: AccountId) -&gt; Balance;

        /// Transfers `value` amount of tokens from the caller's account to account `to`.
        #[ink(message)]
        fn transfer(&amp;mut self, to: AccountId, value: Balance) -&gt; Result&lt;()&gt;;

        /// Returns the amount which `spender` is still allowed to withdraw from `owner`.
        #[ink(message)]
        fn allowance(&amp;self, owner: AccountId, spender: AccountId) -&gt; Balance;

        /// Transfers `value` tokens on the behalf of `from` to the account `to`.
        #[ink(message)]
        fn transfer_from(&amp;mut self, from: AccountId, to: AccountId, value: Balance) -&gt; Result&lt;()&gt;;

        /// Allows `spender` to withdraw from the caller's account multiple times, up to
        /// the `value` amount.
        #[ink(message)]
        fn approve(&amp;mut self, spender: AccountId, value: Balance) -&gt; Result&lt;()&gt;;
    }

    // TODO tmp hack struct for passing compile
    #[ink(storage)]
    pub struct Phantom;
    impl Phantom {
        #[ink(constructor)]
        pub fn new() -&gt; Self {
            Phantom {}
        }
        #[ink(message)]
        pub fn message(&amp;self) {}
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>首先必须要定义 <code>#[ink::trait_definition]</code>, 这里定义了一个 <code>IErc20</code> 的 trait 接口。在 trait_definition 中必须定义至少一个 <code>#[ink(constructor)]</code> 和 <code>#[ink(message)]</code>。
所有接口只有声明，没有实现。</p>
<p><code>#[ink::trait_definition]</code> 是可以脱离于 <code>#[ink::contract]</code> 单独定义的，一般简单的trait的，只需要定义 trait_definition 即可，如在前文介绍中定义的那样。但在这个 erc20 trait 的
实现中，之所以定义在<code>#[ink::contract]</code> 中，是因为 <code>#[ink(event)]</code> 的存在，我们希望不仅提供接口，也提供一些事件和错误的定义，这样开发者在使用我们的 erc20-trait 包时可以清楚的知道会
触发那些事件和发生哪些错误，但美中不足的是<code>#[ink(event)]</code>不能脱离于<code>#[ink::contract]</code>单独定义，所以我们只能临时实现一个 <code>Phantom</code> 合约及存储来使编译通过。这个问题我们已经像官方提交issue
（https://github.com/paritytech/ink/issues/683） 。</p>
<p>在定义了<code>#[ink::trait_definition]</code>后，注意需要将 trait 导出，如： <code>pub use self::erc20::{Error, IErc20, Result};</code>, 只有导出后才可以被其他 crate 使用。</p>
<h3><a class="header" href="#使用-erc20-trait-实现合约" id="使用-erc20-trait-实现合约">使用 erc20-trait 实现合约</a></h3>
<ol>
<li>创建一个新合约</li>
</ol>
<pre><code>cargo contract new myerc20
</code></pre>
<p>注意： metis中所有合约的 ink! dependencies 都是最新的ink仓库中的代码，因此需要将新建的合约项目中的依赖改为最新，不然会引起版本冲突，如下：</p>
<pre><code class="language-toml">[dependencies]
ink_primitives = { version = &quot;3.0.0-rc3&quot;, git = &quot;https://github.com/paritytech/ink&quot;, default-features = false }
ink_metadata = { version = &quot;3.0.0-rc3&quot;, git = &quot;https://github.com/paritytech/ink&quot;, default-features = false, features = [&quot;derive&quot;], optional = true }
ink_env = { version = &quot;3.0.0-rc3&quot;, git = &quot;https://github.com/paritytech/ink&quot;, default-features = false }
ink_storage = { version = &quot;3.0.0-rc3&quot;, git = &quot;https://github.com/paritytech/ink&quot;, default-features = false }
ink_lang = { version = &quot;3.0.0-rc3&quot;, git = &quot;https://github.com/paritytech/ink&quot;, default-features = false }
ink_prelude = { version = &quot;3.0.0-rc3&quot;, git = &quot;https://github.com/paritytech/ink&quot;, default-features = false }
</code></pre>
<ol start="2">
<li>将 <code>erc20-trait</code> 包添加到新合约项目的 <code>cargo.toml</code> 依赖中</li>
</ol>
<pre><code class="language-toml">[dependencies]
erc20-trait = { git = &quot;https://github.com/patractlabs/metis&quot;, default-features = false, features = [&quot;ink-as-dependency&quot;] }

[features]
default = [&quot;std&quot;]
std = [
    &quot;erc20-trait/std&quot;,
]
</code></pre>
<p>这里添加依赖时，启用了 <code> features = [&quot;ink-as-dependency&quot;]</code> 特性，是因为在 ink！中合约作为依赖是需要开启改特性。 </p>
<ol start="3">
<li>在新合约项目中实现 erc20 trait</li>
</ol>
<p>完整代码在: <code>https://github.com/patractlabs/metis/blob/master/impls/token/erc20</code></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span>#![cfg_attr(not(feature = &quot;std&quot;), no_std)]

<span class="boring">fn main() {
</span>use ink_lang as ink;

#[ink::contract]
mod erc20 {
    // 这里需要导入 erc20_trait 中定义的接口和错误
    use erc20_trait::{Error, IErc20, Result};
    use ink_prelude::string::String;

    /// Basic version of StandardToken, with no allowances.
    #[ink(storage)]
    pub struct Erc20 {
        /// Total token supply.
        total_supply: Lazy&lt;Balance&gt;,
        /// Mapping from owner to number of owned token.
        balances: StorageHashMap&lt;AccountId, Balance&gt;,
        /// Mapping of the token amount which an account is allowed to withdraw
        /// from another account.
        allowances: StorageHashMap&lt;(AccountId, AccountId), Balance&gt;,
        /// Name of the token
        name: Option&lt;String&gt;,
        /// Symbol of the token
        symbol: Option&lt;String&gt;,
        /// Decimals of the token
        decimals: Option&lt;u8&gt;,
    }

    impl IErc20 for Erc20 {
        #[ink(constructor)]
        fn new(
            initial_supply: Balance,
            name: Option&lt;String&gt;,
            symbol: Option&lt;String&gt;,
            decimals: Option&lt;u8&gt;,
        ) -&gt; Self {
            // implementation ...
        }

        // Omitted part of interface
        
        #[ink(message)]
        fn transfer_from(&amp;mut self, from: AccountId, to: AccountId, value: Balance) -&gt; Result&lt;()&gt; {
            // implementation ...
        }
        
        #[ink(message)]
        fn approve(&amp;mut self, spender: AccountId, value: Balance) -&gt; Result&lt;()&gt; {
            // implementation ...
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#跨合约调用-stub" id="跨合约调用-stub">跨合约调用 stub</a></h2>
<p>在此之前我们已经通过 erc20 trait 实现了标准 erc20 合约, 在一些复杂的 dapps 中与 erc20 合约交互是必不可少的。metis 提供了 <code>erc20-stub</code> 支持跨合约调用我们已经实现erc20合约。</p>
<h3><a class="header" href="#erc20-stub-源码解析" id="erc20-stub-源码解析">erc20 stub 源码解析</a></h3>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span>#![cfg_attr(not(feature = &quot;std&quot;), no_std)]

<span class="boring">fn main() {
</span>// 需要将 Erc20Stub 导出供子合约调用
pub use self::erc20::Erc20Stub;
use ink_lang as ink;

#[ink::contract]
mod erc20 {
    use ink_prelude::string::String;

    /// The ERC-20 error types.
    #[derive(Debug, PartialEq, Eq, scale::Encode, scale::Decode)]
    #[cfg_attr(feature = &quot;std&quot;, derive(scale_info::TypeInfo))]
    pub enum Error {
        /// Returned if not enough balance to fulfill a request is available.
        InsufficientBalance,
        /// Returned if not enough allowance to fulfill a request is available.
        InsufficientAllowance,
    }

    /// The ERC-20 result type.
    pub type Result&lt;T&gt; = core::result::Result&lt;T, Error&gt;;

    #[ink(storage)]
    pub struct Erc20Stub {}

    impl Erc20Stub {
        /// Creates a new ERC-20 contract with the specified initial supply.
        #[ink(constructor)]
        pub fn new(
            _initial_supply: Balance,
            _name: Option&lt;String&gt;,
            _symbol: Option&lt;String&gt;,
            _decimals: Option&lt;u8&gt;,
        ) -&gt; Self {
            unimplemented!()
        }

        /// Returns the token name.
        #[ink(message, selector = &quot;0x6b1bb951&quot;)]
        pub fn token_name(&amp;self) -&gt; Option&lt;String&gt; {
            unimplemented!()
        }

        /// Returns the token symbol.
        #[ink(message, selector = &quot;0xb42c3368&quot;)]
        pub fn token_symbol(&amp;self) -&gt; Option&lt;String&gt; {
            unimplemented!()
        }

        /// Returns the token decimals.
        #[ink(message, selector = &quot;0xc64b0eb2&quot;)]
        pub fn token_decimals(&amp;self) -&gt; Option&lt;u8&gt; {
            unimplemented!()
        }

        /// Returns the total token supply.
        #[ink(message, selector = &quot;0x143862ae&quot;)]
        pub fn total_supply(&amp;self) -&gt; Balance {
            unimplemented!()
        }

        /// Returns the account balance for the specified `owner`.
        #[ink(message, selector = &quot;0xb7d968c9&quot;)]
        pub fn balance_of(&amp;self, _owner: AccountId) -&gt; Balance {
            unimplemented!()
        }

        /// Transfers `value` amount of tokens from the caller's account to account `to`.
        #[ink(message, selector = &quot;0x10d455c2&quot;)]
        pub fn transfer(&amp;mut self, _to: AccountId, _value: Balance) -&gt; Result&lt;()&gt; {
            unimplemented!()
        }

        /// Returns the amount which `spender` is still allowed to withdraw from `owner`.
        #[ink(message, selector = &quot;0xc04aa300&quot;)]
        pub fn allowance(&amp;self, _owner: AccountId, _spender: AccountId) -&gt; Balance {
            unimplemented!()
        }

        /// Transfers `value` tokens on the behalf of `from` to the account `to`.
        #[ink(message, selector = &quot;0xbb399017&quot;)]
        pub fn transfer_from(
            &amp;mut self,
            _from: AccountId,
            _to: AccountId,
            _value: Balance,
        ) -&gt; Result&lt;()&gt; {
            unimplemented!()
        }

        /// Allows `spender` to withdraw from the caller's account multiple times, up to
        /// the `value` amount.
        #[ink(message, selector = &quot;0x4ce0e831&quot;)]
        pub fn approve(&amp;mut self, _spender: AccountId, _value: Balance) -&gt; Result&lt;()&gt; {
            unimplemented!()
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>通过以上代码可以知道，在 stub 合约中没有erc20 具体逻辑的实现，只提供了接口的空实现，该合约将作为父合约被子合约实例化，
并且可以在子合约中，调用父合约的接口。</p>
<p>注意：在该erc20-stub 合约中每个合约方法的 <code>selector</code>都设置了固定的值, 这里的 <code>selector</code> 的值是由 <code>BLAKE2(&quot;IErc20::{message_func_name}&quot;.to_string().as_bytes())[0..4]</code> 
公式计算得出。</p>
<p>在 ink! 体系中 <code>selector</code> 的计算方式跟 solidity 的有所区别，在 solidity 中是对 方法签名做hash运算， 而在 ink! 中有一套自己的计算方式，最简的是对 <code>{message_func_name}</code>
进行hash运算，但 message 是通过 <code>#[ink::trait_definition]</code> 实现时，采用 {trait_name} + {message_func_name} 混合hash 的方式，详细的计算规则，
可以查看 ink！源码（https://github.com/paritytech/ink/blob/master/crates/lang/ir/src/ir/item_impl/callable.rs#L190）。</p>
<p>因此，erc20-stub 只适用于 metis 中实现的 erc20 合约（通过 IErc20 trait 实现）的跨合约调用, 如果是其他方式实现的 erc20 合约，由于 <code>selector</code> 不匹配，不能使用此 stub。</p>
<h3><a class="header" href="#通过-erc20-stub-跨合约调用" id="通过-erc20-stub-跨合约调用">通过 erc20 stub 跨合约调用</a></h3>
<ol>
<li>将 <code>erc20-stub</code> 包添加到新合约项目的 <code>cargo.toml</code> 依赖中</li>
</ol>
<pre><code class="language-toml">[dependencies]
erc20-stub = { git = &quot;https://github.com/patractlabs/metis&quot;, default-features = false, features = [&quot;ink-as-dependency&quot;] }

[features]
default = [&quot;std&quot;]
std = [
    &quot;erc20-stub/std&quot;,
]
</code></pre>
<ol start="2">
<li>在新合约中实例化 erc20 stub</li>
</ol>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span>#![cfg_attr(not(feature = &quot;std&quot;), no_std)]

<span class="boring">fn main() {
</span>use ink_lang as ink;

#[ink::contract]
mod delegate {
    use erc20_stub::Erc20Stub;
    use ink_env::call::FromAccountId;
    use ink_storage::Lazy;

    #[ink(storage)]
    pub struct CrossCall {
        callee: Lazy&lt;Erc20Stub&gt;,
    }

    impl CrossCall {
        #[ink(constructor)]
        pub fn new(callee: AccountId) -&gt; Self {
            let token: Erc20Stub = FromAccountId::from_account_id(callee);
            Self { callee: Lazy::new(token) }
        }

        #[ink(message)]
        pub fn transfer(&amp;mut self, owner: AccountId, amount: Balance) {
            self.callee.transfer(owner, amount).unwrap();
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>在 ink! 合约中可以使用 <code>FromAccountId</code> 实例化合约对象（不是创建一个新合约），接下来就可以使用合约对象对合约方法进行跨合约调用。</p>
<blockquote>
<p><code>ink_storage::Lazy</code> 管理数据实体，并在存储上延迟执行读取/写入操作, 只有在确定确实需要读取/写入时，才会在存储上执行。</p>
</blockquote>
<h1><a class="header" href="#access-control" id="access-control">Access Control</a></h1>
<p>虽然智能合约应用是去中心化的，但在合约中实现必要的中心化访问控制可以使合约更加安全。</p>
<h2><a class="header" href="#ownership-and-ownable" id="ownership-and-ownable">Ownership and Ownable</a></h2>
<p>所有权的概念是访问控制最常见和最基本的形式：有一个帐户是合约的 owner，可以在合约上执行管理任务。 </p>
<p>metis 提供 <a href="https://github.com/patractlabs/metis/tree/master/traits/access/ownership">Ownership</a>  来实现您合约中的所有权。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[ink::trait_definition]
pub trait Ownable {
    /// Initializes the contract setting the deployer as the initial owner.
    #[ink(constructor)]
    fn new() -&gt; Self;

    /// Returns the account id of the current owner.
    #[ink(message)]
    fn owner(&amp;self) -&gt; Option&lt;AccountId&gt;;

    /// Transfer ownership to new owner.
    #[ink(message)]
    fn transfer_ownership(&amp;mut self, new_owner: Option&lt;AccountId&gt;);
}
<span class="boring">}
</span></code></pre></pre>
<h3><a class="header" href="#使用-ownership-实现合约所有权" id="使用-ownership-实现合约所有权">使用 <code>Ownership</code> 实现合约所有权</a></h3>
<ol>
<li>将 <code>ownership</code> 包添加到新合约项目的 <code>cargo.toml</code> 依赖中</li>
</ol>
<pre><code class="language-toml">[dependencies]
ownership = { version = &quot;0.1.0&quot;, git = &quot;https://github.com/patractlabs/metis&quot;, default-features = false }

[features]
default = [&quot;std&quot;]
std = [
    &quot;ownership/std&quot;,
]
</code></pre>
<ol start="2">
<li>最简实现 <code>ownership</code></li>
</ol>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use ink_lang as ink;

#[ink::contract]
mod ownership {
	use super::Ownable;

    #[ink(storage)]
    pub struct Ownership {
        owner: Option&lt;AccountId&gt;,
    }

    impl Ownable for Ownership {
        #[ink(constructor)]
        fn new() -&gt; Self {
            Self {
                owner: Self::env().caller(),
            }
        }

        #[ink(message)]
        fn owner(&amp;self) -&gt; Option&lt;AccountId&gt; {
            self.owner.clone()
        }

        #[ink(message)]
        fn transfer_ownership(&amp;mut self, new_owner: Option&lt;AccountId&gt;) {
            assert_eq!(self.owner(), Some(self.env().caller()));
            if let Some(new_one) = new_owner {

            }
            self.owner = new_owner;
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>默认情况下，合约的所有者是部署它的帐户，<code>Ownable</code> 也提供了 <code>transfer_ownership</code> 方法可以让您将合约所有权转移到其他帐户。</p>
<h1><a class="header" href="#carpo" id="carpo">Carpo</a></h1>
<h1><a class="header" href="#patract" id="patract">Patract</a></h1>
<p><img src="patract/./imgs/overview.jpg" alt="overview" /></p>
<p>Patract 做的东西具体包括:</p>
<ul>
<li>
<p>在开发者端：</p>
<ul>
<li>Jupiter：独立的智能合约测试网，提供给合约开发者测试合约链的环境。</li>
<li>Ask!：AssemblyScript 版的 Ink! 合约框架，吸引 TS/JS 的开发者，给不愿意使用 rust 的合约开发者另一个选择。</li>
<li>Redspot：Wasm 合约开发工作流和脚手架：对标 Ethereum 生态中的 Tuffle/Redhat，让合约开发项目化，自动化的工具。Redspot 采用插件化设计，运行开发者添加自己设计的插件丰富 Redspot 的功能。</li>
<li>Europa：Runtime 和合约运行沙盒：对标 Ethereum 生态中的 EthereumJS/Ganache，给合约开发者提供了丰富的调试信息，便于快速开发合约。</li>
<li>Elara：实时和可扩展的波卡 API：对标 Ethereum 中的 Infura，给合约项目方提供节点的 Endpoint，不用自行搭建节点获取数据。</li>
<li>Megaclite：零知识证明的底层支持：在 Jupiter/Patract 链中提供零知识原语支持，可以允许项目方设计 zkRollup 或其他零知识相关合约。</li>
<li>Metis：Ink! 合约标准库：对标 Ethereum 中的 openzeppelin-contracts，给合约开发者提供可复用的轮子，不必从零开始编写合约代码。</li>
<li>Himalia：多语言合约 SDK：对标 Ethereum 中的 Web3J，Web3Py 等 SDK，给合约项目方提供不同语言的环境，丰富的接口与合约进行交互。</li>
<li>Leda：合约监控台：对标 Ethereum 生态中各类合约监控设施，让合约项目方随时监控合约的存储情况，代币转移情况，合约调用情况等等。</li>
<li>Carpo：专注开发合约的智能 WebIDE：对标 Ethereum 中的 Remix，但其将会是对 Patract 以上合约开发工具的集大成者。Carpo 将采用最新的 WebIDE 技术，使得云端开发无限贴近本地开发，同时完整的云端让开发者无需搭建任何开发环境即可进行开发，开箱即用的 Patract 工具链给合约开发者提供了一体化开发体验，让开发者的开发、调试、测试和部署的合约过程如丝般顺畅。</li>
</ul>
</li>
<li>
<p>在用户端包括：</p>
<ul>
<li>Patra Store：作为 Patract 平行链钱包和 DApp 生态的入口，在测试网阶段将集成一些示例应用和配套开发工具套件用法演示，帮助开发者快速开发 Wasm 合约和前端界面，帮助用户快速进入波卡新合约生态。</li>
<li>Patra Scan：专门为智能合约链优化的区块链浏览器，集成比统一的链浏览器更丰富的合约数据信息展示，增强统计和自定义的查询功能。</li>
</ul>
</li>
</ul>
<h1><a class="header" href="#elara" id="elara">Elara</a></h1>
<p>在Polkadot、Kusama或Parachain中，RPC是Dapp与网络交互的界面。随着Polkadot网络的不断扩展，会有越来越多的平行链上线，也会有越来越多的平行链支持智能合约功能。面对越来越多的平行链，开发者们为了与之交互需要搭建并维护多条链的节点RPC，这对于他们而言将是巨大的开发成本。</p>
<p>无论是面对开发者的开发测试需要，还是用户线上对Dapp的使用需求，方便便捷、快速稳定的网络接入能力都是必备条件之一。因此，为开发者们和普通用户提供统一简化的网络接入服务能力是服务Dapp开发者的必要支撑，也是Polkadot生态的基础设施。</p>
<p>Elara的目标是构建一个类似Infura 的基础架构和网络公共接入服务,为开发者提供多链接入的统一接入层。 我们将创建一个普适的架构，可以很方便接入Polkadot、Kusama、各个平行链和各个substrate链，即专注于为Polkadot、Kusama服务，也保持扩展性，普惠整个Substrate生态。</p>
<p>另外，Elara将作为智能合约开发生态服务的一部分，在未来将与Patract Suite的其他组件进行整合，在合约开发环境支持、开发工具组件、合约部署和应用发布等方面进行全方位整合，简化应用基础架构，让开发者可以专注于构建上层应用。</p>
<p>当前，我们已经提供在线服务elara.patract.io ．欢迎社区使用Elara:</p>
<ul>
<li>所有人都可以使用Elara提供的Polkadot和多个生态主网的公共共享RPC服务( 如wss://polkadot.elara.patract.io 和 https://polkadot.elara.patract.io ).</li>
<li>开发者可以访问elara.patract.io获得免费接入多个网络的独占在线服务.</li>
</ul>
<p>更多信息:</p>
<p>Github:  <a href="https://github.com/patractlabs/elara">https://github.com/patractlabs/elara</a></p>
<p>Homepage:  <a href="https://elara.patract.io">https://elara.patract.io</a></p>
<p>Docs:<a href="https://docs.elara.patract.io/">https://docs.elara.patract.io/</a></p>
<h1><a class="header" href="#tutorial-4" id="tutorial-4">Tutorial</a></h1>
<p>Elara的API需要有效的Project Endpoint包含在您的请求中。此标识符应附加到请求URL。</p>
<h2><a class="header" href="#获取your-project-endpoint" id="获取your-project-endpoint">获取YOUR-PROJECT-ENDPOINT</a></h2>
<p>1.使用您的github帐户登录<a href="https://elara.patract.io/">Elara官方网站</a></p>
<p>2.进入<a href="https://elara.patract.io/#/dashboard/console">Elara Dashboard</a>，单击以选中左侧边栏中的主链。</p>
<p>3.单击右上角的“创建新项目”按钮，在弹出对话框中输入“ PROJECT-NAME”，然后单击“确定”。如果一切正常，您将看到一条消息，说明该项目已成功创建。</p>
<p>4.在项目列表中，单击项目以进入项目详细信息页面
-有一列信息显示“ PID”，一串长度为32的字符和数字，即项目的“ YOUR-PROJECT-ID”
-有一列显示“ ENDPOINTS”的信息，包括访问ENDPOINT的“ https”和“ wss”。那就是项目的“ YOUR-PROJECT-ENDPOINT”</p>
<h2><a class="header" href="#发出请求" id="发出请求">发出请求</a></h2>
<p>使用这些ENDPOINT之一作为您的客户端程序的Provider。</p>
<p>*注意：请务必将YOUR-PROJECT-ENDPOINT替换为Elara仪表板中的Project Endpoint *</p>
<ul>
<li>方法1：curl发送HTTP请求：</li>
</ul>
<pre><code>#curl http
curl --location --request POST 'https://YOUR-PROJECT-ENDPOINT' \
    --header 'Content-Type: application/json' \
    --data-raw '{
        &quot;id&quot;:1,
        &quot;jsonrpc&quot;:&quot;2.0&quot;,
        &quot;method&quot;:&quot;chain_getBlock&quot;,
        &quot;params&quot;:[]
    }'
</code></pre>
<ul>
<li>方法2：使用wscat发送websocket请求：</li>
</ul>
<pre><code>parachain@ubuntu:~/elara$ wscat  -c wss://YOUR-PROJECT-ENDPOINT
Connected (press CTRL+C to quit)
&gt; {&quot;id&quot;:1,&quot;jsonrpc&quot;:&quot;2.0&quot;,&quot;method&quot;:&quot;chain_getBlock&quot;,&quot;params&quot;:[]}
&lt; {&quot;jsonrpc&quot;:&quot;2.0&quot;,&quot;result&quot;:{&quot;block&quot;:{&quot;extrinsics&quot;:[&quot;0x280402000b901ac96e7601&quot;],&quot;header&quot;:{&quot;digest&quot;:{&quot;logs&quot;:[&quot;0x066175726120dfcdf90f00000000&quot;,&quot;0x05617572610101acb2a4725f0f8945593cea6aa6ef70df2a8fd4a2c4eb1c0d1bf51828f26e371f897473113541f9c0d9f94e51471a3d685a86866a12133ea012d2777bb9709589&quot;]},&quot;extrinsicsRoot&quot;:&quot;0xcca5112546305b07d904c2aa26155dffe6c66de043708e1ac89e57609fbcc6d1&quot;,&quot;number&quot;:&quot;0x17922&quot;,&quot;parentHash&quot;:&quot;0xdb798a19707ef9085b97d0b00854c613ae4abdb560e2ea1164f2e7bbfbc288a1&quot;,&quot;stateRoot&quot;:&quot;0xdc575fe975067ded933020df9035db0e496143e6b9a062a4313fd1f6e9d02922&quot;}},&quot;justification&quot;:null},&quot;id&quot;:1}
&gt; 
</code></pre>
<ul>
<li>方法3：使用SDK</li>
</ul>
<p>您可以参考polkadot-js，使用以下类似代码通过Https或Websocket访问节点：</p>
<pre><code>const { ApiPromise, WsProvider } = require('@polkadot/api');
const { HttpProvider } = require('@polkadot/rpc-provider');

(async function () {
// Http
const httpProvider = new HttpProvider('https://YOUR-PROJECT-ENDPOINT')
const hash = await httpProvider.send('chain_getBlockHash', [])
console.log('latest block Hash', hash)

// Websocket
const wsProvider = new WsProvider('wss://YOUR-PROJECT-ENDPOINT')
const api = await ApiPromise.create({ provider: wsProvider })
//Do something

})()
</code></pre>
<p>请务必注意，JSON-RPC请求与传输无关，可以通过HTTPS，Websockets发出相同的请求。</p>
<h1><a class="header" href="#设计简述" id="设计简述">设计简述</a></h1>
<p>Elara有长期的开发迭代规划和运维目标，为的是能够支撑Polkadot生态开发者从万+级别到亿+级别的持续跃迁。Elara的核心是一套高性能、高可用和高扩展的分布式架构。与其他提供 Node API Service的项目有显著区别：</p>
<ol>
<li>
<p>Elara的后端架构不是简单但低效的NodePool+LoadBalancer。这种方案无法承担大规模应用和流量的冲击，无法及时扩展，因为Node会成为体系中的显著瓶颈。而在Elara的架构中，只需要很少数量的Node提供基础数据源。Elara通过分布式架构的设计、多服务的融合以及对请求访问路径的极致优化，来支撑海量用户的访问。NodePool方案的短期开发成本较低，但长期服务用户的单位成本却极高。反过来，Elara在初期的技术成本投入较高，但长期可以极大降低服务用户的单位成本，同时还可以保障高服务质量。</p>
</li>
<li>
<p>Elara专注于为生态开发者提供极简的全功能体验。我们提供的是极其“薄薄”的一层服务，希望开发者感受不到Elara的存在。Elara提供的API服务不仅包括节点的所有功能，也包括了历史状态数据功能，还包括项目的请求统计仪表盘等功能，给开发者提供的服务能力远大于自己部署节点所提供的能力。所以，在这个目标之下，&quot;一键节点部署&quot;之类的功能就显得非常多余，开发者只应该专注于自己的业务应用。</p>
</li>
<li>
<p>Elara是一个开放的平台，秉持社区共建的原则。在接下来的版本迭代中，我们会陆续接入更多主网，还会建立一套Polkadot生态主链和平行链自动化接入的流程规范。</p>
</li>
</ol>
<p>在整体设计上，Elara设计成微服务的架构体系，由多个可独立进行扩展的微服务组成。所有的微服务启动后都以独立进程运行，所以在将来可以对单独的微服务进行平行扩容、重构、替换实现等升级。其中用到<code>Redis</code>作为数据高速访问的存储容器,和使用<code>kafka</code>做架构解耦。将来可以很容易地在此设计的基础上，添加更多复杂的功能模块，让Elara发挥更强大的效果。</p>
<p>Elara的核心架构大概如下所示</p>
<p><img src="https://user-images.githubusercontent.com/21072025/111115173-35923280-859f-11eb-8172-737c07aab4e7.png" alt="elara" /></p>
<h1><a class="header" href="#api-接入" id="api-接入">API 接入</a></h1>
<h2><a class="header" href="#endpoint-规则" id="endpoint-规则">ENDPOINT 规则</a></h2>
<p><code>Https</code>接入</p>
<pre><code>https://api.elara.patract.io/&lt;Network&gt;/&lt;YOUR-PROJECT-ID&gt;
</code></pre>
<p><code>Websocket</code>接入</p>
<pre><code>wss://api.elara.patract.io/&lt;Network&gt;/&lt;YOUR-PROJECT-ID&gt;
</code></pre>
<h2><a class="header" href="#支持网络" id="支持网络">支持网络</a></h2>
<table><thead><tr><th><strong>NETWORK</strong></th><th><strong>DESCRIPTION</strong></th><th>ENDPOINT</th></tr></thead><tbody>
<tr><td>Polkadot</td><td>JSON-RPC over HTTPS</td><td>https://api.elara.patract.io/Polkadot/YOUR-PROJECT-ID</td></tr>
<tr><td>Polkadot</td><td>JSON-RPC over WebSocket</td><td>wss://api.elara.patract.io/Polkadot/YOUR-PROJECT-ID</td></tr>
<tr><td>Kusama</td><td>JSON-RPC over HTTPS</td><td>https://api.elara.patract.io/Kusama/YOUR-PROJECT-ID</td></tr>
<tr><td>Kusama</td><td>JSON-RPC over WebSocket</td><td>wss://api.elara.patract.io/Kusama/YOUR-PROJECT-ID</td></tr>
<tr><td>Rococo</td><td>JSON-RPC over HTTPS</td><td>https://api.elara.patract.io/Rococo/YOUR-PROJECT-ID</td></tr>
<tr><td>Rococo</td><td>JSON-RPC over WebSocket</td><td>wss://api.elara.patract.io/Rococo/YOUR-PROJECT-ID</td></tr>
<tr><td>Jupiter</td><td>JSON-RPC over HTTPS</td><td>https://api.elara.patract.io/Jupiter/YOUR-PROJECT-ID</td></tr>
<tr><td>Jupiter</td><td>JSON-RPC over WebSocket</td><td>wss://api.elara.patract.io/Jupiter/YOUR-PROJECT-ID</td></tr>
<tr><td>Darwinia</td><td>JSON-RPC over HTTPS</td><td>https://api.elara.patract.io/Darwinia/YOUR-PROJECT-ID</td></tr>
<tr><td>Darwinia</td><td>JSON-RPC over WebSocket</td><td>wss://api.elara.patract.io/Darwinia/YOUR-PROJECT-ID</td></tr>
<tr><td>Dock</td><td>JSON-RPC over HTTPS</td><td>https://api.elara.patract.io/Dock/YOUR-PROJECT-ID</td></tr>
<tr><td>Dock</td><td>JSON-RPC over WebSocket</td><td>wss://api.elara.patract.io/Dock/YOUR-PROJECT-ID</td></tr>
<tr><td>Edgeware</td><td>JSON-RPC over HTTPS</td><td>https://api.elara.patract.io/Edgeware/YOUR-PROJECT-ID</td></tr>
<tr><td>Edgeware</td><td>JSON-RPC over WebSocket</td><td>wss://api.elara.patract.io/Edgeware/YOUR-PROJECT-ID</td></tr>
<tr><td>Kulupu</td><td>JSON-RPC over HTTPS</td><td>https://api.elara.patract.io/Kulupu/YOUR-PROJECT-ID</td></tr>
<tr><td>Kulupu</td><td>JSON-RPC over WebSocket</td><td>wss://api.elara.patract.io/Kulupu/YOUR-PROJECT-ID</td></tr>
<tr><td>Nodle</td><td>JSON-RPC over HTTPS</td><td>https://api.elara.patract.io/Nodle/YOUR-PROJECT-ID</td></tr>
<tr><td>Nodle</td><td>JSON-RPC over WebSocket</td><td>wss://api.elara.patract.io/Nodle/YOUR-PROJECT-ID</td></tr>
<tr><td>Plasm</td><td>JSON-RPC over HTTPS</td><td>https://api.elara.patract.io/Plasm/YOUR-PROJECT-ID</td></tr>
<tr><td>Plasm</td><td>JSON-RPC over WebSocket</td><td>wss://api.elara.patract.io/Plasm/YOUR-PROJECT-ID</td></tr>
<tr><td>Stafi</td><td>JSON-RPC over HTTPS</td><td>https://api.elara.patract.io/Stafi/YOUR-PROJECT-ID</td></tr>
<tr><td>Stafi</td><td>JSON-RPC over WebSocket</td><td>wss://api.elara.patract.io/Stafi/YOUR-PROJECT-ID</td></tr>
<tr><td>Chainx</td><td>JSON-RPC over HTTPS</td><td>https://api.elara.patract.io/Chainx/YOUR-PROJECT-ID</td></tr>
<tr><td>Chainx</td><td>JSON-RPC over WebSocket</td><td>wss://api.elara.patract.io/Chainx/YOUR-PROJECT-ID</td></tr>
<tr><td>Mandala</td><td>JSON-RPC over HTTPS</td><td>https://api.elara.patract.io/Mandala/YOUR-PROJECT-ID</td></tr>
<tr><td>Mandala</td><td>JSON-RPC over WebSocket</td><td>wss://api.elara.patract.io/Mandala/YOUR-PROJECT-ID</td></tr>
</tbody></table>
<h2><a class="header" href="#错误代码" id="错误代码">错误代码</a></h2>
<p>如果Substrate RPC方法遇到错误，则响应对象中包含的错误成员务必是包含代码成员和描述性消息成员的对象。 以下列表包含所有可能的错误代码和关联的消息：</p>
<table><thead><tr><th><strong>CODE</strong></th><th><strong><strong>MEANING</strong></strong></th><th><strong>CATEGORY</strong></th></tr></thead><tbody>
<tr><td>-32700</td><td>Parse error</td><td>Invalid JSON</td></tr>
<tr><td>-32600</td><td>Invalid request</td><td>JSON is not a valid request object</td></tr>
<tr><td>-32601</td><td>Method not found</td><td>Method does not exist</td></tr>
<tr><td>-32602</td><td>Invalid params</td><td>Invalid method parameters</td></tr>
<tr><td>-32603</td><td>Internal error</td><td>Internal JSON-RPC error</td></tr>
<tr><td>-1</td><td>CheckAuthenticated Fail</td><td>non-standard</td></tr>
<tr><td>-2</td><td>Project Name Empty</td><td>non-standard</td></tr>
<tr><td>-3</td><td>Project Name Error!</td><td>non-standard</td></tr>
<tr><td>-4</td><td>Chain Error</td><td>non-standard</td></tr>
<tr><td>-5</td><td>Out Of Limit</td><td>non-standard</td></tr>
<tr><td>-6</td><td>NotActive</td><td>non-standard</td></tr>
<tr><td>-7</td><td>RPC Error</td><td>non-standard</td></tr>
<tr><td>-8</td><td>Project  Error</td><td>non-standard</td></tr>
<tr><td>-9</td><td>No Access Allowed</td><td>non-standard</td></tr>
<tr><td>-10</td><td>Black Uid</td><td>non-standard</td></tr>
<tr><td>-11</td><td>Duplicate Name</td><td>non-standard</td></tr>
</tbody></table>
<h2><a class="header" href="#介绍-2" id="介绍-2">介绍</a></h2>
<p>PatraStore是通过iFrame的方式嵌入Dapp，PatraStore会为Dapp提供Signer，Provider的功能。</p>
<p>阅读本文档需要对<a href="https://polkadot.js.org/docs/">pokadot-js</a>有一定的了解。</p>
<h2><a class="header" href="#overview-1" id="overview-1">Overview</a></h2>
<p>PatraStore和Dapp的通信是利用PostMessage的方式进行通信，为了方便开发者们，我们提供了一套SDK。这套SDK实现了<a href="https://github.com/polkadot-js/extension">polkadot-js/extension</a>中的协议，因此，使用我们的sdk可以完全兼容<a href="https://www.npmjs.com/package/@polkadot/extension-dapp">@polkadot/extension-dapp</a>。</p>
<p>开发者可以很方便的引入PatraStore的sdk，我们提供cdn服务托管了sdk，您只需在代码中引入<code>&lt;script type=&quot;text/javascript&quot; src=&quot;https://static.patrastore.io/sdk/store-sdk.min.js&quot;&gt;&lt;/script&gt;</code>即可。</p>
<h2><a class="header" href="#getting-started" id="getting-started">Getting started</a></h2>
<p>首先，请确保您在html中引入了<code>&lt;script type=&quot;text/javascript&quot; src=&quot;https://static.patrastore.io/sdk/store-sdk.min.js&quot;&gt;&lt;/script&gt;</code>，为了确保sdk可以正常工作，需要您在业务代码之前引用，比较好的方式是放在html的<code>head</code>标签中。</p>
<p>确保对<code>@polkadot/extension-dapp</code>的<a href="https://polkadot.js.org/docs/extension">文档</a>有一定的了解，我们在下方也会出Demo。</p>
<p>安装相应依赖。<code>yarn add @polkadot/extension-dapp</code>。</p>
<h3><a class="header" href="#请求用户授权" id="请求用户授权">请求用户授权</a></h3>
<p><strong>这一步是在以下所有操作调用之前。</strong></p>
<pre><code class="language-typescript">import { web3Enable } from '@polkadot/extension-dapp';

await web3Enable();
</code></pre>
<h3><a class="header" href="#获取injected" id="获取injected">获取Injected</a></h3>
<pre><code class="language-typescript">import { web3FromSource } from '@polkadot/extension-dapp';

// PatraStore注入injected的名称为store
const injected = await web3FromSource('store');
</code></pre>
<h3><a class="header" href="#signer" id="signer">Signer</a></h3>
<pre><code class="language-typescript">const signer = injected.signer;
</code></pre>
<p>获取到Signer之后可以使用signer调取PatraStore的签名</p>
<h3><a class="header" href="#provideroptional" id="provideroptional">Provider(Optional)</a></h3>
<p>我们提供的Provider是基于PostMessage实现，为了确保Dapp和PatraStore连接的是同一个链，建议您使用这种方式实例化Provider。</p>
<pre><code class="language-typescript">import type { ProviderInterface } from '@polkadot/rpc-provider/types';
import { WsProvider } from '@polkadot/rpc-provider';
import { web3ListRpcProviders, web3UseRpcProvider } from '@polkadot/extension-dapp';

let provider: ProviderInterface;
const providers = await web3ListRpcProviders('store');
if (providers &amp;&amp; Object.keys(providers).length &gt; 0) {
  provider = (await web3UseRpcProvider('store', Object.keys(providers)[0])).provider;
} else {
  provider = new WsProvider(url);
}
</code></pre>
<h3><a class="header" href="#init-api" id="init-api">Init Api</a></h3>
<p>经过上面的步骤，我们已经获得了Provider和Signer，下面是实例化<code>ApiPromise</code>的完整实例。</p>
<pre><code class="language-typescript">import type { ProviderInterface } from '@polkadot/rpc-provider/types';

import { ApiPromise } from '@polkadot/api/promise';
import { WsProvider } from '@polkadot/rpc-provider';
import { web3Enable, web3FromSource, web3ListRpcProviders, web3UseRpcProvider } from '@polkadot/extension-dapp';

async function initApi(): ApiPromise {
  await web3Enable();

  let provider: ProviderInterface;
  const providers = await web3ListRpcProviders('store');
  if (providers &amp;&amp; Object.keys(providers).length &gt; 0) {
    provider = (await web3UseRpcProvider('store', Object.keys(providers)[0])).provider;
  } else {
    provider = new WsProvider(url);
  }

  const { signer } = await web3FromSource('store');

  return new ApiPromise({
    provider,
    signer,
    // Jupiter types
    types: {
      &quot;LookupSource&quot;: &quot;MultiAddress&quot;,
      &quot;Address&quot;: &quot;MultiAddress&quot;,
      &quot;FullIdentification&quot;: &quot;AccountId&quot;,
      &quot;AuthorityState&quot;: {
        &quot;_enum&quot;: [
          &quot;Working&quot;,
          &quot;Waiting&quot;
        ]
      },
      &quot;EraIndex&quot;: &quot;u32&quot;,
      &quot;ActiveEraInfo&quot;: {
        &quot;index&quot;: &quot;EraIndex&quot;,
        &quot;start&quot;: &quot;Option&lt;u64&gt;&quot;
      },
      &quot;UnappliedSlash&quot;: {
        &quot;validator&quot;: &quot;AccountId&quot;,
        &quot;reporters&quot;: &quot;Vec&lt;AccountId&gt;&quot;
      }
    }
  })
}

const api: ApiPromise = await initApi();
</code></pre>
<h3><a class="header" href="#更多用法" id="更多用法">更多用法</a></h3>
<p>请参考<a href="https://polkadot.js.org/docs/extension">https://polkadot.js.org/docs/extension</a></p>
<h2><a class="header" href="#发布dapp" id="发布dapp">发布DApp</a></h2>
<p>目前我们不支持托管DApp，需要开发者部署好DApp，然后在PatraStore上面上传一下资料（域名，类型，图片，账户等信息）。</p>
<p>确保您开发的DApp前端引入了我们的<a href="patra-store/./getting-starter.html">SDK</a>，否则DApp在PatraStore中无法正常工作。</p>
<ol>
<li>进入<a href="https://patrastore.io/jupiter-a1/system/developer">https://patrastore.io/:chain-value/system/developer</a>页面</li>
<li>点击Publish DApp按钮
<img src="patra-store/./imgs/publish.png" alt="" />
<img src="patra-store/./imgs/publish-form.png" alt="" /></li>
<li>选择Account，然后填入DApp的基本信息</li>
<li><strong>在html中加入meta标签</strong>
<pre><code class="language-html">&lt;!-- accountId必须和您选择的账户地址一致，我们后台会间隔一段时间检查一下meta标签，如果accountId和账户地址不一致，DApp将会变为Offline状态 --&gt;
&lt;meta name=&quot;patrastore:verify&quot; content=&quot;accountId&quot; &gt;
</code></pre>
</li>
<li>点击<code>Publish</code>按钮，如果上方填的信息无误，即可成功发布DApp。</li>
</ol>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
