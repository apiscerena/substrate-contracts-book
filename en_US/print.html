<!DOCTYPE HTML>
<html lang="zh_CN" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Substrate Contracts Book</title>
        
        <meta name="robots" content="noindex" />
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        
        <link rel="icon" href="favicon.svg">
        
        
        <link rel="shortcut icon" href="favicon.png">
        
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="introduction.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="contracts/overview.html"><strong aria-hidden="true">1.1.</strong> Contracts Overview</a></li><li class="chapter-item expanded "><a href="contracts/model.html"><strong aria-hidden="true">1.2.</strong> Contracts Model</a></li><li class="chapter-item expanded "><a href="contracts/language.html"><strong aria-hidden="true">1.3.</strong> Contracts Language (Framework)</a></li><li class="chapter-item expanded "><a href="contracts/wasm_first_step.html"><strong aria-hidden="true">1.4.</strong> Brief introduction of Wasm</a></li></ol></li><li class="chapter-item expanded "><a href="pallet-contracts/introduction.html"><strong aria-hidden="true">2.</strong> pallet-contracts module</a></li><li class="chapter-item expanded "><a href="ink/introduction.html"><strong aria-hidden="true">3.</strong> ink!</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ink/tutorial.html"><strong aria-hidden="true">3.1.</strong> ink! tutorial</a></li><li class="chapter-item expanded "><a href="ink/framework.html"><strong aria-hidden="true">3.2.</strong> ink! framework</a></li><li class="chapter-item expanded "><a href="ink/edsl-basic.html"><strong aria-hidden="true">3.3.</strong> ink! eDSL basic element</a></li><li class="chapter-item expanded "><a href="ink/call-contracts.html"><strong aria-hidden="true">3.4.</strong> ink! contract call</a></li><li class="chapter-item expanded "><a href="ink/ink-solidity.html"><strong aria-hidden="true">3.5.</strong> ink! compile with solidity</a></li><li class="chapter-item expanded "><a href="ink/cargo-contract.html"><strong aria-hidden="true">3.6.</strong> cargo-contract</a></li><li class="chapter-item expanded "><a href="ink/trap.html"><strong aria-hidden="true">3.7.</strong> ink! suck</a></li></ol></li><li class="chapter-item expanded "><a href="ask/introduction.html"><strong aria-hidden="true">4.</strong> Ask!</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ask/tutorial.html"><strong aria-hidden="true">4.1.</strong> tutorial</a></li><li class="chapter-item expanded "><a href="ask/design.html"><strong aria-hidden="true">4.2.</strong> design</a></li><li class="chapter-item expanded "><a href="ask/basics.html"><strong aria-hidden="true">4.3.</strong> basic</a></li><li class="chapter-item expanded "><a href="ask/example.html"><strong aria-hidden="true">4.4.</strong> example</a></li></ol></li><li class="chapter-item expanded "><a href="solang/introduction.html"><strong aria-hidden="true">5.</strong> Solang</a></li><li class="chapter-item expanded "><a href="redspot/introduction.html"><strong aria-hidden="true">6.</strong> Redspot</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="redspot/tutorial.html"><strong aria-hidden="true">6.1.</strong> tutorial</a></li><li class="chapter-item expanded "><a href="redspot/overview.html"><strong aria-hidden="true">6.2.</strong> Overview</a></li><li class="chapter-item expanded "><a href="redspot/configuration.html"><strong aria-hidden="true">6.3.</strong> configuration</a></li><li class="chapter-item expanded "><a href="redspot/runtime-environment.html"><strong aria-hidden="true">6.4.</strong> Runtime Environment</a></li><li class="chapter-item expanded "><a href="redspot/console.html"><strong aria-hidden="true">6.5.</strong> console</a></li><li class="chapter-item expanded "><a href="redspot/q-and-a.html"><strong aria-hidden="true">6.6.</strong> Q &amp; A</a></li><li class="chapter-item expanded "><a href="redspot/plugin.html"><strong aria-hidden="true">6.7.</strong> plugin</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="redspot/plugin/redspot-chai.html"><strong aria-hidden="true">6.7.1.</strong> @redspot/chai</a></li><li class="chapter-item expanded "><a href="redspot/plugin/redspot-gas-reporter.html"><strong aria-hidden="true">6.7.2.</strong> @redspot/gas-reporter</a></li><li class="chapter-item expanded "><a href="redspot/plugin/redspot-patract.html"><strong aria-hidden="true">6.7.3.</strong> @redspot/patract</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="europa/introduction.html"><strong aria-hidden="true">7.</strong> Europa</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="europa/tutorial.html"><strong aria-hidden="true">7.1.</strong> tutorial</a></li><li class="chapter-item expanded "><a href="europa/execution_info.html"><strong aria-hidden="true">7.2.</strong> explain for execution log</a></li><li class="chapter-item expanded "><a href="europa/sample.html"><strong aria-hidden="true">7.3.</strong> example for debug</a></li><li class="chapter-item expanded "><a href="europa/wasm_executor.html"><strong aria-hidden="true">7.4.</strong> Wasm executor</a></li><li class="chapter-item expanded "><a href="europa/wasm_backtrace.html"><strong aria-hidden="true">7.5.</strong> Wasm Backtrace</a></li></ol></li><li class="chapter-item expanded "><a href="zkmega/introduction.html"><strong aria-hidden="true">8.</strong> zkMega</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="zkmega/tutorial.html"><strong aria-hidden="true">8.1.</strong> tutorial</a></li><li class="chapter-item expanded "><a href="zkmega/contract.html"><strong aria-hidden="true">8.2.</strong> ZKP contract</a></li><li class="chapter-item expanded "><a href="zkmega/example.html"><strong aria-hidden="true">8.3.</strong> example</a></li><li class="chapter-item expanded "><a href="zkmega/benchmark.html"><strong aria-hidden="true">8.4.</strong> benchmark</a></li></ol></li><li class="chapter-item expanded "><a href="himalia/introduction.html"><strong aria-hidden="true">9.</strong> Himalia</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="himalia/tutorial.html"><strong aria-hidden="true">9.1.</strong> tutorial</a></li><li class="chapter-item expanded "><a href="himalia/go-patract.html"><strong aria-hidden="true">9.2.</strong> go-patract</a></li><li class="chapter-item expanded "><a href="himalia/py-patract.html"><strong aria-hidden="true">9.3.</strong> py-patract</a></li></ol></li><li class="chapter-item expanded "><a href="metis/introduction.html"><strong aria-hidden="true">10.</strong> Metis</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="metis/tokens.html"><strong aria-hidden="true">10.1.</strong> Tokens</a></li><li class="chapter-item expanded "><a href="metis/access-control.html"><strong aria-hidden="true">10.2.</strong> Access Control</a></li></ol></li><li class="chapter-item expanded "><a href="carpo/introduction.html"><strong aria-hidden="true">11.</strong> Carpo</a></li><li class="chapter-item expanded "><a href="patract/introduction.html"><strong aria-hidden="true">12.</strong> Patract</a></li><li class="chapter-item expanded "><a href="elara/introduction.html"><strong aria-hidden="true">13.</strong> Elara</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="elara/tutorial.html"><strong aria-hidden="true">13.1.</strong> tutorial</a></li><li class="chapter-item expanded "><a href="elara/design.html"><strong aria-hidden="true">13.2.</strong> design</a></li><li class="chapter-item expanded "><a href="elara/API.html"><strong aria-hidden="true">13.3.</strong> API</a></li></ol></li><li class="chapter-item expanded "><a href="patra-store/introduction.html"><strong aria-hidden="true">14.</strong> PatraStore</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="patra-store/overview.html"><strong aria-hidden="true">14.1.</strong> Overview</a></li><li class="chapter-item expanded "><a href="patra-store/getting-starter.html"><strong aria-hidden="true">14.2.</strong> Getting Starter</a></li><li class="chapter-item expanded "><a href="patra-store/publish-dapps.html"><strong aria-hidden="true">14.3.</strong> Publish DApp</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                        
                        <button id="language-toggle" class="icon-button" type="button" title="Select language" aria-label="Select language" aria-haspopup="true" aria-expanded="false" aria-controls="language-list">
                            <i class="fa fa-globe"></i>
                        </button>
                        <ul id="language-list" class="language-popup" aria-label="Languages" role="menu">
                          
                            <li role="none"><a href="../en_US/print.html"><button role="menuitem" class="language" id="light">English</button></a></li>
                          
                            <li role="none"><a href="../zh_CN/print.html"><button role="menuitem" class="language" id="light">中文</button></a></li>
                          
                        </ul>
                        
                    </div>

                    <h1 class="menu-title">Substrate Contracts Book</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#substrate-contracts-book" id="substrate-contracts-book">Substrate Contracts Book</a></h1>
<h2><a class="header" href="#introduction" id="introduction">Introduction</a></h2>
<p>This book introduces a series of knowledge related to the contract system in Substrate. The book is written by Aten @atenjin, who comes from Patract (<a href="https://patract.io/">https://patract.io/</a>) @<a href="https://github.com/patractlabs">patractlabs</a>. You can check the repository of this book on <a href="https://github.com/patractlabs/substrate-contracts-book">GitHub</a> and we welcome you to contribute to this book.</p>
<p>Because <code>pallet-evm</code>, which is the contract of EVM/solidity system, has relatively rich information in the Ethereum ecosystem, <code>pallet-evem</code> will not be explained as a key point in this contract book. Other contract systems, such as pallet-actor, or libra transplantation contract platform, are in a relatively early stage of research, so they will not be mentioned in this book either.</p>
<p>This book focuses on <code>pallet-contracts</code>, which is the WASM contracts, and contains the following topics:</p>
<ul>
<li><code>pallet-contracts</code>: the contract platform (also referred as contract module) to run the contract</li>
<li>Language for writing contracts, which are:
<ul>
<li><code>ink!</code></li>
<li><code>Ask!</code></li>
<li><code>Solang</code></li>
</ul>
</li>
<li>Tools to develop contracts, which are:
<ul>
<li><code>Redspot</code></li>
<li><code>Europa</code></li>
<li><code>Elara</code></li>
<li>and so on..</li>
</ul>
</li>
</ul>
<p>To make contract developers to better understand how the <code>pallet-contracts</code> module and WASM contracts work, this book also includes some information about WASM and blockchain contract models.</p>
<h1><a class="header" href="#contract-system-overview" id="contract-system-overview">Contract System Overview</a></h1>
<p>Model of the blockchain running contract is considered to be the combination of the blockchain environment (distributed consensus system) and a platform that can run a piece of logic. You can see the following examples:</p>
<ul>
<li>Bitcoin model can be divided into block model, PoW, and Bitcoin script.</li>
<li>Ethereum model can be divided into blocks, state model, PoW, and EVM.</li>
<li>Substrate model can be divided into blocks, state model, Bft consensus, and Runtime.</li>
</ul>
<p>In conclusion, we can divide the blockchain model into two parts:</p>
<ul>
<li>Underlying system that runs the blockchain, which provides a distributed and trusted environment.</li>
<li>Business logic of the chain, which runs in this trusted environment.</li>
</ul>
<p>However, <strong>the execution results must be consistent for the same code and state</strong>, because of features of the blockchain system. Therefore, the running environment must make sure that different running nodes will not cause <strong>inconsistent</strong> results. To achieve this goal, most blockchains use the <strong>sandbox</strong>.</p>
<p>The platform for running the contract is the business logic of a chain. <strong>The code that can run on this business logic is open, and the content of the contract is not controlled by the chain itself</strong>. In this case, a sandbox environment is needed to isolate the running of various contracts.</p>
<h2><a class="header" href="#what-is-sandbox" id="what-is-sandbox">What is sandbox?</a></h2>
<p>Sandbox is well known in the computer field. In the blockchain, sandbox is generally run by a virtual machine because the virtual machine can simulate the sandbox environment most easily.</p>
<p>Different chains use different virtual machines to run the contract sandbox:</p>
<ul>
<li>
<p>Ethereum</p>
<p>The yellow paper written by Gavin Wood proposed the model of EVM, created the concept of EVM virtual machine, and drafted the OP_CODE of EVM. After that, Solidity was designed to be compiled to OP_CODE, and then the entire ecology of Ethereum was created. It is equivalent to Ethereum's contract sandbox model for processing blockchain, building all facilities from zero to one. Therefore, the syntax of Solidity and the things that EVM can do are very simple compared to the current blockchain, such as syntax of solidity and stack depth limit of EVM. However, as a pioneer, it created a blockchain contract virtual machine model.</p>
</li>
<li>
<p>Fabric</p>
<p>As a consortium chain, Fabric is different from the public chain in usage scenarios. Fabric puts forward the concept of chain code and runs the chain code in docker. Docker is a heavier type of virtual machine compared to EVM. Fabric's chain code can do more than Solidity, but its running cost is higher than EVM.</p>
</li>
<li>
<p>EOS</p>
<p>EOS adopts Wasm as the virtual machine of the contract, which is also the selling point of EOS at that time. Compared to running Solidity's EVM, EOS's Wasm virtual machine has a much higher operating efficiency. Using C++ as a language compiled to Wasm has naturally attracted many traditional developers. EOS, as the forerunner of Wasm virtual machine, has already demonstrated the advantages of Wasm over EVM at that time. However, in addition to constraints of the environment, EOS has defects in the contract model design (see the next chapter for details) and is not really a centralized system. Therefore, EOS does not give full play to the capabilities of the Wasm contract system.</p>
</li>
<li>
<p>Substrate's <code>pallet-contracts</code></p>
<p><code>pallet-contracts</code> uses the Wasm virtual machine to run the contract. Currently, for security reasons, only the Wasmi interpreter is used to execute Wasm. But its contract model is similar to the EVM contract model (see the next chapter for details). Like EVM, Wasm virtual machine has features of fast start-up and hand-to-mouth discard. In addition, Wasm has high performance and high scalability while not being too large like docker and JVM. Therefore, Wasm is slowly being adopted in more scenarios besides the browser environment, such as edge computing, hot updates, and so on. Therefore, more and more new blockchains will use the Wasm virtual machine as the main solution when they need a sandbox environment. On the other hand, Wasm also has the feature of compiling from different languages to Wasm, such as rust, assemblyscript, and c++. This feature can attract all kinds of developers to join the contract development process.</p>
</li>
<li>
<p>Other blockchains</p>
<p>Other blockchains will have their own solutions to accomplish this sandbox goal. Some alliance chains use tailored JVMs, some public chains use RISC-V virtual machines, and some chains use slaves. Zero design a virtual machine (such as libra). These solutions have their own requirements and characteristics, but from the perspective of the model, no matter what the solution, the ultimate goal is to provide a virtual machine environment to run the contract sandbox.</p>
</li>
</ul>
<h2><a class="header" href="#sandbox-for-running-contracts" id="sandbox-for-running-contracts">Sandbox for running contracts</a></h2>
<p>Most of the business logic of the chain described above will run in the sandbox system, and the business logic of running contract needs sandbox isolation. On the other hand, Substrate's runtime is a sandbox environment (running in Wasm), so in Substrate's contract modules (<code>pallet-emv</code>, <code>pallet-contracts</code>), it is necessary to run another sandbox in a sandbox environment, as illustrated in the following figure:</p>
<p><img src="contracts/./imgs/overview_module.jpg" alt="overview" /></p>
<p>Where,</p>
<ul>
<li>On the left is the Ethereum model, which means that every time a contract is run, an EVM virtual machine needs to be started on the chain platform to run</li>
<li>On the right is the Substrate model. We currently know that the business logic of the Substrate chain is running in the Wasm virtual machine:
<ul>
<li><code>pallet-EVM</code>: The EVM of Ethereum is compiled into Runtime Wasm, so every contract that runs is actually consistent with Ethereum, and an EVM virtual machine is created to run. If the chain is running in Wasm form, an EVM virtual machine is generated in the Wasm virtual machine to run.</li>
<li><code>pallet-contracts</code>: Wasm contracts use Wasm virtual machine to run contracts. The difference from pallet-evm is that if the chain is running in Wasm form, the virtual machine of Wasm contract jumps out of the current Runtime Wasm virtual machine to create a new Wasm. The virtual machine is running.
<ul>
<li>Currently (<a href="https://github.com/paritytech/substrate/commit/0b0d124d5f9be89f614f2be8e9da038fcb9f540e">0b0d124d</a> before the submission of substrate) <code>Wasmtime</code> is recommended for Runtime's Wasm virtual machine, while <code>pallet-contracts</code> contracts can only use <code>wasmi</code>.</li>
<li><code>pallet-contracts</code> can also be executed using <code>Wasmtime</code>, but currently parity believes that <code>Wasmtime</code> is relatively uncontrollable, so <code>Wasmtime</code> has not been adopted yet. Currently they have related plans and prototype code to use Wasmtime to run <code>pallet-contracts</code> contracts.</li>
</ul>
</li>
</ul>
</li>
<li>In short, in the process of running the contract, most chains adopt a sandbox model to run the contract. For the EVM, pallet-contracts model, a virtual machine is created every time a contract is run.</li>
</ul>
<h2><a class="header" href="#notes" id="notes">Notes:</a></h2>
<ol>
<li><code>Wasmtime</code> is a Wasm virtual machine that implements JIT, and <code>wasmi</code> is a pure interpreter-type Wasm virtual machine.</li>
<li>The execution efficiency of Wasmtime is much higher than <code>wasmi</code>.</li>
</ol>
<h1><a class="header" href="#contract-model" id="contract-model">Contract model</a></h1>
<p>After we have the concept of contracts and contract sandboxes, we can begin to discuss the concept of contract models.</p>
<p>The contract sandbox only represents the environment in which the contract is run, and how the contract is run, how the contract interacts with the contract, and how the contract interacts with the data of the chain. These problems belong to the contract model problem.</p>
<p>In other words, the <strong>contract model is the model in which the contract runs in the contract sandbox/virtual machine</strong>.</p>
<p><img src="contracts/./imgs/model.jpg" alt="" /></p>
<p>As shown in the figure, the contract model and the contract virtual machine can be decoupled in nature. The only relationship is whether the contract virtual machine can support the contract model required by the upper layer, for example:</p>
<ul>
<li>Bitcoin's virtual machine is the stack executor of Bitcoin scripts. Since the executor design is a non-Turing complete OP_CODE, the upper-level contract model can only support Bitcoin scripts.</li>
<li>Ethereum follows the inspiration of Bitcoin and designed OP_CODE with Turing completeness, namely EVM Virtual Machine (Ethereum Virtual Machine). But the OP_CODE of EVM is relatively simple, and only has a stack design, without the concept of a heap. But EVM introduces the OP_CODE of read and write state, so the contract model can support the state model from the virtual machine mechanism. Therefore, the EVM is also regarded as a state transition machine that performs state transitions (as described in the Ethereum Yellow Paper written by Gavin Wood). The state model is actually a relatively general abstract model. Most models can be simulated with the state model (such as building a UTXO model in the state model). Therefore, theoretically, as long as you continue to improve the OP_CODE of the EVM, the upper layer of the EVM can also be used. Construct other contract models.</li>
<li>libra believes that the core of the blockchain lies in the processing of assets, so it proposes the Move Virtual Machine (MVM) model to limit the contract model from the virtual machine, which can be understood as a specialized logic OP_CODE collection. Therefore, the upper layer of MVM can only run the Move model.</li>
</ul>
<p>Through the above discussion, we can recognize the concept of the contract model and understand the limitations of the virtual machine on the upper-level contract model. Therefore, we can discuss the contract model that the Wasm virtual machine can run and the contract model composition of <code>pallet-contracts</code>.</p>
<h2><a class="header" href="#wasm-virtual-machine" id="wasm-virtual-machine">Wasm Virtual Machine</a></h2>
<p>Wasm is a binary instruction format that runs on a stack-based virtual machine. (WebAssembly (abbreviated Wasm) is a binary instruction format for a stack-based virtual machine, from <a href="https://webassembly.org/">https://webassembly.org/</a>) So Wasm’s model and mainstream computer program The model structure is relatively similar. On the other hand, Wasm is designed to be a more general form, and WASI is designed and supports the free definition of <code>host function</code> in the operating environment. Therefore, although Wasm is developed from the browser, the current usage scenarios are not limited to browsing. It is beginning to take effect on edge computing, hot updates, and serverless platforms.</p>
<p>If the ability of a virtual machine is measured by the completeness of instructions, the EVM is at the level of a semi-finished product, which has many restrictions and is not flexible enough; while the JVM and Wasm virtual machines are relatively complete with few restrictions and strong functionality. On the other hand, the rationality of the instruction design will also affect the execution efficiency of the virtual machine to a certain extent, and the implementation scheme adopted by the virtual machine will also have a relatively large impact on the execution efficiency.</p>
<p>For example, EVM currently can only run in the form of an interpreter, and there is no optimization for the interpreter in the current implementation process body (go, c++, etc.), and the execution efficiency is relatively low, while virtual machines such as JVM and Wasm There are implementations using JIT mode, and the execution efficiency is quite high and even close to the performance of local execution.</p>
<blockquote>
<p>Note: <code>pallet-contracts</code> currently can only use <code>wasmi</code> (interpreter) to execute Wasm code, so the execution performance of the contract is not as good as that of Runtime using <code>wasmtime</code>.</p>
</blockquote>
<p>At the same time, compared to virtual machines such as JVM, the Wasm virtual machine is very lightweight (lightweight), fast, and highly customizable. ** And the function of <code>host function</code> gives the Wasm virtual machine a channel for interaction with the host** Therefore, compared with other virtual machines, it is easier to combine the Wasm virtual machine as a blockchain contract sandbox with the functions of the chain.</p>
<p>On the other hand, in the author's opinion, Wasm is a better abstraction layer between the bottom code and the upper code, and its complexity and completeness are far beyond EVM, so it is more suitable for the needs of the blockchain contract field.</p>
<p>Therefore, the sandbox environment provided by the Wasm virtual machine meets the following two requirements on the premise that the contract sandbox is satisfied:</p>
<ul>
<li>Complete instructions, rich functionality, and high execution efficiency</li>
<li>There is a suitable interface that can interact with the host (here refers to the environment in which Wasm is running, that is, the chain), so that the host can provide the required functions.</li>
</ul>
<h2><a class="header" href="#evm-contract-model" id="evm-contract-model">EVM contract model</a></h2>
<p>Since Ethereum is a blockchain that stores state, the contract model of EVM needs basic read and write state functions as it should. If the process of each contract operation is regarded as a process from the start of the program to the end of its execution, then the changes in the state data correspond to the changes in the data that the program needs to persist.</p>
<p>Therefore, for the read and write status, Ethereum's EVM provides two instructions, <code>SLOAD</code> and <code>SSTORE</code>.</p>
<p>On the other hand, Ethereum describes an account using the &quot;account model&quot;, that is, the contract and the user calling the contract are regarded as an account. Under this account, there are concepts such as <code>balance</code>, so EVM provides <code>CALLER</code>, <code>ORIGIN </code>, <code>CALLVALUE</code> and a series of instructions to describe this model.</p>
<p>At the same time, because in the abstract system of EVM, the contract and the user are considered to be consistent, the model of &quot;contract call contract&quot; appears, namely <code>CALL</code>, <code>DELEGATECALL</code> and other instructions, which brings the composability of the contract. Created a prosperous Ethereum ecosystem. In EVM, a contract relies on one EVM to run, so the contract calling contract starts another EVM in one EVM and loads instructions for execution.</p>
<p>Of course, the original intention of the EVM virtual machine design is to solve the problem of non-Turing completeness of the Bitcoin script. In order to solve this problem and ensure that the downtime problem does not occur, the instruction Gas billing model is introduced.</p>
<p>Therefore, in summary, the EVM contract model has the following characteristics:</p>
<ol>
<li>The data processing model is a state machine model, and state changes are triggered by external calls (analogous to the process of calling a state change function);</li>
<li>The contract model requires chain-related features;</li>
<li>Treat the contract as consistent with the user and allow the contract to call the contract;</li>
<li>Introduce an instruction billing model.</li>
</ol>
<h2><a class="header" href="#the-contract-model-of-pallet-contracts" id="the-contract-model-of-pallet-contracts">The contract model of <code>pallet-contracts</code></a></h2>
<p>Here is a direct conclusion: <strong><code>pallet-contracts</code> uses the Wasm virtual machine to execute code, but its contract model is basically the same as the EVM contract model</strong>.</p>
<p>In other words, the contract model of <code>pallet-contracts</code> also has the following 4 characteristics:</p>
<ol>
<li>The data processing model is the state machine model;</li>
<li>The contract model requires chain-related features;</li>
<li>Treat the contract as consistent with the user and allow the contract to call the contract;</li>
<li>Introduce an instruction billing model.</li>
</ol>
<p>And, on the basis of the above 4 characteristics, a &quot;storage leasing model&quot; has been added:</p>
<ul>
<li><code>Rent</code> storage lease billing.</li>
</ul>
<p>As mentioned above, the contract execution environment and contract model can be decoupled. Since the EVM was designed relatively early, there is no concept of decoupling this level, so the instructions in the instructions are <code>SLOAD</code>, <code>SSTORE</code> and similar. The instructions are combined with other instructions of the EVM. And Wasm was not originally designed for the blockchain, so there must be no instructions related to the chain environment.</p>
<p>So Wasm's <code>host function</code> is used to accomplish this. As the host of the host, the chain only needs to provide the methods that he thinks the contract may use to the Wasm virtual machine, and let him import these function objects, which can be used during the execution of the contract. Therefore, through the <code>host function</code>, the <code>pallet-contracts</code> contract module can have 1, 2, and 4 functions, and will provide some of the functions required by 3, and the fifth feature (rental billing) can also be introduced.</p>
<p>And the implementation of the third function is also consistent with EVM. When there is a part of the contract calling the contract, it returns to the <code>pallet-contracts</code> module from Wasm through the <code>host function</code>, and starts a new Wasm virtual machine to execute The contract being called. (This part will be described in a future article)</p>
<p>So in summary, the contract model of <code>pallet-contracts</code> has the following characteristics:</p>
<ol>
<li>The contract model is consistent with the EVM contract model, and a storage billing model is added on this basis</li>
<li>The interaction with the chain is realized through the <code>host function</code> feature of Wasm</li>
</ol>
<h2><a class="header" href="#use-wasm-virtual-machine-to-implement-other-contract-models" id="use-wasm-virtual-machine-to-implement-other-contract-models">Use Wasm virtual machine to implement other contract models</a></h2>
<p>I just briefly described how <code>pallet-contracts</code> implements the contract model on the Wasm virtual machine. Since the previous article has explained that the virtual machine and the contract model can be decoupled, in fact, other things can also be implemented on the Wasm virtual machine. Contract model.</p>
<p>For example, we can consider porting the Move virtual machine to the Wasm virtual machine. There are two possible implementations:</p>
<ol>
<li>
<p>Analogous to running the EVM implementation in the Runtime Wasm environment, the MVM implementation can also be compiled into the form of Wasm (for example, named <code>pallet-mvm</code>) and run in the Runtime Wasm.</p>
<p>Based on this implementation, Move can still be compiled in the normal way, and it is consistent with the compilation result of Solidity running on <code>pallet-evm</code>, and the result of Move compilation is run on a platform such as <code>pallet-mvm</code>.</p>
</li>
<li>
<p>Abstract the MVM, ownership, and chain-related features into a form of <code>pallet-contracts</code>, and design to compile the intermediate code IR compiled by the Move language to Wasm.</p>
<p>Based on this realization, Move can be compiled into Wasm and run in the Wasm virtual machine.</p>
</li>
</ol>
<h2><a class="header" href="#other-contract-models" id="other-contract-models">Other contract models</a></h2>
<h3><a class="header" href="#eos-contract-model" id="eos-contract-model">EOS contract model</a></h3>
<p>EOS's contract model is similar to EVM, while strengthening the concept of account model. Therefore, the way EOS uses Wasm is also based on the execution of Wasm, and introduces chain-related functions through <code>host function</code>.</p>
<p>The main difference between the EOS and EVM models is that the EOS contract calls the contract in the form of a transaction, and the EOS resource model is a mortgage model. At present, it is generally believed that it is the EOS mortgage model that ultimately led to EOS not succeeding.</p>
<h3><a class="header" href="#asynchronous-contract-model" id="asynchronous-contract-model">Asynchronous contract model</a></h3>
<p>The <code>pallet-actor</code> is the beginning of Substrate's attempt to implement the asynchronous contract model, and there is currently no progress. The model of <code>pallet-actor</code> intends to use the Wasm virtual machine as the operating environment, and on this basis add asynchronous functions to improve performance.</p>
<p>There are also a few other studies on asynchronous contract models, but they are all in a relatively preliminary stage.</p>
<h1><a class="header" href="#contract-language-framework" id="contract-language-framework">Contract language (framework)</a></h1>
<p>Corresponding to the concept of &quot;contract model&quot; (operating platform), we can derive the concept of contract language (framework) (writing code that can run on the platform).</p>
<p>Instead of simply using &quot;contract language&quot;, we use words like &quot;contract language (framework)&quot; because we have separated the &quot;contract sandbox&quot; and &quot;contract model&quot; in the previous chapter. Structure level, so in fact, some new contract platforms did not &quot;invent&quot; a new Solidity contract language like EVM, but chose some languages ​​(such as Rust, C++, AssemblyScript, etc.) based on this language. &quot;hack syntax analysis&quot;, &quot;macro&quot;, and other dimensions add contract-related constraints and functional logic to existing languages. Therefore, in many cases, it will exist in the form of &quot;frame&quot;, &quot;library&quot;, etc. (such as Frame Contract Pallet's rust contract language framework ink!). And this &quot;framework/library&quot; is not the dimension of libraries used in usual program development. Some contract language frameworks need to be modified to the compiler dimension, so we prefer to call them &quot;language frameworks&quot;.</p>
<h2><a class="header" href="#correspondence-between-contract-language-framework-and-contract-model" id="correspondence-between-contract-language-framework-and-contract-model">Correspondence between contract language (framework) and contract model</a></h2>
<p><img src="contracts/./imgs/language_1.jpg" alt="language 1" /></p>
<p>As shown in the figure above, the upper part is the relationship between EVM and Solidity. Since EVM/Solidity was proposed earlier, its model is consistent with the usual model relationship between computer virtual machines and languages. The lower part is the correspondence between the language framework part after separating the contract model.</p>
<p>Here we will focus on the second half. The readers of the first half can analyze according to their own experience in Ethereum contract development compared with the introduction in the following text.</p>
<p>In the system of compiled language, first simply define the following nouns (not rigorously speaking, defined only for the following introduction):</p>
<ul>
<li>S language: the original language (source) for programmers to write code, for example, to compile C++ into assembly, then C++ is the original language S</li>
<li>T language: The language (target) produced after S language is compiled by a compiler, for example, if C++ is compiled into assembly, then assembly is the target language T</li>
</ul>
<p>The previous article has introduced that the environment for running the contract system can be logically split into a &quot;contract model&quot; and a &quot;contract virtual machine&quot;. The former manages the business logic of the contract, and the latter manages how to run the code of the contract, so the corresponding contract language The part can also be disassembled into &quot;contract language framework&quot; and &quot;S language compiled into contract virtual machine&quot;.</p>
<p>According to this definition, it is clear that Solidity is a product that has the characteristics of both &quot;contract language framework&quot; and &quot;S language&quot;:</p>
<ol>
<li>
<p>Solidity has a Turing complete language system, so Solidity is a &quot;language&quot; (relative to the BTC script)</p>
</li>
<li>
<p>The grammar of Solidity has many keywords with contract characteristics, corresponding to the concept of &quot;contract language framework&quot;, such as:</p>
<ul>
<li><code>mapping</code>: A typical case of contract storage</li>
<li><code>msg.sender</code>, <code>msg.value</code>: variables related to contract calls</li>
<li><code>view</code>, <code>pure</code> and other modifiers</li>
<li><code>call</code>, <code>delegate_call</code> and other keywords related to contract calls</li>
</ul>
<p>These concepts do not exist to support the logic of the Solidity language, but to serve the business logic of the Ethereum contract virtual machine.</p>
</li>
</ol>
<p>The purpose of the &quot;contract language framework&quot; is to correspond to the business logic of the contract model. What kind of contract model requires what kind of contract language framework. For example, the bottom layer of EVM is k/v type storage, so the <code>mapping</code> designed in Solidity cannot be traversed (unless extra storage is attached). For example, the contract model of EVM contract interaction is designed as a contract calling contract mode, so Solidity provides <code>call</code> and <code>delegate_call</code>. <strong>The same applies to other contract systems</strong>.</p>
<p>On the other hand, the contract language framework is an additional function built on the S language, so the functions provided by the contract language framework are ultimately compiled to the T language corresponding to the S language. Some of the features required by the blockchain, such as deterministic requirements, not allowed to use the interface called by the operating system, etc., will be <strong>constrained</strong> at this level. Therefore, the contract language framework not only provides the function of the contract model for the S language itself, but also needs to impose certain constraints on the language itself. This step is also a difficult place to develop and understand the contract language framework. At the same time, it is precisely because of this point that causes many awkward situations in the process of contract developers using the contract model framework. Languages ​​such as Solidity or Move are new languages ​​developed for contract platforms. Even though their grammar will have many traces of simulating other languages, they can be more friendly to contract developers in terms of constraints. However, it is difficult to deal with the contract language that adds the contract language framework function to the existing language, and this is one of the reasons why it is difficult for contract developers to use the framework function.</p>
<p>Take ink! for example:</p>
<ol>
<li>
<p>Float should be avoided in the blockchain, because floating-point numbers may produce non-deterministic behavior. Therefore, in contract/runtime development, if you need to use floating-point numbers, or multiply and divide overflow numbers, you need to introduce fixed-point numbers for processing. Therefore, the fixed-point library provided by Substrate runtime can be introduced into the ink! contract for processing.</p>
</li>
<li>
<p>Since the contract model of <code>pallet-contracts</code> is basically the same as EVM, the contract storage of <code>pallet-contracts</code> is also composed of K/V. Then the contract model framework needs to deal with the various collection types provided in the standard library. Therefore, the collection types that may be used in the standard library are rewritten in <strong>ink!</strong>, and the process of processing the collection element types into K/V data is added. Therefore, in the ink! contract storage, if a collection type is designed, only the types provided in the ink! standard library can be used. On the other hand, since the return value of ink! needs to export metadata for third-party processing, and the current metadata interface implementation is only implemented for the collection in the standard library, so the collection of the return value of the ink! method can only use the collection of the standard library. Types of. So the following code will appear:</p>
<pre><code class="language-rust ignore">#[ink::contract]
mod test {
    // Introduce Vec realized by ink
    use ink_storage::collections::Vec as StorageVec;
    // Introduce the Vec of the standard library
    use ink_prelude::vec::Vec;
    #[ink(storage)]
    pub struct Test {
        owners: StorageVec&lt;AccountId&gt;, // Only ink's Vec can be used
    }
    impl Test {
        #[ink(message)]
        pub fn get_owners(&amp;self) -&gt; Vec&lt;AccountId&gt; {
            // Convert Vec implemented by ink to Vec implemented by standard library
            self.owners.iter().map(Clone::clone).collect()
        }
    }
}
</code></pre>
</li>
</ol>
<p>So in summary, in the model structure, developers need to understand:</p>
<ul>
<li>The contract language framework corresponds to the contract model, and the characteristics of the language framework will match the model one by one;</li>
<li>The contract language framework provides the S language with business functions for the contract model, and it also restricts the S language itself according to the requirements of the contract business logic.</li>
</ul>
<p>However, because Solidity itself is positioned as a language designed for writing contracts, many contract-related functions can be designed as keywords. And if a language itself is not designed for contracts, it is necessary to design a &quot;contract language framework&quot; corresponding to the contract model based on this contract. Since new functions are added to this language, it is generally difficult to integrate with the language itself in depth. Therefore, the final result is related to the ability of this language to <strong>expand the syntax tree</strong>. The language itself provides more flexible interfaces (macros, plug-ins, etc.) for modifying/adding the syntax tree, the more functions the contract language framework can achieve. The less the language itself provides such extensibility functions, the contract language framework can only consider modifying the compiler and extending the required grammar to support the contract model, so that the final language becomes a &quot;dialect&quot; of the original language. Up. Therefore, the former can exist in the form of a library/framework, while the latter becomes a new language. <strong>This is why we call this model the &quot;contract language framework&quot;</strong>.</p>
<h2><a class="header" href="#pallet-contracts-and-the-corresponding-contract-language-framework" id="pallet-contracts-and-the-corresponding-contract-language-framework"><code>pallet-contracts</code> and the corresponding contract language framework</a></h2>
<p><img src="contracts/./imgs/language_2.jpg" alt="language 2" /></p>
<p>After explaining the contract language framework model above, we can apply the contract model framework to Substrate's Wasm contract system.</p>
<p>Obviously, the realization of the ink! system corresponds to the contract model of pallet-contracts. ink! 3.0 introduces the functional logic corresponding to <code>pallet-contracts</code> into rust through the system of process macros (2.0 through god declaration macros). Therefore, the S language in this system is rust, and the T language is Wasm bytecode. With the help of an auxiliary tool <code>cargo-contract</code>, the rust code using the ink! framework is compiled into the Wasm bytecode of the contract. The environment in which Wasm bytecode runs on the chain is wasmi (Wasmtime and other JIT execution environments will also be introduced in the future).</p>
<p>And because the execution environment of <code>pallet-contracts</code> is Wasm bytecode, the language that can be compiled into Wasm bytecode is matched with a contract language framework that conforms to the <code>pallet-contracts</code> contract model, and it can be generated that can run on <code>pallet. -contracts</code> The contracts on this contract platform. So for <code>pallet-contracts</code>, it is completely possible to design contract systems in different languages ​​to provide multiple options for development and use different languages ​​to develop Wasm contracts.</p>
<p>In addition to rust's ink!, the contract language framework that currently supports running on <code>pallet-contracts</code> also has the following items:</p>
<ul>
<li>Ask!, developed by Patract, is a contract language framework based on the AssemblyScript language. (Currently under development)</li>
<li>Solang, developed by hyperledger-labs, supports to compile Solidity to Wasm tool of <code>pallet-contracts</code>.</li>
</ul>
<h1><a class="header" href="#brief-introduction-of-wasm" id="brief-introduction-of-wasm">Brief introduction of Wasm</a></h1>
<h2><a class="header" href="#the-association-between-wasm-and-contract-model" id="the-association-between-wasm-and-contract-model">The association between Wasm and contract model</a></h2>
<p><img src="contracts/./imgs/wasm.jpg" alt="" /></p>
<h1><a class="header" href="#pallet-contracts-合约模块" id="pallet-contracts-合约模块">pallet-contracts 合约模块</a></h1>
<p><code>pallet-contracts</code>合约模块, 一般称呼为<a href="https://substrate.dev/docs/en/knowledgebase/smart-contracts/contracts-pallet">“Contracts Pallet”</a> 或者 “FRAME Contracts pallet”，又或者称呼为“Substrate Smart Contracts”，是parity官方研发的Wasm合约模块。</p>
<p>依据Substrate knowledgebase的介绍，Contracts Pallet具备如下特性：</p>
<ul>
<li>Are inherently safer to the network.</li>
<li>Have built in economic incentives against abuse.</li>
<li>Have computational overhead to support graceful failures in logic.</li>
<li>Have a lower bar to entry for development.</li>
<li>Enable fast pace community interaction through a playground to write new logic.</li>
</ul>
<h1><a class="header" href="#ink" id="ink">ink</a></h1>
<p>ink! is an eDSL to write WebAssembly based smart contracts using the Rust programming language. The compilation target are blockchains built on the Substrate framework.</p>
<p>Although ink! claims to be a kind of eDSL for writing contracts, I prefer to think that ink! is a contract framework written in Rust language that meets the requirements of Contracts Pallet.</p>
<p>For example, for EVM, if the instruction set of the EVM is regarded as a specification (the instruction set of the EVM already contains the information of the EVM contract model), then as long as the language can be compiled into the instruction set of the EVM, it can be said to be able to run on the EVM Contract language on the Internet, for example:</p>
<ul>
<li>Solidity</li>
<li>Vyper</li>
</ul>
<p>And ink! Same here. Contracts Pallet requires Wasm code that can run the Contracts Pallet contract model, so any framework/language/library that can be compiled to meet this Wasm contract model can be called Contracts Pallet's contract language.</p>
<p>ink! is to use the Rust language, and on this basis, design a set of eDSL through Rust's <strong>hygienic macro system</strong>, and use this eDSL to write Rust code that meets the requirements of Contracts Pallet. In addition to eDSL, ink! also provides a <strong>storage collection type</strong> suitable for contract models, generating Metadata (corresponding to Solidity's ABI) and other tool libraries.</p>
<p>See the official documentation of ink!:</p>
<ul>
<li><a href="https://substrate.dev/docs/en/knowledgebase/smart-contracts/ink-fundamentals">ink! Concepts</a></li>
<li><a href="https://substrate.dev/substrate-contracts-workshop/#/">ink! Smart Contracts Tutorial</a></li>
<li><a href="https://paritytech.github.io/ink-docs/">ink! Documentation Portal</a></li>
</ul>
<h2><a class="header" href="#ink-the-process-to-the-contracts-pallet" id="ink-the-process-to-the-contracts-pallet">ink! The process to the Contracts pallet</a></h2>
<p>An example image is provided in the official parity document:
<img src="https://paritytech.github.io/ink-docs/img/how-it-works.svg" alt="https://paritytech.github.io/ink-docs/how-it-works" /></p>
<p>From this figure, we can see that the process of writing and deploying the ink! contract requires</p>
<ul>
<li>ink! dependent library: provide ink! eDSL framework and provide corresponding dependent components</li>
<li>cargo-contract: tool for compiling ink! contract</li>
<li>SDK: SDK that interacts with the chain and deploys the contract to the chain. The official parity mainly provides <code>polkadot.js</code>, and Patract provides the Himalia toolkit, including <code>go</code>, <code>java</code>, <code>python</code>, <code>C#</code> SDK</li>
</ul>
<p>This chapter will mainly introduce ink! and <code>cargo-contract</code> information, and the information about SDK will be introduced in the following chapters.</p>
<h1><a class="header" href="#ink-tutorial" id="ink-tutorial">ink! tutorial</a></h1>
<p>TODO</p>
<h1><a class="header" href="#ink-framework" id="ink-framework">ink! Framework</a></h1>
<p>All the main functions of ink! are implemented in the <a href="https://github.com/paritytech/ink/tree/master/crates"><code>ink/crates</code></a> directory:</p>
<ul>
<li>crates:
<ul>
<li>allocator: related to Wasm, define allocator, developers do not need to care in most cases</li>
<li>env: Provides components that interact with the chain. In summary, the parts related to the chain will be placed here, including
<ul>
<li>host function part</li>
<li>Some types and trait definitions that need to be imported</li>
<li>topic of event</li>
</ul>
</li>
<li>lang: The definition component of the eDSL process macro, the contract specification is determined by this place</li>
<li>metadata: components that generate metadata</li>
<li>prelude: A package that needs to be imported in advance during the contract writing process, including some standard libraries</li>
<li>primitives: pointers to operating state storage, developers do not need to care in most cases</li>
<li>storage: provide chain storage allocation model and provide some predefined storage collection types</li>
</ul>
</li>
</ul>
<h1><a class="header" href="#ink-edsl-basic-elements" id="ink-edsl-basic-elements">ink! eDSL basic elements</a></h1>
<p>The elements of ink! eDSL design are actually relatively similar to those of Solidity, because the contract model structure of Contracts Pallet and the contract model of EVM are relatively similar.</p>
<p>Therefore, the design of ink! can find a lot of shadows similar to Solidity (the same applies to the Runtime design of Substrate). When describing the ink characteristics later, I will try to compare with the characteristics of Solidity, which is convenient for readers to understand.</p>
<h2><a class="header" href="#elements-of-edsl" id="elements-of-edsl">Elements of eDSL</a></h2>
<p>From the example provided by ink! documentation or ink!, the code shows that ink! also proposes the following three basic elements on the Contracts Pallet model:</p>
<ul>
<li><code>constructor</code>/<code>message</code></li>
<li><code>storage</code></li>
<li><code>event</code></li>
</ul>
<p>However, due to the design relationship of the Rust process macro, you can see that ink! First requires a contract to be under a <code>mod</code>, and add the <code>#[ink::contract]</code> macro to this <code>mod</code>:</p>
<pre><code class="language-rust ignore">#[ink::contract]
mod erc20 {
    // ...
}
</code></pre>
<p>In this way, it is equivalent to telling ink! What is in this mod is to be processed according to the eDSL of ink.</p>
<h3><a class="header" href="#inkcontract" id="inkcontract"><code>#[ink::contract]</code></a></h3>
<p>Therefore, when you encounter the macro <code>#[ink::contract]</code>, it appears that this is the &quot;contract part&quot; identified by ink!. Therefore, we can see that many imports of <code>use xxx</code> will be placed under the scope of <code>mod</code> in <code>#[ink::contract]</code>.</p>
<p>And the current ink! design is that, under a <code>crate</code> package, only one <code>#[ink::contract]</code> can appear, so it means that ink! thinks that the dimension of a contract is based on rust's <code>crate</code>, that is If in the same <code>crate</code>, whether in the same file (for example, under <code>lib.rs</code>) or in different files, more than two are defined by <code>#[ink::contract]</code> The <code>mod</code>, for example:</p>
<pre><code class="language-rust ignore">#[ink::contract]
mod erc20 {
    // ...
}

#[ink::contract]
mod another_define {
    // ...
}
</code></pre>
<p>Analogous to solidity:</p>
<pre><code class="language-solidity ignore">// a.sol defines multiple `contract` in the same file
contract A {

}
contract B {

}
</code></pre>
<p>Then in the compilation of ink!, this situation will be considered illegal.</p>
<p>Of course, as opposed to this, as long as there is only one <code>mod</code> modified by <code>#[ink::contract]</code> in the current <code>crate</code>, other <code>mod</code>s should be used normally, so the contract modified by ink! <code>crate</code> can still do a good job of code isolation, enhance readability and maintainability**. This ability is important for <strong>maintaining large and complex contracts</strong>, such as:</p>
<pre><code class="language-rust ignore">#[ink::contract]
mod erc20 {
    use crete::another_define::*;
}

mod another_define {
    // ...
}
</code></pre>
<p>For example, the following example:</p>
<pre><code class="language-rust ignore">mod fxck {
    use crate::erc20::Erc20;
    use ::ink_lang::Env; // Note that `ink_lang::Env` needs to be introduced here
    impl Erc20 {
        pub fn tmp(&amp;self) {
            self.env().caller(); // 
        }
    }
}

#[ink::contract]
mod erc20 {
    #[ink(storage)]
    pub struct Erc20 {...}

    impl Erc20 {
        #[ink(constructor)]
        pub fn new(initial_supply: Balance) -&gt; Self {...}
        #[ink(message)]
        pub fn transfer(&amp;mut self, initial_supply: Balance) -&gt; Self {
            self.tmp(); // call methods defined in other `mod`
        }
    }
}
</code></pre>
<p>This model can achieve some code isolation that cannot be done under Solidity, and enhance maintainability. (Because Solidity's library can only be used for pure function calculations)</p>
<p>In summary, under the ink! system:</p>
<ul>
<li>A contract is in a <code>crate</code> unit, and only one <code>#[ink::contract]</code> definition can appear in a <code>crate</code>;</li>
<li><code>#[ink::contract]</code> modified <code>mod</code> represents the content of the contract, and also represents <strong>the basic elements of the contract must be defined under this <code>mod</code></strong>;</li>
<li>All parts other than <code>mod</code> modified by <code>#[ink::contract]</code> (other <code>mod</code>, functions, types) follow the rules of rust, and good code isolation can be done to improve maintainability;</li>
<li>In practice, the <code>mod</code> modified by <code>#[ink::contract]</code> can be used as the entry point of the contract, and the implemented logic can be distributed to other <code>mod</code>s.</li>
</ul>
<p>The following uses &quot;contract mod&quot; to indicate a <code>mod</code> modified by <code>#[ink::contract]</code></p>
<h3><a class="header" href="#storage" id="storage"><code>storage</code></a></h3>
<p>In the contract mod, a structure must be defined, and this structure is modified by <code>#[ink(storage)]</code>, indicating that the storage of the contract is defined.</p>
<p>At the same time, this structure definition modified by <code>#[ink(storage)]</code> is also regarded as an operable contract entity**, so all contract-related resources, types, and operations will be ** and this structure The body is bound together**. When the contract calls the contract, the type of the called contract is also represented by this structure.</p>
<p>Therefore, this structure can be understood as a contract entity.</p>
<blockquote>
<p>Although the part that modifies <code>mod</code> is the contract, because <code>mod</code> can only represent the scope in rust, so for practical use, use the structure modified by <code>#[ink(storage)]</code> to indicate that it can be operated Contract entity.</p>
<p>In this context, the <code>mod</code> modified by <code>#[ink::contract]</code> can be understood as the concept of &quot;opening the contract domain&quot;, while the <code>stuct</code> modified by <code>#[ink(storage)]</code> It is a contract under this contract domain.</p>
</blockquote>
<p>Here, the concept of storage defined by ink! is consistent with the concept of “storage” defined in Solidity, which means that the attributes defined here are the final state written to the <strong>chain</strong>. The purpose of writing all contract logic is to modify the state defined here.</p>
<p>However, because the current ink! uses a structure to carry the contract state, all the states of the current contract can only be defined in this structure. When the contract is designed to be relatively large and complicated, the maintainability here will decrease.</p>
<p>An example of defining storage is as follows:</p>
<pre><code class="language-rust ignore">#[ink(storage)]
pub struct Erc20 {
    /// Total token supply.
    total_supply: Lazy&lt;Balance&gt;,
    /// Mapping from owner to number of owned token.
    balances: StorageHashMap&lt;AccountId, Balance&gt;,
    /// Mapping of the token amount which an account is allowed to withdraw
    /// from another account.
    allowances: StorageHashMap&lt;(AccountId, AccountId), Balance&gt;,
}
</code></pre>
<p>Structures modified by <code>#[ink(storage)]</code> are collectively referred to as contract structures in the following text.</p>
<p>Here are a few features that need to be paid special attention to:</p>
<ol>
<li>
<p>The type of the attribute defined in the contract structure must be a type that has implemented <code>SpreadLayout</code> (or more accurately, a type that implements <code>PackedLayout</code>, because <code>PackedLayout</code> is inherited from the definition of <code>SpreadLayout</code>):</p>
<pre><code class="language-rust ignore">/// Types that can be stored to and loaded from the contract storage.
pub trait SpreadLayout {
}
</code></pre>
<blockquote>
<p>The reason why only the type that implements this trait can be used here is very simple, because storage is different from the general type, it must contain the information of the &quot;chain&quot; in it, so the contract implementation of different chains must have a part for processing The storage (that is, state) allocation problem in the contract.</p>
<p>For example, during the compilation process of Solidity, the key of the state is actually assigned according to the upper and lower order defined by the storage in the contract. If the <code>SpredLayout</code> or <code>PackedLayout</code> type has been implemented here, there will be an approximate process for state allocation.</p>
</blockquote>
<p>Ink! has done basic implementations for general types, but <strong>for collection types (<code>Vec</code>, <code>HashMap</code>, etc.), because the state of the contract needs to hook the process of reading and writing</strong>, it cannot be implemented for collection types This <code>trait</code>. Therefore, in ink!, all the commonly used collection types in the standard library have been re-implemented, and the attribute types of the structure modified by <code>#[ink(storage)]</code> must be used if the collection type is used. The collection type provided by ink!**.</p>
<blockquote>
<p>Since Solidity is relatively rudimentary, the storage map defined by Solidity cannot be traversed. (Caused by a defect in the Solidity design)</p>
<p>ink! has done a lot of things when designing this piece, so the collection types <code>Vec</code>, <code>BTreeMap</code>, <code>HashMap</code> and so on provided by ink! are all <strong>traversable</strong>. Compared with the functions that Solidity can achieve, it is a considerable improvement.</p>
</blockquote>
</li>
<li>
<p>Even based on the above design, the nested collection type is still difficult to implement (because the state structure of Substrate uses the k/v model). Therefore, in the design, we can only try to avoid nested collection types. If you must nest the collection type, you need to flatten the nesting level, merge the second-level key and the first-level key together, and use tuples instead (equivalent to <code>double_map</code> in Substrate Runtime)</p>
<pre><code class="language-Solidity ignore">// solidity
contract A {
    mapping (uint =&gt; mapping (uint =&gt; uint))
}
</code></pre>
<p>The similar code in ink! should be:</p>
<pre><code class="language-rust ignore">#[ink(storage)]
pub struct Erc20 {
    // Note that the key here uses the tuple `(AccountId, AccountId)`
    allowances: StorageHashMap&lt;(AccountId, AccountId), Balance&gt;,
}
</code></pre>
</li>
<li>
<p>A model of <code>Lazy</code> is provided in storage, which allows developers to use <code>Lazy</code> to wrap a type so that the state data can be loaded when it is used:</p>
<pre><code class="language-rust ignore">/// A lazy storage entity.
///
/// This loads its value from storage upon first use.
///
/// # Note
///
/// Use this if the storage field doesn't need to be loaded in some or most cases.
#[derive(Debug)]
pub struct Lazy&lt;T&gt;
where
    T: SpreadLayout,
{
    cell: LazyCell&lt;T&gt;,
}
</code></pre>
<p>How to use:</p>
<pre><code class="language-rust ignore">#[ink(storage)]
pub struct Erc20 {
    /// Total token supply.
    total_supply: Lazy&lt;Balance&gt;,
}
</code></pre>
</li>
</ol>
<h3><a class="header" href="#constructormessage" id="constructormessage"><code>constructor</code>/<code>message</code></a></h3>
<p><code>constructor</code>/<code>message</code> is the entry function that triggers the contract state change. In other words, <code>constructor</code>/<code>message</code> is the state transition function of the contract state.</p>
<p><code>constructor</code>/<code>message</code> can only modify the methods of the contract structure**, and cannot be used to modify the methods of other structures or other pure functions.</p>
<p>In the contract mod, there is at least one method for the contract structure modified by <code>constructor</code> and <code>message</code>. If there are less than one respectively, it will cause compilation error.</p>
<p>among them:</p>
<ul>
<li>
<p><code>constructor</code> corresponds to the constructor in the Solidity contract. When the contract is deployed (in Contracts Pallet currently represents the process of doing <code>instantiate</code> from the uploaded contract code), a call to the corresponding constructor will be triggered.</p>
<blockquote>
<p>It needs to be emphasized here that the call of the constructor and the instantiation of the contract are two conceptual things. This process is <strong>not atomic</strong> in the coordination process of ink! and Contracts Pallet. Therefore, the constructor may not be called, but the contract address will be generated, and the contract instance for which the constructor has not been called can be called normally.</p>
<p>A typical example is the wrong code parameter passed in when calling <code>instantiate</code>.</p>
</blockquote>
</li>
<li>
<p><code>message</code> corresponds to the call methods such as <code>public</code>/<code>external</code> in the Solidity contract. Due to the characteristics of Rust's mutable/immutable methods, <code>message</code> uses the ** feature to indicate whether this method will modify the state of the contract**.</p>
<p>So if the method of <code>message</code> modification is</p>
<pre><code class="language-rust ignore">// Note that the first parameter of the method is `&amp;self`
#[ink(message)]
pub fn total_supply(&amp;self) -&gt; Balance {
    *self.total_supply
}
</code></pre>
<p>It means that the call of this method will not modify the state (controlled by the rust syntax), which is consistent with Ethereum. This type of method is mostly used for rpc calls to return the storage of a contract or return some storage-based calculation results.</p>
<p>If the modification is</p>
<pre><code class="language-rust ignore">// Note that the first parameter of the method is `&amp;mut self`
pub fn transfer(&amp;mut self, to: AccountId, value: Balance) -&gt; Result&lt;()&gt; {
    let from = self.env().caller();
    self.transfer_from_to(from, to, value)
}
</code></pre>
<p>It means that the call of this method will modify the state, so if this method is called and executed in the form of a packaged transaction call, it will trigger a state change. If it is called by rpc, it means that the simulation has been executed once.</p>
<p>At the same time, metadata.json (corresponding to the ABI of Solidity) will be generated after the contract is compiled. In this metadata, there will be a <code>mutates</code> field for the message part to indicate whether the method is variable.</p>
</li>
</ul>
<h4><a class="header" href="#messages-selector" id="messages-selector">message's <code>selector</code></a></h4>
<p>For the generation of the ABI of the contract method, Solidity uses the method name plus the parameter type as a function signature to piece together into a string and then make a hash to take the first 4 bytes.</p>
<pre><code class="language-text">call = &quot;func_name(param1_type,param2_type,...)&quot;
bytes4(keccak256(call), a, b)
</code></pre>
<p>In ink!, this concept that allows contracts to distinguish call trigger points is called <code>selector</code>.</p>
<p>Since rust does not support function overloading, a relatively simple design is adopted in ink!, which directly hashes the string of the function name and takes the first 4 bytes:</p>
<pre><code class="language-text">call = &quot;func_name&quot;
blake2_512(call)[0..4]
</code></pre>
<blockquote>
<p>The author believes that this design has caused problems with other contract language designs. Because rust does not support overloading, it does not mean that other languages ​​do not support overloading. After Solang compiles Solidity to Wasm, if it wants to be compatible with ink!'s metadata, problems will arise when calling each other.</p>
</blockquote>
<p>On the other hand, <code>selector</code> can also run the contract developer's own definition</p>
<pre><pre class="playground"><code class="language-rust json">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[ink(message, selector = &quot;0xCAFEBABE&quot;)]
pub fn was_it_ten(&amp;self) -&gt; bool {...}
<span class="boring">}
</span></code></pre></pre>
<h4><a class="header" href="#message-of-payable" id="message-of-payable">message of <code>payable</code></a></h4>
<p>There is a <code>payable</code> modifier for the method in Solidity, which is used to indicate that the method can accept a certain amount of money.</p>
<p>Therefore, <code>payable</code> is also provided in ink! to indicate whether it is possible to transfer a certain amount of <strong>local currency</strong> while calling this method. In the current design of ink!, if a non-payable message is called with an amount at the same time, the calling process will be regarded as an error.</p>
<p>By default, <code>paybale</code> is considered to be <code>false</code>, and it is <code>true</code> only when the contract developer specifies <code>payable</code>.</p>
<p>The case for specifying a message to be callable is:</p>
<pre><pre class="playground"><code class="language-rust json">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[ink(message, playable)]
pub fn was_it_ten(&amp;self) -&gt; bool {...}
<span class="boring">}
</span></code></pre></pre>
<p>On the other hand, in metadata, there will be a <code>payable</code> field for the message part to indicate whether this method requires payment.</p>
<h3><a class="header" href="#event" id="event"><code>event</code></a></h3>
<p>The concept of event is not necessary in the state machine model. However, because <strong>blockchain is an asynchronous system</strong>, after sending a transaction to trigger a state change, the result of the change cannot be immediately known, and it can only rely on monitoring an element to determine the execution result. <code>event</code> is an element designed at the stage of Solidity, and this design is also inherited from Substrate Runtime and ink!.</p>
<blockquote>
<p>I don't think event is a good design. In theory, there are other better ways, or variants of event. Event will cause abuse by developers to a certain extent.</p>
</blockquote>
<p>The <code>event</code> of ink! in Contracts Pallet finally prints the event defined by the contract to the event of the chain through the <code>host function</code>.</p>
<p>The event design of ink! is nothing special compared to Solidity, but because it is a contract running in Wasm, the event of the printing contract needs to interact with the chain through the host function, so the calling method needs to be passed through. env()` to call.</p>
<pre><code class="language-rust ignore">Self::env().emit_event(...);
// or use
self.env().emit_event(...);
</code></pre>
<h1><a class="header" href="#ink-跨合约调用" id="ink-跨合约调用">ink! 跨合约调用</a></h1>
<h1><a class="header" href="#ink-与solidity的对比" id="ink-与solidity的对比">ink! 与solidity的对比</a></h1>
<h1><a class="header" href="#cargo-contract" id="cargo-contract">cargo-contract</a></h1>
<h1><a class="header" href="#ink-当前的坑" id="ink-当前的坑">ink! 当前的坑</a></h1>
<h1><a class="header" href="#ask" id="ask">Ask!</a></h1>
<p><img src="https://camo.githubusercontent.com/207ae88065c356df521ad4c6cff4a68ef91ae963a9c65893dd0d9d991a4e00a8/68747470733a2f2f706174726163742e6e6574776f726b2f696d616765732f706174726163742d61736b2e706e67" alt="" /></p>
<p>Ask! is a Wasm contract language framework designed by Patract, built on AssemblyScript and able to run on the <code>pallet-contracts</code> module.</p>
<p>Although AssemblyScript is only a subset of typescript, there are many developers who use typescript as a development language, so the cost of learning AssemblyScript for these developers is very low. Therefore, Patract believes that the Ask! project has good application development prospects. Compared with the Rust-based ink!, Patract believes that the typescript-based Ask! can effectively lower the threshold for contract developers and enrich the contract development ecosystem.</p>
<p>Ask! uses and ink! takes a similar approach to macro design eDSL. By providing annotations in AssemblyScript (hereinafter referred to as AS), it provides functions that can be applied to the <code>pallet-contracts</code> contract model based on the syntax of AS. Through the implementation of annotations, the details related to the contract are hidden as much as possible. On the other hand, the realization of Ask! will be close to ink!, and <strong>the final realization will ensure compatibility with the ink! contract to the greatest extent</strong>.</p>
<blockquote>
<p>for example：
ink! describes the external call interface of the contract using <code>#[ink(constructor)]</code>, <code>#[ink(message)]</code> to modify the method of the contract structure.</p>
<p>In Ask!, annotations such as <code>@constructor</code> and <code>@action</code> will be used to modify contract class methods to achieve similar functions.</p>
</blockquote>
<h2><a class="header" href="#ask-development-progress" id="ask-development-progress">Ask! Development progress</a></h2>
<p>**Ask! is currently under development, and currently only the v0.1 version of the Kusama financial proposal has been completed. Many current designs may undergo incompatibility changes in the future. **</p>
<p>TODO： 添加议案链接及报告链接。</p>
<h1><a class="header" href="#tutorial" id="tutorial">tutorial</a></h1>
<blockquote>
<p>At present, Ask! has only carried out the development of the first phase of the Kusama Treasury bill. Therefore, it has not been released to public repositories such as npm.</p>
</blockquote>
<h2><a class="header" href="#simple-start" id="simple-start">Simple start：</a></h2>
<ol>
<li>
<p>clone project</p>
<pre><code class="language-bash">$ git clone https://github.com/patractlabs/ask
</code></pre>
</li>
<li>
<p>example contract</p>
<p>Some case contracts, such as <code>flipper</code>, <code>incrementer</code>, etc., are prepared in the Ask! project, under the <code>/example</code> directory. Developers can directly refer to these projects, or they can perform the following process by creating a new typescript file (*.ts). The final code of the following example process is located in the <code>/example/solar</code> directory.</p>
<ol>
<li>
<p>create file <code>solar.ts</code></p>
</li>
<li>
<p>define contract storage</p>
<p>Ask! uses the annotation <code>@storage</code> to define the storage of a contract. This process is similar to the <code>#[ink(storage)]</code> macro in ink!. For example, in this case, we define the following three contract storage variables:</p>
<pre><code class="language-typescript">@storage
class Planets {
    name: string;
    radius: u32;
    isdwarf: boolean;
}
</code></pre>
</li>
<li>
<p>Define the scope of the contract and callable methods:</p>
<p>Ask! uses the <code>@contract</code> annotation to specify a class as the contract class. This process is similar to the <code>#[ink::contract]</code> macro in ink!.</p>
<pre><code class="language-typescript">@contract
class SolarSystem {
    // ...
}
</code></pre>
<p>Ask! provides <code>@constructor</code> and <code>@message</code> annotations to modify the methods in the contract class, similar to <code>#[ink(constructor)]</code> and <code>#[ink(message)]</code> in ink!.</p>
<pre><code class="language-typescript">@contract
class SolarSystem {
    @constructor
    default(name: string) void { /*...*/ }

    @message(mutates = false, selector = &quot;0x0a0b0c0d&quot;)
    getRadius(): u32 { /*...*/ }
}
</code></pre>
</li>
<li>
<p>Compile the Ask! contract</p>
<ol>
<li>
<p>Installation dependent environment:</p>
<p>Enter the root directory of the Ask! project and execute the command:</p>
<pre><code class="language-bash">$ npm install
</code></pre>
</li>
<li>
<p>Compile</p>
<p>Compile the contract in the <strong>root directory</strong> of the Ask! project. Assuming that the path of the current contract is located in <code>examples/solar/solar.ts</code> (developers can replace with the path of their own contract files), then the compilation command is:</p>
<pre><code class="language-bash">./assembly/codegen/bin/ask examples/solar/solar.ts
</code></pre>
<p>After executing this command, an extension file <code>extension.ts</code> will be generated in the contract file directory, and the compiled product of the contract is located in the <code>target</code> directory under the contract file directory.</p>
</li>
<li>
<p>Test</p>
<p>Developers can use the contract execution environment sandbox <a href="ask/../europa/introduction.html">Europa</a> provided by Patract to deploy and test contracts.</p>
<p>After starting Europa, developers can deploy and call contracts in the <code>target</code> directory through <a href="https://polkadot.js.org/apps">https://polkadot.js.org/apps</a>. This process is similar to Ink! The operation process of the contract is the same.</p>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<h1><a class="header" href="#design" id="design">Design</a></h1>
<h2><a class="header" href="#ask-design-overview" id="ask-design-overview">Ask! Design Overview</a></h2>
<p>AssemblyScript uses the asc compiler to compile TypeScript (TS) files into WebAssembly bytecode. However, asc is a general-purpose compilation tool, and the smart contract structure cannot be used to directly compile TS files into WASM bytecode and metadata information. Therefore, in order for asc to recognize and parse the contract-related annotations and specific grammar provided by Ask!, asc needs to be modified.</p>
<h2><a class="header" href="#design-1" id="design-1">Design</a></h2>
<p>ask! will provide two components, <code>Contract Framework</code> (referred to as <code>Framework</code> in the following description) and <code>Contract PreProcessor</code> (referred to as <code>PreProcessor</code> in the following description). In addition, we will also provide a support tool called ask-cli (similar to ink!'s <code>cargo-contract</code>) to help build and manage Ask! Wasm smart contract written.</p>
<p>The functions of Ask! are implemented as follows:</p>
<ul>
<li>
<p>The main function of <code>Framework</code> is to provide advanced packaging for on-chain APIs, and then provide specifications for writing contracts through annotation types. It needs to complete the following tasks:</p>
<ul>
<li>Define the annotation-based contract writing specification</li>
<li>Define the description specification of the contract interface in the metadata</li>
<li>Encapsulate the detailed information of the data interaction between the contract and the chain, such as the definition of the key generation rules in the contract storage and the storage read and write</li>
<li>Encapsulate functional components on the chain, such as Balance, AccountId, Block, Crypto, etc.</li>
<li>Compile the AS contract into Wasm code according to the semantics of the contract, and include the link symbol of the interactive interface with the FRAME contract.</li>
</ul>
</li>
<li>
<p>The main function of <code>PreProcessor</code> is to parse the annotations defined in the framework and generate corresponding logic codes for these annotations. According to the contract interface specification in the framework, a metadata file is generated. This part needs to complete the following tasks:</p>
<ul>
<li>Parse the annotations in the contract and generate the corresponding logic code</li>
<li>Analyze contract interfaces and parameters, and generate metadata files</li>
<li>Parse the custom contract grammar (syntactic sugar) and generate the corresponding logic code</li>
<li>Automatically store and load data</li>
</ul>
</li>
<li>
<p>The main function of <code>ask-cli</code> is to manage the Ask! project in cli, which includes the following functions:</p>
<ul>
<li>Create ask! contract template.</li>
<li>Simplify ask! During the project compilation process, the detailed information of the preprocessing and compilation process is hidden.</li>
<li>Manage the version dependency of <code>Framework</code>, <code>PreProcessor</code> and Compiler.</li>
<li>Check the legality of the generated Wasm code.</li>
</ul>
</li>
</ul>
<h1><a class="header" href="#基础" id="基础">基础</a></h1>
<h1><a class="header" href="#example" id="example">example</a></h1>
<h1><a class="header" href="#solang" id="solang">Solang</a></h1>
<h1><a class="header" href="#redspot" id="redspot">Redspot</a></h1>
<p>Redspot is a contract integration builder that allows developers to simplify the process of testing and interacting with contracts by projecting the development of contracts such as ink! The Redspot system allows developers to build rich plugins that extend Redspot's functionality, minimizing the burden on contract developers and automating the execution of repetitive processes.</p>
<p>Redspot is designed to be similar to Truffle in the Ethereum ecosystem, but with a broader set of extensions than Truffle.</p>
<p>Patract believes that Redspot must be a flexible system, since the <code>pallet-contracts</code> contract module can be integrated directly, or with some modification, into the Substrate chain. Therefore, Redspot decided to use <a href="https://github.com/nomiclabs/hardhat">hardhat</a> as the core Redspot architecture because it has an excellent design that allows developers to add new features using plugins.</p>
<p>So Redspot comes from the hardhat fork (based on the MIT protocol) and removes the Ether-related parts from its base and adds features related to the Substrate and <code>pallet-contracts</code> modules. In the future, Redspot will build more features based on hardhat's core.</p>
<h1><a class="header" href="#tutorial-1" id="tutorial-1">tutorial</a></h1>
<h2><a class="header" href="#environment-preparation" id="environment-preparation">Environment preparation</a></h2>
<h3><a class="header" href="#installing-node" id="installing-node">Installing Node</a></h3>
<p>We require node version &gt;= 12.0, if not, you can visit the nodejs website and learn how to install or upgrade. Alternatively we recommend that you install Node using nvm. Windows users can use nvm-windows instead.</p>
<h3><a class="header" href="#ink-toolchain-for-contract-compilation" id="ink-toolchain-for-contract-compilation">ink! Toolchain for contract compilation</a></h3>
<ol>
<li>
<p>rust environment. Since the ink! contract requires rust's Wasm toolchain, and Wasm currently only runs under the nightly toolchain, developers need to prepare the Wasm compilation environment first: ``bash</p>
<pre><code class="language-bash">rustup install nightly
rustup component add rust-src --toolchain nightly
rustup target add wasm32-unknown-unknown --toolchain nightly
rustup component add rust-src --toolchain nightly

</code></pre>
</li>
</ol>
<p>The tool to compile the contract <code>cargo-contract</code>.</p>
<pre><code>Please note that the following command installs the official `cargo-contract` provided by parity by default (currently the latest version is 0.10.0).
``bash
cargo install cargo-contract --force
```

With Europa you can use the `cargo-contract` provided by Patract, which provides an optional `-d/--debug` command
``bash
cargo install cargo-contract --git https://github.com/patractlabs/cargo-contract --branch=v0.10.0 --force
```

If you installed `cargo-contract` without feature `binaryen-as-dependency`, you need to prepare `wasm-opt` in your current environment.
</code></pre>
<ol start="3">
<li>install <code>wasm-opt</code> (optional)</li>
</ol>
<p>wasm-opt comes from the repository <a href="https://github.com/WebAssembly/binaryen">https://github.com/WebAssembly/binaryen</a>. Developers can download the latest compilation product for the corresponding platform directly from the release. Direct downloads should be placed in a PATH path that can be accessed from anywhere.</p>
<p>Alternatively, developers can install <code>wasm-opt</code> via the system command</p>
<p>TODO Determine the installation method for different platforms</p>
<h3><a class="header" href="#prepare-a-blockchain-node-that-can-run-contracts" id="prepare-a-blockchain-node-that-can-run-contracts">Prepare a blockchain node that can run contracts</a></h3>
<h4><a class="header" href="#1-jupiter" id="1-jupiter">1. Jupiter</a></h4>
<p>Jupiter <a href="https://github.com/patractlabs/jupiter">https://github.com/patractlabs/jupiter</a> is maintained by Patract, contains the Patract contract design specification and is compatible with the latest <code> pallet-contracts</code> module of the contract testing network.</p>
<p>Jupiter has three types of nodes.</p>
<ul>
<li>a parallel chain of Jupiter contracts running on rococo.</li>
<li>Jupiter standalone test networks that run independently to provide the latest contract functionality to the outside world.</li>
<li>Jupiter nodes for fast local testing</li>
</ul>
<p>See the Readme of this project for information on the differences between these three types of nodes and their compilation and installation.</p>
<h4><a class="header" href="#2-europa" id="2-europa">2. Europa</a></h4>
<p>Europa <a href="https://github.com/patractlabs/europa">https://github.com/patractlabs/europa</a> is a contract sandbox designed by Patract to help contract developers debug and test their contracts. It is similar to Ganache in the Ethereum ecosystem, but the features of Europa are more in the sense that it provides a log of detailed execution information during the deployment of contract invocations, which can reflect the operation of the contract module as a &quot;black box&quot; to the maximum extent, and is very helpful for contract This is very helpful for contract developers.</p>
<p>Developers can install and start Europa simply by</p>
<pre><code class="language-bash">cargo install europa --git https://github.com/patractlabs/europa --locked --force
europa --tmp
</code></pre>
<p>For different versions of Europa and other information, see the Readme for this project.</p>
<h4><a class="header" href="#3-canvas" id="3-canvas">3. Canvas</a></h4>
<p>Canvas <a href="https://github.com/paritytech/canvas-node">https://github.com/paritytech/canvas-node</a> is the official contract test chain provided by parity with the <code>pallet-contracts</code> module. module, which is a test network maintained by the parity <code>ink!</code> &amp; <code>pallet-contracts</code> development team.</p>
<p>To participate in the canvas network, please refer to the Readme for this project. if the purpose is just to run the test node locally, you can execute the following command.</p>
<pre><code class="language-bash">cargo install canvas-node --git https://github.com/paritytech/canvas-node.git --force --locked
canvas --dev --tmp
</code></pre>
<h2><a class="header" href="#create-a-redspot-project" id="create-a-redspot-project">Create a Redspot project</a></h2>
<h3><a class="header" href="#installing-from-a-template" id="installing-from-a-template">Installing from a Template</a></h3>
<p>Redspot provides contract development templates that allow users to quickly build a project. Currently, only templates for the erc20 contract are supported for installation.</p>
<p>To create a new project from the template, you can choose to use <code>npx</code>. npx is a package executor that comes with npm (<em>npm 5.2+</em> ). Running the following command will pull the <strong>latest</strong> Redspot and build the Redspot project using erc20 as the template.</p>
<pre><code>npx redspot-new erc20
</code></pre>
<blockquote>
<p>Note that Redspot does not yet provide the ability to create projects from templates, as ink! changes frequently at the moment. Developers who need additional project templates can copy them from the example directory in Redspot's project repository <a href="https://github.com/patractlabs/redspot">https://github.com/patractlabs/redspot</a> to directory in Redspot's project repository [] () and change the configuration such as the project name. All cases in the <strong>example directory are already in the Redspot project structure</strong>, so there is no need for the user to run <code>npx redspot-new</code> to create the project.</p>
</blockquote>
<p>If a project has already been created by Redspot, there must be a file <code>redspot.config.ts</code> in the root of the project to mark the project as Redspot, and <code>package.json</code> in the same directory controls the version of Redspot that corresponds to the project.</p>
<p>If a contract developer has obtained a Redspot project from github, or example, or otherwise, and another developer has built it, going to the project directory and running <code>yarn install</code> will restore the Redspot environment used by the Redspot project, as in the following example.</p>
<pre><code class="language-bash"># copy the delegator multi-contract example from redspot repo to local dir
cp -r . /redpost/example/delegator . /
cd delegator
yarn install
</code></pre>
<p>The default template is already configured with typescript. It is also recommended that you use typescript for development. Even if you have no experience with typescript, typescript is javascript-compatible, works without any type definition, and still has the powerful type hinting and error hinting features of typescript.</p>
<h3><a class="header" href="#integration-into-existing-contract-projects" id="integration-into-existing-contract-projects">Integration into existing contract projects</a></h3>
<p>Redspot can also be easily integrated into existing contract projects. Let's take the contracts in the <strong>examples</strong> directory of the official ink (https://github.com/paritytech/ink) repository as an example.</p>
<h4><a class="header" href="#compile-the-contract" id="compile-the-contract">Compile the contract</a></h4>
<p>First clone the ink repository and open the ink directory.</p>
<pre><code>git clone https://github.com/paritytech/ink.git
cd ink
</code></pre>
<p>Then we create the following three files in the ink root directory.</p>
<p>redspot.config.ts:</p>
<pre><code class="language-typescript">import { RedspotUserConfig } from 'redspot/types';
import '@redspot/patract'; // 引入 @redspot/patract 插件
import '@redspot/chai'; // 引入 @redspot/chai 插件

export default {
  defaultNetwork: 'development', // 默认的 network
  contract: {
    ink: {
      toolchain: 'nightly',      // 指定编译合约时的 toolchain 版本
      sources: ['examples/**/*'] // 合约所在的目录
    }
  },
  networks: {
    // development 网络的配置
    development: {
      endpoint: 'ws://127.0.0.1:9944',
      types: {},
      gasLimit: '400000000000', // 设置默认的 gasLimit
      explorerUrl:
        'https://polkadot.js.org/apps/#/explorer/query/?rpc=ws://127.0.0.1:9944/'
    },
  },
  mocha: {
    timeout: 60000
  }
} as RedspotUserConfig;
</code></pre>
<p>package.json:</p>
<pre><code class="language-json">{
  &quot;name&quot;: &quot;examples&quot;,
  &quot;version&quot;: &quot;0.1.0&quot;,
  &quot;private&quot;: true,
  &quot;resolutions&quot;: {
    &quot;@polkadot/api&quot;: &quot;^3.10.2&quot;,
    &quot;@polkadot/api-contract&quot;: &quot;^3.10.2&quot;
  },
  &quot;dependencies&quot;: {
    &quot;@redspot/chai&quot;: &quot;^0.10.1&quot;,
    &quot;@redspot/patract&quot;: &quot;^0.10.1&quot;,
    &quot;@types/chai&quot;: &quot;^4.2.14&quot;,
    &quot;@types/mocha&quot;: &quot;^8.0.3&quot;,
    &quot;chai&quot;: &quot;^4.2.0&quot;,
    &quot;redspot&quot;: &quot;^0.10.1&quot;,
    &quot;typescript&quot;: &quot;^4.0.2&quot;
  },
  &quot;scripts&quot;: {
    &quot;build&quot;: &quot;npx redspot compile&quot;,
    &quot;test&quot;: &quot;npx redspot test&quot;
  }
}
</code></pre>
<p>tsconfig.json:</p>
<pre><code class="language-json">{
  &quot;compilerOptions&quot;: {
    &quot;target&quot;: &quot;es5&quot;,
    &quot;module&quot;: &quot;commonjs&quot;,
    &quot;strict&quot;: true,
    &quot;esModuleInterop&quot;: true,
    &quot;outDir&quot;: &quot;dist&quot;,
    &quot;noImplicitAny&quot;: false
  },
  &quot;include&quot;: [
    &quot;**/*.ts&quot;
  ],
  &quot;exclude&quot;: [
    &quot;node_modules&quot;
  ],
  &quot;files&quot;: [
    &quot;./redspot.config.ts&quot;,
  ]
}
</code></pre>
<p>Then install the npm dependency (it is recommended to use <a href="https://classic.yarnpkg.com/en/docs/install">yarn</a> as the package manager): ```.</p>
<pre><code>yarn or npm install
</code></pre>
<p>Then running the command <code>npx redspot compile</code> in the root of the project will compile all the contracts under examples, now we execute the following command.</p>
<pre><code>npx redspot compile examples/erc20
</code></pre>
<p>This command will specify the erc20 contract to be compiled. After the compilation is complete, you can find the compiled product in the artifacts directory.</p>
<h4><a class="header" href="#deploying-the-contract" id="deploying-the-contract">Deploying the contract</a></h4>
<p>Now we can run a deployment script through Redspot by creating this file in the ink root directory.</p>
<p>deploy.ts</p>
<pre><code class="language-typescript">import { network, patract } from &quot;redspot&quot;;

const { getContractFactory } = patract;
const { getSigners, api } = network;

async function run() {
    console.log(&quot;deploy erc20&quot;);

    await api.isReady;

    console.log(&quot;deploy erc201&quot;);

    const signers = await getSigners();
    const signer = signers[0];

    const contractFactory = await getContractFactory(&quot;erc20&quot;, signer);

    const contract = await contractFactory.deploy(&quot;new&quot;, &quot;1000000&quot;, {
        gasLimit: &quot;200000000000&quot;,
        value: &quot;10000000000000000&quot;,
    });

    console.log(
        &quot;Deploy successfully. The contract address: &quot;,
        contract.address.toString()
    );

    api.disconnect();
}

run().catch((err) =&gt; {
    console.log(err);
});

</code></pre>
<p>Then you make sure that you have configured the network correctly in <code>redspot.config.ts</code>: </p>
<p>``typescript
{
...
networks: {
development: {
endpoint: 'ws://127.0.0.1:9944', // 
types: {},
...
},
},
}</p>
<pre><code>
Now you can run the deploy.ts file, adding `-no-compile` to prevent duplicate compilation: `

```bash
npx redspot run . /deploy.ts --no-compile
</code></pre>
<p>After a successful contract deployment, you will get a message like this.</p>
<pre><code>Deploy successfully. the contract address: 5CqB5Mh9UdVbTE1Gt5PJfWSiCHydJaJsA31HjKGti1Z2fn78
</code></pre>
<h4><a class="header" href="#test-contracts" id="test-contracts">Test Contracts</a></h4>
<p>We add a new erc20.test.ts file to the tests directory to test the erc20 contract: erc20.test.ts</p>
<p>tests/erc20.test.ts</p>
<pre><code class="language-typescript">import BN from 'bn.js';
import { expect } from 'chai';
import { patract, network, artifacts } from 'redspot';

const { getContractFactory, getRandomSigner } = patract;

const { api, getSigners } = network;

describe('ERC20', () =&gt; {
  after(() =&gt; {
    return api.disconnect();
  });

  async function setup() {
    const one = new BN(10).pow(new BN(api.registry.chainDecimals[0]));
    const signers = await getSigners();
    const Alice = signers[0];
    const sender = Alice;
    const contractFactory = await getContractFactory('erc20', sender);
    const contract = await contractFactory.deploy('new', '1000');
    const abi = artifacts.readArtifact('erc20');
    const receiver = await getRandomSigner();

    return { sender, contractFactory, contract, abi, receiver, Alice, one };
  }

  it('Assigns initial balance', async () =&gt; {
    const { contract, sender } = await setup();
    const result = await contract.query.balanceOf(sender.address);
    expect(result.output).to.equal(1000);
  });

  it('Transfer emits event', async () =&gt; {
    const { contract, sender, receiver } = await setup();

    await expect(contract.tx.transfer(receiver.address, 7))
      .to.emit(contract, 'Transfer')
      .withArgs(sender.address, receiver.address, 7);
  });

  it('Can not transfer above the amount', async () =&gt; {
    const { contract, receiver } = await setup();

    await expect(contract.tx.transfer(receiver.address, 1007)).to.not.emit(
      contract,
      'Transfer'
    );
  });

  it('Can not transfer from empty account', async () =&gt; {
    const { contract, Alice, one, sender } = await setup();

    const emptyAccount = await getRandomSigner(Alice, one.muln(10000));

    await expect(
      contract.tx.transfer(sender.address, 7, {
        signer: emptyAccount
      })
    ).to.not.emit(contract, 'Transfer');
  });
});

</code></pre>
<p>Run the test command.</p>
<pre><code>npx redspot test --no-compile
</code></pre>
<p>You will get results similar to the following.</p>
<pre><code>....
✓ Can not transfer from empty account (17912ms)

  4 passing (46s)
</code></pre>
<h2><a class="header" href="#project-development" id="project-development">Project Development</a></h2>
<p>Go to the root of your newly created Redspot project and execute the following command to view the Tasks currently supported by Redspot:</p>
<pre><code class="language-bash">npx redspot
</code></pre>
<p>For the concept of &gt;Tasks, please refer to the document [Tasks](. /overview.md#Tasks).</p>
<p>Run <code>npx redspot --help</code> to see the help.</p>
<pre><code>Redspot version 0.10.1

Usage: redspot [GLOBAL OPTIONS] &lt;TASK&gt; [TASK OPTIONS]

GLOBAL OPTIONS:

  --config A Redspot config file. 
  --help Shows this message, or a task's help if its name is provided 
  --log-level Set log levels 1-5 
  --max-memory The maximum amount of memory that Redspot can use. 
  --network The network to connect to. 
  --show-stack-traces Show stack traces. 
  --tsconfig Reserved redspot argument -- Has no effect. 
  --verbose Enables Redspot verbose logging 
  --version Shows redspot's version. 


AVAILABLE TASKS:

  check Check whatever you need
  clean Clears the cache and deletes all artifacts
  compile Compiles the entire project, building all artifacts
  console Opens a redspot console
  help Prints this message
  run Runs a user-defined script after compiling the project
  test Runs mocha tests

To get help for a specific task run: npx redspot help [task]
</code></pre>
<p>You can see that there are two parts to the help message, GLOBAL OPTIONS and TASKS, through which we can invoke Redspot's built-in tasks or custom tasks. For example</p>
<p><code>npx redspot compile</code> can run the compile contract command.</p>
<p>Usually each TASK provides its own configuration of parameters. The <code>npx redspot compile --help</code> can be used to view help information.</p>
<pre><code>Redspot version 0.10.1

Usage: redspot [GLOBAL OPTIONS] compile [.... .sourcePattern]

POSITIONAL ARGUMENTS:

  sourcePattern A glob string that is matched against (default: [])

compile: Compiles the entire project, building all artifacts

For global options help run: redspot help
</code></pre>
<p>For the compile command, we can pass the path of the contract to specify the contract to be compiled, e.g. <code>npx redspot compile examples/erc20</code>.</p>
<p><code>GLOBAL OPTIONS</code> is the global configuration of the Redspot runtime. It can be attached to any TASK. For example, <code>npx redspot test --network substrate</code> will specify a connection to the substrate network (the substrate network needs to be configured in config). <code>npx redspot test --log-level 3</code> will specify the level of logs to be printed, the default is 2. We can also set <code>GLOBAL OPTIONS</code> via environment variables.</p>
<ul>
<li>Set log level: <code>REDSPOT_LOG_LEVEL=5 npx redspot test</code> ,</li>
<li>set network: <code>REDSPOT_NETWORK=substrate npx redspot test</code>.</li>
</ul>
<p>Let's go over a few of the built-in TASKs.</p>
<h3><a class="header" href="#compile" id="compile">Compile</a></h3>
<p>Running the <code>npx redspot compile</code> command will perform contract compilation. The <a href="https://github.com/paritytech/ink">ink</a> contract and the <a href="https://github.com/hyperledger-labs/solang">solang</a> contract are currently supported for compilation. When compiling the ink contract, make sure you have <a href="https://github.com/paritytech/cargo-contract">cargo-contract</a> installed. When compiling the solang contract, make sure you have <a href="https://solang.readthedocs.io/en/latest/installing.html#building-solang-from-crates-io">solang cli</a> installed. In <code>redspot.config.ts</code>, you can configure the options for compiling.</p>
<pre><code>{
	...
	contract: {
    ink: {
      toolchain: 'nightly', // set the cargo-contract compile-time toolchain
      sources: ['contracts/**/*'] // Configure the directory to find the contract files
    },
    solang: {
      sources: ['contracts/**/*.sol'] // Configure the directory to find contract files
    }
  },
  paths: {
  	...
    artifacts: 'artifacts' // specify the directory where the contract compilation products are stored
    ...
  }
  ...
}
</code></pre>
<p>The compile command takes the sourcePattern parameter and can override the sources in the configuration file, for example</p>
<p><code>npx redspot compile examples/erc20</code></p>
<p>will only look for contracts in the <code>examples/erc20</code> directory.</p>
<p>After compilation, the compiled product can be found in the <code>artifacts</code> directory. There will usually be two formats, <code>[ContractName].contract</code> and <code>[ContractName].json</code>, the only difference between them is that <code>.json</code> does not contain wasm and will be smaller in size. You can also use your own tools to compile and copy the <code>[ContractName].contract</code> file to the artifacts directory. This will not affect other features either.</p>
<h3><a class="header" href="#test" id="test">Test</a></h3>
<p>Automated testing is essential in writing contracts. You can use Redspot for unit testing. Before running the test command, you need to make sure that you have properly configured the nodes that need to be connected. the relevant configuration for Test is as follows.</p>
<pre><code>{
	defaultNetwork: &quot;development&quot;, // the default network to connect to
	...
	networks: {
			development: {
          endpoint: &quot;ws://127.0.0.1:9944&quot;, // url of the network to connect to (websocket)
          types: {}, // Type definitions to be passed to polkadotjs for use
          accounts: [&quot;//Alice&quot;, &quot;tomato mad peasant blush poem obtain inspire distance attitude mercy return marriage&quot;] // The account to use for the signature, default is ['// Alice', '//Bob', '//Charlie', '//Dave', '//Eve', '//Ferdie']
          gasLimit: &quot;400000000000&quot;, // default gaslimit
      },
	}
	path: {
		tests: 'tests', // directory to find test files
	},
	mocha: {
		timeout: 60000, // timeout for mocha tests
		...
	}
	...
}
</code></pre>
<p>You can configure the network to connect to when testing by passing in the network option, example.</p>
<p><code>REDSPOT_NETWORK=development npx redpost test </code> </p>
<p>You can also test only a single file <code>npx redspot test . /tests/[filename].ts</code>. Setting <code> --no-compile</code> prevents the compile command <code>npx redspot test --no-compile</code> from being run automatically.</p>
<p>Test uses mocha as the testing framework by default. You can configure mocha's options in the <code>redspot.config.ts</code> file. Here are all the supported options: https://mochajs.org/api/mocha .</p>
<p>A complete test file looks like this.</p>
<pre><code class="language-typescript">import BN from 'bn.js';
import { expect } from 'chai';
import { patract, network, artifacts } from 'redspot';

const { getContractFactory, getRandomSigner } = patract;

const { api, getSigners } = network;

describe('ERC20', () =&gt; {
  after(() =&gt; {
    return api.disconnect();
  });

  async function setup() {
    const one = new BN(10).pow(new BN(api.registry.chainDecimals[0]));
    const signers = await getSigners();
    const Alice = signers[0];
    const sender = Alice;
    const contractFactory = await getContractFactory('erc20', sender);
    const contract = await contractFactory.deploy('new', '1000');
    const abi = artifacts.readArtifact('erc20');
    const receiver = await getRandomSigner();

    return { sender, contractFactory, contract, abi, receiver, Alice, one };
  }

  it('Assigns initial balance', async () =&gt; {
    const { contract, sender } = await setup();
    const result = await contract.query.balanceOf(sender.address);
    expect(result.output).to.equal(1000);
  });

  it('Transfer emits event', async () =&gt; {
    const { contract, sender, receiver } = await setup();

    await expect(contract.tx.transfer(receiver.address, 7))
      .to.emit(contract, 'Transfer')
      .withArgs(sender.address, receiver.address, 7);
  });

  it('Can not transfer above the amount', async () =&gt; {
    const { contract, receiver } = await setup();

    await expect(contract.tx.transfer(receiver.address, 1007)).to.not.emit(
      contract,
      'Transfer'
    );
  });

  it('Can not transfer from empty account', async () =&gt; {
    const { contract, Alice, one, sender } = await setup();

    const emptyAccount = await getRandomSigner(Alice, one.muln(10000));

    await expect(
      contract.tx.transfer(sender.address, 7, {
        signer: emptyAccount
      })
    ).to.not.emit(contract, 'Transfer');
  });
});
</code></pre>
<p>In the setup function, we create a random account and assign a fixed balance to this account. This account is then used to run various tests to ensure that the results are the same each time.</p>
<p>In this test file, we use two Redspot plugins, @redspot/patract and @redspot/chai, which we will describe in detail in a later article.</p>
<p>In fact, you don't have to use <code>npx redspot test</code> to run this test file; the Test command is simply a wrapper around the mocha command. You can use it any way you like to run the test code. There is no magic in between. For example, try running a test case by executing the command.</p>
<p><code>TS_NODE_TRANSPILE_ONLY=true mocha -r ts-node/register tests/erc20.test.ts --timeout 60000</code> </p>
<p>where we use ts-node to compile and run typescript code, so we need to add <code>-r ts-node/register</code>. <code>TS_NODE_TRANSPILE_ONLY=true</code> Set ts-node to ignore typescript type errors when running.</p>
<h3><a class="header" href="#run" id="run">Run</a></h3>
<p>The Run command can be used to run any typescript file. Setting <code>-no-compile</code> prevents the compile command <code>npx redspot run --no-compile</code> from being run automatically.</p>
<p>Like Test, it is just a simple wrapper around <code>TS_NODE_TRANSPILE_ONLY=true node -r ts-node/register [filepath]</code>. It's just a simple wrapper for `TS_NODE_TRANSPILE_ONLY=true</p>
<p>Normally we can run the deployment script using Run</p>
<pre><code class="language-typescript">import { network, patract } from &quot;redspot&quot;;

const { getContractFactory } = patract;
const { getSigners, api } = network;

async function run() {
    console.log(&quot;deploy erc20&quot;);

    await api.isReady;

    console.log(&quot;deploy erc201&quot;);

    const signers = await getSigners();
    const signer = signers[0];

    const contractFactory = await getContractFactory(&quot;erc20&quot;, signer);

    const contract = await contractFactory.deploy(&quot;new&quot;, &quot;1000000&quot;, {
        gasLimit: &quot;200000000000&quot;,
        value: &quot;10000000000000000&quot;,
    });

    console.log(
        &quot;Deploy successfully. the contract address: &quot;,
        contract.address.toString()
    );

    api.disconnect();
}

run().catch((err) =&gt; {
    console.log(err);
});

</code></pre>
<p>This uses the <code>@redspot/patract</code> plugin. We will explain this in more detail in a later article.</p>
<h3><a class="header" href="#console" id="console">Console</a></h3>
<p>You can start a node's <a href="https://nodejs.dev/learn/how-to-use-the-nodejs-repl"><em>REPL</em></a> console by running the <code>npx redspot console</code>. It has the Redspot Runtime Environment built in, so you can access Redspot in there to provide plugins, configuration, and tasks. We'll have a detailed description of this later.</p>
<p>More examples can be seen at https://github.com/patractlabs/redspot/tree/master/examples/.</p>
<h2><a class="header" href="#introduction-1" id="introduction-1">Introduction</a></h2>
<h2><a class="header" href="#redspots-architecture" id="redspots-architecture">Redspot's architecture</a></h2>
<p>Redspot is designed around the concept of Tasks and Plugins. most of Redspot's functionality comes from plugins, and as a developer you are free to choose which plugins you want to use.</p>
<h3><a class="header" href="#tasks" id="tasks">Tasks</a></h3>
<p>Every time you run Redspot from the cli, you are running a task. For example, executing the command <code>npx redspot compile</code> is running a compile task. To see what tasks are currently available in your project, run <code>npx redspot</code>. You can see help for any task by running <code>npx redspot help [task]</code>.</p>
<h3><a class="header" href="#plugins" id="plugins">Plugins</a></h3>
<p>Redspot has some plugins installed by default, if you need to install or upgrade them manually, please follow these steps.</p>
<p>For example, if you want to install the <code>@redspot/patract</code> and <code>@redspot/chai</code> plugins, go to the project root directory and follow these commands to install them</p>
<pre><code class="language-bash">yarn add @redspot/patract @redspot/chai
</code></pre>
<p>In the redspot configuration file <code>redspot.config.js</code> in the project's directory, add</p>
<pre><code class="language-typescript">import { RedspotUserConfig } from 'redspot/types';
import '@redspot/patract';
import '@redspot/chai';

export default {
 ...
} as RedspotUserConfig;
</code></pre>
<h1><a class="header" href="#configure" id="configure">Configure</a></h1>
<p>When you run Redspot, it will search for the closest redspot.config.js file starting from the current working directory. This file is usually located in the root directory of the project.</p>
<p>This file contains the entire Redspot setup (e.g. configuration, plugins, custom tasks, etc.).</p>
<h2><a class="header" href="#configuration-options" id="configuration-options">Configuration options</a></h2>
<p>To set the configuration, you need to export the object (object) from redspot.config.ts.</p>
<pre><code class="language-typescript">import { RedspotUserConfig } from 'redspot/types';

export default {
  defaultNetwork: 'development',
  contract: {
    ink: {
      toolchain: 'nightly',
      sources: ['contracts/**/*']
    },
    solang: {
      sources: ['contracts/**/*.sol']
    }
  },
  networks: {
    development: {
      endpoint: 'ws://127.0.0.1:9944',
      types: {},
      gasLimit: '400000000000'
    },
    substrate: {
      endpoint: 'ws://127.0.0.1:9944',
      gasLimit: '400000000000',
      accounts: ['//Alice', &quot;tomato mad peasant blush poem obtain inspire distance attitude mercy return marriage&quot;, &quot; 0x26aa394eea5630e07c48ae0c9558cef70a98fdbe9ce6c55837576c60c7af3850&quot;],
      types: {}
    }
  },
  paths: {
    artifacts: &quot;artifacts&quot;,
    tests: &quot;tests&quot;
  },
  mocha: {
    timeout: 60000
  }
} as RedspotUserConfig;
</code></pre>
<p>The configuration information can be obtained in the js file via ``config`''.</p>
<pre><code class="language-typescript">import { config } from &quot;redspot&quot;

console.log(config)
</code></pre>
<h2><a class="header" href="#defaultnetwork" id="defaultnetwork">defaultNetwork</a></h2>
<p>You can customize the network that is used by default when running Redspot by using the <code>defaultNetwork</code> field in the configuration. If this configuration is omitted, the default value is <code>localhost</code>.</p>
<h2><a class="header" href="#networks" id="networks">networks</a></h2>
<p>The <code>networks</code> configuration field is an optional object to which the network name maps to its configuration.</p>
<p>The default configuration for <code>localhost</code> is :</p>
<pre><code class="language-typescript">{
  localhost: {
    gasLimit: &quot;400000000000&quot;,
    accounts: [&quot;//Alice&quot;, &quot;//Bob&quot;, &quot;//Charlie&quot;, &quot;//Dave&quot;, &quot;//Eve&quot;, &quot;//Ferdie&quot;],
    endpoint: &quot;ws://127.0.0.1:9944&quot;,
    types: {}
  }
}
</code></pre>
<p>Other network names can also be configured, e.g. configure <code>mainnet</code>, the name of a particular network <code>some_network_name</code>, etc.</p>
<pre><code class="language-typescript">{
    mainnet: {
        //...
    },
    some_network_name: {
        //...
    }
}
</code></pre>
<p>The following configuration options are described for the <code>network</code> section.</p>
<h3><a class="header" href="#networkgaslimit" id="networkgaslimit"><code>[network].gasLimit</code></a></h3>
<p>This configuration is used to set the default value of <code>gaslimit</code> that needs to be provided when instantiating or invoking a contract via a transaction. This value must be an integer, with no precision.</p>
<p>If this value is too small, you will get a <code>contracts.OutOfGas</code> error. The maximum gaslimit is the maximum value used for <code>DispatchClass::Normal</code> in Runtime for this Substrate's chain. (For example, in the configuration of Substrate's node node is <code>NORMAL_DISPATCH_RATIO * MAXIMUM_BLOCK_WEIGHT = 75% * 2000000000000</code>).</p>
<p>So it is generally recommended to set it higher.</p>
<h3><a class="header" href="#networkaccounts" id="networkaccounts"><code>[network].accounts</code></a></h3>
<p><code>accounts</code> should be set by <a href="https://polkadot.js.org/docs/keyring/start/suri/"><code>suri</code></a> or <a href="https://polkadot.js.org/docs/keyring/"><code>KeyringPair</code></a> start/create/#adding-a-pair).</p>
<p>The accounts default to [&quot;//Alice&quot;, &quot;//Bob&quot;, &quot;//Charlie&quot;, &quot;//Dave&quot;, &quot;//Eve&quot;, &quot;//Ferdie&quot;].</p>
<p>See runtime-environment for details </p>
<h3><a class="header" href="#networkendpoint" id="networkendpoint"><code>[network].endpoint</code></a></h3>
<p><code>endpoint</code> specifies the node in the current network configuration that the developer wants to connect to.</p>
<p>Currently, only WebSockets type RPC connections are supported (i.e. only link protocols starting with <code>wss://</code> or <code>ws://</code> are supported).</p>
<h3><a class="header" href="#networktypes" id="networktypes"><code>[network].types</code></a></h3>
<p>type is a concept defined in <code>polkadotjs</code>. If there is any doubt about this, you can see it here at <a href="https://polkadot.js.org/docs/api/start/types.extend/"><code>types.extend</code></a>. You can also set <code>[network].typesbundle</code>, <code>[network].typesSpec</code>, etc. Usually, if you get an error like &quot;No such variant in enum MultiSignature&quot;, you should probably consider adding <code>{ Address: &quot;AccountId&quot;, LookupSource: &quot;AccountId&quot;}</code>, see <a href="https://polkadot.js.org/docs/api/start/types.extend/#impact-on-extrinsics">impact-on-extrinsics</a> .</p>
<h2><a class="header" href="#contract" id="contract">contract</a></h2>
<p>In the contract, you can set the compiler options, currently <a href="https://github.com/paritytech/ink">ink</a> and <a href="https://github.com/hyperledger-labs/solang">solang</a> are supported. You can also compile the ink contract and the solang contract together under the same project.</p>
<p>See the example of compiling multiple contracts at https://github.com/patractlabs/redspot/tree/master/examples/multi-contract .</p>
<h3><a class="header" href="#contractinktoolchain" id="contractinktoolchain">[contract].ink.toolchain</a></h3>
<p>Set the toolchain used by <a href="https://github.com/paritytech/cargo-contract">cargo-contract</a> when compiling contracts. You can also specify <code>nightly-YYYY-MM-DD</code></p>
<h3><a class="header" href="#contractinksources" id="contractinksources">[contract].ink.sources</a></h3>
<p>Sets the directory of the ink contract to look for at compile time. glob syntax.</p>
<h3><a class="header" href="#contractsolangsources" id="contractsolangsources">[contract].solang.sources</a></h3>
<p>Set the directory of the solang contract to be looked up at compile time. glob syntax.</p>
<h2><a class="header" href="#paths" id="paths">Paths</a></h2>
<p>paths sets the directory name for artifacts and tests files. Normally, you don't need to change this.</p>
<h2><a class="header" href="#mocha" id="mocha">mocha</a></h2>
<p>Redspot uses mocha as its testing framework, and all of the options here will be passed to mocha. Check out https://mochajs.org/api/mocha for more details.</p>
<h1><a class="header" href="#runtime-environment" id="runtime-environment">Runtime Environment</a></h1>
<p>The RedSpot Runtime Environment (RSE) contains all of Redspot's publicly available features.</p>
<p>When you import Redspot (import &quot;redspot&quot;), you get an RSE environment.</p>
<h2><a class="header" href="#accessing-rse" id="accessing-rse">Accessing RSE</a></h2>
<p>env has the following properties.</p>
<pre><code>RuntimeEnvironment {
		config; // the user's configuration file 
    redspotArguments; // global arguments to run the command, including network , logLevel, etc.
    run; // function to run the command
    network; // Contains attributes such as api , keyring etc.
    artifacts; // the product of managing contract compilation
}
</code></pre>
<p>In the Redspot Console, these properties of env are injected into global variables. You can access them directly at</p>
<pre><code>&gt; network.name
'development'
</code></pre>
<p>In js or ts files, you can access the RSE by <code>import env from 'redspot'</code>.</p>
<pre><code class="language-typescript">import { config, redspotArguments, run, network, artifacts } from 'redspot' 
</code></pre>
<h2><a class="header" href="#extending-rse" id="extending-rse">Extending RSE</a></h2>
<p>Some plugins can extend RSE by adding some additional properties or methods to RSE. For example, <code>@redspot/patract</code> extends the RSE by providing an instance of patract. When the patract plugin is introduced, you can access the patract instance like this.</p>
<pre><code class="language-typescript">import { patract } from 'redspot' 
console.log(patract)
</code></pre>
<p>Let's go through the properties of the built-in RSE in more detail.</p>
<h3><a class="header" href="#config" id="config">config</a></h3>
<p>Config contains all the configuration options in redspot.config.ts. and contains the default settings. It is a JSON object.</p>
<p>Get the currently configured default network to connect to</p>
<pre><code class="language-typescript">import { config } from 'redspot' 
console.log(config.defaultNetwork);
</code></pre>
<h3><a class="header" href="#redspotarguments" id="redspotarguments">redspotArguments</a></h3>
<p>Global arguments for the currently running command.</p>
<pre><code>&gt; redspotArguments
{
  network: undefined,
  showStackTraces: false,
  version: false,
  help: false,
  config: undefined,
  verbose: false,
  logLevel: '2',
  maxMemory: undefined,
  tsconfig: undefined
}
</code></pre>
<h3><a class="header" href="#run-1" id="run-1">run</a></h3>
<p>With the run function, you can call the task in a js or ts file: ``#</p>
<pre><code class="language-typescript">import { run } from 'redspot'

run('test') // run the test command
run('test', { testFiles: '. /tests/erc20.test.ts'}) // pass in parameters
</code></pre>
<h3><a class="header" href="#network" id="network">network</a></h3>
<p>Network contains information about the network you are currently running on. The network can be used to get api, keyring, signer, etc. The type definition of network is</p>
<pre><code class="language-typescript">export interface Network {
  name: string;
  config: NetworkConfig;
  provider: WsProvider;
  api: ApiPromise;
  registry: Registry;
  keyring: Keyring;
  getSigners(): Promise&lt;Signer[]&gt;;
  createSigner(pair: KeyringPair): Signer;
  gasLimit: BN;
}
</code></pre>
<h4><a class="header" href="#networkname" id="networkname">network.name</a></h4>
<p>The name of the network currently in use</p>
<h4><a class="header" href="#networkconfig" id="networkconfig">network.config</a></h4>
<p>Configuration options for the network currently in use, equivalent to: <code>config.networks[network.name]</code></p>
<h4><a class="header" href="#networkprovider" id="networkprovider">network.provider</a></h4>
<p>is equivalent to an instance of <a href="https://polkadot.js.org/docs/api/start/create/#providers">wsprovider</a> in polkadotjs. They have the same interface. The endpoint configured in <code>redspot.config.ts</code> is used for the network.provider instantiation parameters.</p>
<h4><a class="header" href="#networkregistry" id="networkregistry">network.registry</a></h4>
<p>Equivalent to an instance of the Registry in polkadotjs, used to manage type codecs. It also contains the <code>types</code> type definitions configured by the user in <code>redspot.config.ts</code>. Check out the polkadotjs documentation to learn more: https://polkadot.js.org/docs/api/start/types.create/.</p>
<h4><a class="header" href="#networkkeyring" id="networkkeyring">network.keyring</a></h4>
<p>Equivalent to an instance of Keyring in polkadotjs. The default is type ss25519. The default value of ss58 is set after the api initialization is complete. See more about keyring: https://polkadot.js.org/docs/api/start/keyring.</p>
<h4><a class="header" href="#networkgetsigners" id="networkgetsigners">network.getSigners</a></h4>
<p>The accounts configured by the user in <code>redspot.config.ts</code> will be resolved to Signers. The getSigners function allows you to get all signers, which is an array corresponding to the accounts configured in accounts.</p>
<p>To get all signers.</p>
<pre><code class="language-typescript">import { network } from 'redspot';

network.getSigners().then((signers) =&gt; {
	console.log(signers[0].address)
})
</code></pre>
<p>The signer is actually compatible with the polkadot js signer. signer's type definition.</p>
<pre><code class="language-typescript">export interface Signer {
   	address: string;
   api: ApiPromise;
   pair: KeyringPair;
   signPayload: (payload: SignerPayloadJSON) =&gt; Promise&lt;SignerResult&gt;;
}
</code></pre>
<p>You can also use it in polkadotjs for transaction signing: the</p>
<pre><code class="language-typescript">import { network } from 'redspot';

const api = network.api

async run() {
  const signers = await network.getSigners()
  const from = signers[0]
  const to = signers[1]
  
  api.tx.balances.transfer(signer1.address, 100000000000).signAndSend({
  	signer: from
  })
}

</code></pre>
<h4><a class="header" href="#networkcreatesigner" id="networkcreatesigner">network.createSigner</a></h4>
<p>You can generate a signer with the createSigner function, which takes a keyringpair and converts it into a signer instance: ``</p>
<pre><code class="language-typescript">const pair = keyring.createFromUri(uri)
const signer = network.createSigner(pair)
</code></pre>
<h4><a class="header" href="#networkgaslimit-1" id="networkgaslimit-1">network.gasLimit</a></h4>
<p>It comes from gaslimt in config and is resolved to type bn.</p>
<h3><a class="header" href="#artifacts" id="artifacts">artifacts</a></h3>
<p>With artifacts you can access and manage abi. it has the following type definition.</p>
<pre><code class="language-typescript">export interface Artifacts {
  readArtifact(contractName: string): Promise&lt;AbiMetadata&gt;;
  readArtifactSync(contractName: string): AbiMetadata;
  readAllArtifact(): Promise&lt;AbiMetadata[]&gt;;
  readAllArtifactSync(): AbiMetadata[];
  getArtifactPath(contractName: string): Promise&lt;string&gt;;
  getArtifactPathSync(contractName: string): string;
  artifactExists(contractName: string): Promise&lt;boolean&gt;;
  getArtifactPaths(): Promise&lt;string[]&gt;;
  copyToArtifactDir(paths: string[]): Promise&lt;void&gt;;
}
</code></pre>
<h4><a class="header" href="#artifactsreadartifact" id="artifactsreadartifact">artifacts.readArtifact</a></h4>
<p>Get the contract metadata by contract name, which returns a JSON object:</p>
<pre><code class="language-typescript">{
  metadataVersion: string;
  source: {
    hash: string;
    language: string;
    compiler: string;
    wasm: string;
  };
  contract: {
    name: string;
    version: string;
    authors: string[];
  };
  types: any[];
  spec: {
    constructors: any[];
    docs: any[];
    events: any[];
    messages: any[];
  };
}
</code></pre>
<p>where wasm is the wasm file compiled from the contract.</p>
<h4><a class="header" href="#artifactsreadartifactsync" id="artifactsreadartifactsync">artifacts.readArtifactSync</a></h4>
<p>Synchronized version of <code>artifacts.readArtifact</code>.</p>
<h4><a class="header" href="#artifactsreadallartifact" id="artifactsreadallartifact">artifacts.readAllArtifact</a></h4>
<p>Get the metadata of all contracts.</p>
<h4><a class="header" href="#artifactsreadallartifactsync" id="artifactsreadallartifactsync">artifacts.readAllArtifactSync</a></h4>
<p>Synchronized version of <code>artifacts.readAllArtifact</code>.</p>
<h4><a class="header" href="#artifactsgetartifactpath" id="artifactsgetartifactpath">artifacts.getArtifactPath</a></h4>
<p>Gets the path to the file that contains the metadata for the specified contract.</p>
<h4><a class="header" href="#artifactsgetartifactpathsync" id="artifactsgetartifactpathsync">artifacts.getArtifactPathSync</a></h4>
<p>Synchronized version of <code>artifacts.getArtifactPath</code>.</p>
<h4><a class="header" href="#artifactsartifactexists" id="artifactsartifactexists">artifacts.artifactExists</a></h4>
<p>Determines if a contract's metadata exists</p>
<h4><a class="header" href="#artifactsgetartifactpaths" id="artifactsgetartifactpaths">artifacts.getArtifactPaths</a></h4>
<p>Gets the file paths of the metadata for all contracts.</p>
<h4><a class="header" href="#artifactscopytoartifactdir" id="artifactscopytoartifactdir">artifacts.copyToArtifactDir</a></h4>
<p>Copies the file to the artifact directory</p>
<h1><a class="header" href="#console-1" id="console-1">Console</a></h1>
<p>Redspot provides a powerful console that allows developers to simply use commands and contracts to do operations, or call scripts located in the <code>scripts</code> directory to do mechanized repetitive work, etc.</p>
<p>Redspot's console has many other rich features.</p>
<ul>
<li>Provides <strong>powerful tab-completion</strong> capabilities</li>
<li>The console records command history, so developers can view the <code>cache/console-history.txt</code> file to get the history of executed commands, and also use the <code>↑</code> button to find the required history commands. In the future, the console will also provide shortcut keys to index history commands.</li>
</ul>
<h2><a class="header" href="#start-the-console" id="start-the-console">Start the console</a></h2>
<pre><code class="language-bash">$ npx redspot console
## If you are sure that the contract compiled in the ``artifacts`` directory meets your expectations, you can add the --no-compile argument to not compile the contract
$ npx redspot console --no-compile
</code></pre>
<p>If you run the <code>.help</code> command, you can see the corresponding help.</p>
<pre><code class="language-bash">&gt; .help
.break Sometimes you get stuck, this gets you out
.clear Alias for .break
.editor Enter editor mode
.exit Exit the repl
.help Print this help message
.load Load JS from a file into the REPL session
.save Save Save all evaluated commands in this REPL session to a file
&gt;Save 
</code></pre>
<h2><a class="header" href="#common-commands" id="common-commands">Common commands</a></h2>
<p>By default, the console imports components for contract interaction under the <code>redspot</code> library, such as</p>
<ul>
<li><code>patract</code></li>
<li><code>network</code> </li>
<li>...</li>
</ul>
<p>Consistent with the scripts in the <code>scripts</code> directory, these components can be used to invoke many functions, such as interacting with the contract, querying information, viewing the network, etc.</p>
<h3><a class="header" href="#common-workflows" id="common-workflows">Common workflows</a></h3>
<p>Example: You currently want to debug the erc20 contract. After the contract is compiled, you will see the <code>erc20.json</code> and <code>erc20.wasm</code> files in the <code>artifacts</code> directory. The operations related to loading the contract need to be marked by the file names here.</p>
<p>For example, if we emulate the <code>deploy.ts` deployment script in the </code>scripts` directory, we can execute the command to deploy the contract and call it directly from the console.</p>
<pre><code class="language-typescript">var factory = await patract.getContractFactory('erc20'); // erc20 is the same as the filename
var contract = await factory.deployed('new', 10000000); // upload the code and instantiate this contract
</code></pre>
<p>If the address of a contract is known and you want to load the contract instance first you can do so by.</p>
<pre><code class="language-typescript">var factory = await patract.getContractFactory('erc20'); // erc20 is the same as the filename
var contract = await factory.attach('16DHBsUan9GoedoTYJmbyBZJMmN39ZpKUPvYeAGMTXCgxLQe'); // load the contract address
</code></pre>
<p>At this point the <code>contract</code> object here is a well instantiated object. So subsequently you can use this <code>contract</code> object to interact with the contract directly, for example to call a transfer function.</p>
<pre><code class="language-typescript">var ret = await contract.transfer(&quot;15Jbynf3EcRqdHV1K14LXYh7PQFTbp5wiXfrc4kbMReR9KxA&quot;, 100)
ret.events // print the information of events
</code></pre>
<p>If it is to get the result of executing a method via an rpc call.</p>
<pre><code class="language-typescript">var ret = await contract.balanceOf(&quot;15Jbynf3EcRqdHV1K14LXYh7PQFTbp5wiXfrc4kbMReR9KxA&quot;)
ret.output.toString()
</code></pre>
<p>If this procedure is more fixed, the above commands can be written to a file in the <code>scripts</code> directory, e.g. named <code>scripts/do_something.ts</code>.</p>
<pre><code class="language-typescript">var factory = await patract.getContractFactory('erc20');
var contract = await factory.deployed('new', 10000000); 
var ret = await contract.transfer(&quot;15Jbynf3EcRqdHV1K14LXYh7PQFTbp5wiXfrc4kbMReR9KxA&quot;, 100)
ret.events
</code></pre>
<p>A series of processes can then be automated using the following command.</p>
<pre><code class="language-typescript">.load scripts/do_something.ts
</code></pre>
<p>So the console helper functions as follows.</p>
<p>! [](. /imgs/process.jpg)</p>
<h1><a class="header" href="#q--a" id="q--a">Q &amp; A</a></h1>
<h1><a class="header" href="#q--a-1" id="q--a-1">Q &amp; A</a></h1>
<h3><a class="header" href="#how-to-upgrade-redspot" id="how-to-upgrade-redspot">How to upgrade Redspot</a></h3>
<p>redspot is just a normal npm package. So it is upgraded in the same way as any other npm package.</p>
<p><code>npm upgrade</code> upgrades all dependencies</p>
<p><code>npm upgrade redspot</code> Upgrade only redspot</p>
<p>If you are using yarn</p>
<p><code>yarn upgrade-interactive --latest</code> to upgrade all dependencies to the stable version</p>
<p>You can manually change the version number in package.json and reinstall the dependencies directly</p>
<pre><code class="language-json">{
  &quot;name&quot;: &quot;erc20&quot;,
  &quot;version&quot;: &quot;0.1.0&quot;,
  &quot;private&quot;: true,
  &quot;dependencies&quot;: {
    &quot;@redspot/chai&quot;: &quot;^0.10.2-1&quot;,
    &quot;@redspot/gas-reporter&quot;: &quot;^0.10.2-1&quot;,
    &quot;@redspot/patract&quot;: &quot;^0.10.2-1&quot;,
    &quot;@types/chai&quot;: &quot;^4.2.14&quot;,
    &quot;@types/mocha&quot;: &quot;^8.0.3&quot;,
    &quot;chai&quot;: &quot;^4.2.0&quot;,
    &quot;redspot&quot;: &quot;^0.10.2-1&quot;,
    &quot;typescript&quot;: &quot;^4.0.2&quot;
  },
  &quot;scripts&quot;: {
    &quot;build&quot;: &quot;npx redspot compile&quot;,
    &quot;test&quot;: &quot;npx redspot test&quot;
  }
}
</code></pre>
<p>Note that it is best to upgrade all plugins to the latest version at the same time.</p>
<h3><a class="header" href="#cannot-call-the-contract-when-using-erc20-trait" id="cannot-call-the-contract-when-using-erc20-trait">Cannot call the contract when using erc20-trait</a></h3>
<p>Since erc20-trait has extra namespaces, you must also add namespaces when calling it. Example.</p>
<pre><code class="language-typescript">// erc20
contractFactory.deploy(&quot;new&quot;, &quot;1000000&quot;)
// erc20-trait
contractFactory.deploy(&quot;baseErc20,new&quot;, &quot;1000000&quot;)

// erc20
contract.query.balanceOf(someaddress)
// erc20-trait
contract.query[&quot;baseErc20,balanceOf&quot;](someaddress)

// erc20
contract.tx.transfer(receiver.address, 7))
// erc20-trait
contract.tx[&quot;baseErc20,transfer&quot;](receiver.address, 7))
</code></pre>
<h3><a class="header" href="#how-to-secure-the-private-key-online-and-avoid-uploading-to-github" id="how-to-secure-the-private-key-online-and-avoid-uploading-to-github">How to secure the private key online and avoid uploading to github</a></h3>
<p>You can use environment variables to configure account, e.g.</p>
<pre><code class="language-typescript">// redspot.config.ts
import { RedspotUserConfig } from 'redspot/types';


export default {
 ...
  network: {
    mainnet: {
      ...
      account: [process.env.ACCOUNT]
      ...
    ACCOUNT] ... }
  }
} as RedspotUserConfig;
</code></pre>
<p>Run the script.</p>
<pre><code class="language-bash">REDSPOT_NETWORK=mainnet ACCOUNT=&quot;//Alice&quot; npx redspot run . /scripts/deploy.ts
</code></pre>
<p>You can also use tools like <a href="https://github.com/motdotla/dotenv">dotenv </a>.</p>
<h1><a class="header" href="#plugins-1" id="plugins-1">Plugins</a></h1>
<p>The core functionality of Redspot includes the Redspot runtime environment and the tasks of compiling contracts, running tests, and running scripts.</p>
<p>Other functions such as test suites with contracts, contract interaction, accessing contracts, setting up different chain configurations, etc. are provided by plugins. Users can choose which plugins they want to use. Introducing a plugin is simple. Add it as an npm dependency. Then add to <code>redspot.config.ts</code>.</p>
<pre><code class="language-typescript">import { RedspotUserConfig } from 'redspot/types';
import '@redspot/patract'; // introduce the @redspot/patract plugin
import '@redspot/chai'; // import @redspot/chai plugin

export default {
 ...
} as RedspotUserConfig;
</code></pre>
<p>Here we introduce a few of the officially provided plugins.</p>
<h2><a class="header" href="#redspotpatract" id="redspotpatract">@redspot/patract</a></h2>
<p>This plugin extends the Redspot runtime environment and adds the patract attribute, which allows you to access patract instances like this.</p>
<pre><code class="language-typescript">import { patract } from 'redspot' 
</code></pre>
<p>The type definition of patract is as follows.</p>
<pre><code class="language-typescript">interface Patract {
     Contract: Contract;
     ContractFactory: ContractFactory;
    /**
     * Generating Contract Instance from Contract Addresses
     *
     * @param contractName Contract name
     * @param address contract address
     * @param signer The account used to sign, or the first account in the user configured if it is undefined.
     * @returns Contract Instance
     */
    getContractAt(
      contractName: string,
      address: AccountId | string,
      signer?: Signer
    ): Promise&lt;Contract&gt;;
    /**
     * Return the contract factory
     *
     * @param contractName Contract name
     * @param signer The account used to sign, or the first account in the user configured if it is undefined.
     * @returns Contract Factory Instance
     */
    getContractFactory(
      contractName: string,
      signer?: Signer
    ): Promise&lt;ContractFactory&gt;;
    /**
     * Generate a random account and transfer token to it
     *
     * @param from This account will be transferred to the new account
     * @param amount The amount transferred to the new account
     * @returns New Account
     */
    getRandomSigner(
      from?: Signer,
      amount?: BN | number | string | BigInt
    ): Promise&lt;Signer&gt;;
  
  };
</code></pre>
<h4><a class="header" href="#getrandomsignerfrom-amount-promisesigner" id="getrandomsignerfrom-amount-promisesigner"><code>getRandomSigner(from, amount): Promise&lt;Signer&gt;</code></a></h4>
<p>getRandomSigner is a utility function that creates a random signer to be generated and passes some initial amount to it from from.</p>
<h4><a class="header" href="#getcontractfactorycontractname-signer-promisecontractfactory" id="getcontractfactorycontractname-signer-promisecontractfactory"><code>getContractFactory(contractName, signer?): Promise&lt;ContractFactory&gt;</code></a></h4>
<p>This function will create an instance of contractFactory with the contract name and signer.</p>
<p>Note that the contract must have been compiled successfully. You can find the metadata file for this in artifacts.</p>
<h4><a class="header" href="#getcontractatcontractname-address-signer-promisecontract" id="getcontractatcontractname-address-signer-promisecontract"><code>getContractAt(contractName, address, signer): Promise&lt;Contract&gt;</code></a></h4>
<p>Creates a Contract instance with a contract name, contract address and signer.</p>
<p>Note that the contract must have been compiled successfully. You can find the metadata file for it in artifacts.</p>
<p>###ContractFactory</p>
<p>The ContractFactory is mainly used for contract deployment.</p>
<pre><code class="language-typescript">import { patract } from 'redspot'
const { getContractFactory, getRandomSigner } = patract;

const signers = await getSigners();
const contractFactory = await getContractFactory('erc20', signers[0]);
const contract = await contractFactory.deploy('new', '1000');
</code></pre>
<h4><a class="header" href="#new-contractfactoryaddress-contractmetadata-api-signer" id="new-contractfactoryaddress-contractmetadata-api-signer"><code>new ContractFactory(address, contractMetadata, api, signer) </code></a></h4>
<p>Create a contractFactory instance with contract address, metadata, api and signer.</p>
<h4><a class="header" href="#contractfactorydeployconstructororid---args--overrides--promisecontract" id="contractfactorydeployconstructororid---args--overrides--promisecontract"><code> contractFactory.deploy(constructorOrId, . . args[ , overrides ]): Promise&lt;Contract&gt;</code></a></h4>
<p>constructorOrId is the name of the contructor of the contract to be called. Note that for some contracts that use <code>trait</code>, the name of the contructor should be something like this.</p>
<pre><code class="language-typescript">const contract = await contractFactory.deploy('baseErc20,new', '1000');
</code></pre>
<p>args is the list of arguments you need to pass to the contructor you are using.</p>
<p>overrides are optional and can be used to specify gasLimit, value, signer, salt, etc.</p>
<pre><code class="language-typescript">const contract = await contractFactory.deploy('baseErc20,new', '1000', {
  gaslimit: '10000000000000000000000',
  salt: 'jkqwezlkwklqreqw',
  signer: signers[1],
  value: '32133210000000000000000000000'
});
</code></pre>
<p>gasLimit is the maximum gas value that can be used for this transaction.</p>
<p>salt is used to generate the address of the contract. The same contract address will be generated if the deployer, deployment parameters and salt are the same.</p>
<p>signer When creating a contractFactory, there is a signer parameter that is used for the default transaction signature. The signer item can override the default signature account.</p>
<p>value is the amount to be passed to the contract to be created.</p>
<p>Note that <code>@redspot/patract</code> will not handle numeric amount precision and needs to be handled by the user.</p>
<h4><a class="header" href="#contractfactorydeployedconstructororid--args--overrides--promisecontract" id="contractfactorydeployedconstructororid--args--overrides--promisecontract"><code>contractFactory.deployed(constructorOrId, . .args[ , overrides ]): Promise&lt;Contract&gt;</code></a></h4>
<p>This method is similar to <code>contractFactory.deploy</code>, the only difference is that <code>deployed</code> checks in advance if the contract address to be generated exists, and if it does, does not try to deploy it, but instead creates a <code>Contract</code> instance directly using that contract address.</p>
<h4><a class="header" href="#contractfactoryinstantiateconstructororid--args--overrides--promisecontractaddress" id="contractfactoryinstantiateconstructororid--args--overrides--promisecontractaddress"><code>contractFactory.instantiate(constructorOrId, . .args[ , overrides ]): Promise&lt;ContractAddress&gt;</code></a></h4>
<p>If wasm has been uploaded to the chain, you can call <code>contractFactory.instantiate</code> directly to instantiate the contract. It takes the same arguments as <code>deploy</code>, but returns the contract address.</p>
<h4><a class="header" href="#contractfactoryinstantiateconstructororid--args--overrides--promisecontractaddress-1" id="contractfactoryinstantiateconstructororid--args--overrides--promisecontractaddress-1"><code>contractFactory.instantiate(constructorOrId, . .args[ , overrides ]): Promise&lt;ContractAddress&gt;</code></a></h4>
<p>If wasm has been uploaded to the chain, you can call <code>contractFactory.instantiate</code> directly to instantiate the contract. It takes the same arguments as <code>deploy</code>, but returns the contract address.</p>
<h4><a class="header" href="#contractfactoryattachaddresscontract" id="contractfactoryattachaddresscontract"><code>contractFactory.attach(address):Contract</code></a></h4>
<p>Generates a <code>Contract</code> instance using the specified contract address</p>
<h4><a class="header" href="#contractfactoryconnectsigner-contractfactory" id="contractfactoryconnectsigner-contractfactory"><code>contractFactory.connect(signer): ContractFactory</code></a></h4>
<p>Create a new contractFactory instance with the specified signer</p>
<h3><a class="header" href="#contract-1" id="contract-1">Contract</a></h3>
<h4><a class="header" href="#new-contractaddress-contractmetadata-api-signer" id="new-contractaddress-contractmetadata-api-signer"><code>new Contract(address, contractMetadata, api, signer) </code></a></h4>
<p>Create a contractFactory instance with the contract address, contractMetadata, api and signer.</p>
<h4><a class="header" href="#contractquerymessagename-args-overrides" id="contractquerymessagename-args-overrides"><code>contract.query.MessageName(. .args[, overrides])</code></a></h4>
<p>Similar to in polkadotjs, contract.query[MessageName] can call <code>contracts.call</code> rpc. For example, in the erc20 contract, to get the account balance.</p>
<pre><code class="language-typescript">const result = await contract.query.balanceOf(someaddress)
</code></pre>
<p>The return value is of the following type.</p>
<pre><code class="language-typescript">export interface ContractCallOutcome {
    debugMessage: Text;
    gasConsumed: u64;
    output: Codec | null;
    result: ContractExecResultResult;
}
</code></pre>
<p>It is the same as in polkadotjs api-contract.</p>
<p>overrides are optional and can be used to specify gasLimit, value, etc.</p>
<pre><code class="language-typescript">const contract = await contract.query.balanceOf('baseErc20,new', '1000', {
	gasLimit：'1231231231233123123'
  value: '3213321000000000000000000'
  signer： signers[1]
});
</code></pre>
<p>gasLimit is the maximum amount of gas that can be used for this transaction.</p>
<p>salt is used to generate the address of the contract. The same contract address will be generated if the deployer, deployment parameters and salt are identical.</p>
<p>signer When creating a contractFactory, there is a signer parameter that is used for the default transaction signature. The signer item can override the default signature account.</p>
<p>value is the amount to be passed to the contract to be created.</p>
<p>Note that <code>@redspot/patract</code> will not handle numeric amount precision and needs to be handled by the user.</p>
<h4><a class="header" href="#contractfactorydeployedconstructororid--args--overrides--promisecontract-1" id="contractfactorydeployedconstructororid--args--overrides--promisecontract-1"><code>contractFactory.deployed(constructorOrId, . .args[ , overrides ]): Promise&lt;Contract&gt;</code></a></h4>
<p>This method is similar to <code>contractFactory.deploy</code>, the only difference is that <code>deployed</code> checks in advance if the contract address to be generated exists, and if it does, does not try to deploy it, but instead creates a <code>Contract</code> instance directly using that contract address.</p>
<h4><a class="header" href="#contractfactoryinstantiateconstructororid--args--overrides--promisecontractaddress-2" id="contractfactoryinstantiateconstructororid--args--overrides--promisecontractaddress-2"><code>contractFactory.instantiate(constructorOrId, . .args[ , overrides ]): Promise&lt;ContractAddress&gt;</code></a></h4>
<p>If wasm has been uploaded to the chain, you can call <code>contractFactory.instantiate</code> directly to instantiate the contract. It takes the same arguments as <code>deploy</code>, but returns the contract address.</p>
<h4><a class="header" href="#contractfactoryinstantiateconstructororid--args--overrides--promisecontractaddress-3" id="contractfactoryinstantiateconstructororid--args--overrides--promisecontractaddress-3"><code>contractFactory.instantiate(constructorOrId, . .args[ , overrides ]): Promise&lt;ContractAddress&gt;</code></a></h4>
<p>If wasm has been uploaded to the chain, you can call <code>contractFactory.instantiate</code> directly to instantiate the contract. It takes the same arguments as <code>deploy</code>, but returns the contract address.</p>
<h4><a class="header" href="#contractfactoryattachaddresscontract-1" id="contractfactoryattachaddresscontract-1"><code>contractFactory.attach(address):Contract</code></a></h4>
<p>Generates a <code>Contract</code> instance using the specified contract address</p>
<h4><a class="header" href="#contractfactoryconnectsigner-contractfactory-1" id="contractfactoryconnectsigner-contractfactory-1"><code>contractFactory.connect(signer): ContractFactory</code></a></h4>
<p>Create a new contractFactory instance with the specified signer</p>
<h3><a class="header" href="#contract-2" id="contract-2">Contract</a></h3>
<h4><a class="header" href="#new-contractaddress-contractmetadata-api-signer-1" id="new-contractaddress-contractmetadata-api-signer-1"><code>new Contract(address, contractMetadata, api, signer) </code></a></h4>
<p>Creates a contractFactory instance with the contract address, contractMetadata, api and signer.</p>
<h4><a class="header" href="#contractquerymessagename-args-overrides-1" id="contractquerymessagename-args-overrides-1"><code>contract.query.MessageName(. .args[, overrides])</code></a></h4>
<p>Similar to in polkadotjs, contract.query[MessageName] can call <code>contracts.call</code> rpc. For example, in the erc20 contract, to get the account balance.</p>
<pre><code class="language-typescript">const result = await contract.query.balanceOf(someaddress)
</code></pre>
<p>The return value is of the following type.</p>
<pre><code class="language-typescript">export interface ContractCallOutcome {
    debugMessage: Text;
    gasConsumed: u64;
    output: Codec | null;
    result: ContractExecResultResult;
}
</code></pre>
<p>It is the same as in polkadotjs api-contract.</p>
<p>overrides are optional and can be used to specify gasLimit, value, etc.</p>
<pre><code class="language-typescript">const contract = await contract.query.balanceOf('baseErc20,new', '1000', {
	gasLimit: '1231231231231233123123'
  value: '32133210000000000000000000000'
  signer: signers[1]
});
</code></pre>
<p>gasLimit value refers to the gasLimit and value in the <code>contracts.call</code> rpc. signer can specify the origin address of <code>contracts.call</code>.</p>
<h4><a class="header" href="#contractoptimizegasmessagename--args-overrides" id="contractoptimizegasmessagename--args-overrides"><code>contract.optimizeGas.MessageName(.. . args[, overrides])</code></a></h4>
<p>This function is similar to <code>contract.query.MessageName</code>, but the return value is the estimated gas to be consumed</p>
<pre><code class="language-typescript">const result = await contract.estimateGas.balanceOf(someaddress)
result // BN(232130000000)
</code></pre>
<h4><a class="header" href="#contracttxmessagename-argsoverrides" id="contracttxmessagename-argsoverrides"><code>contract.tx.MessageName(. .args[,overrides])</code></a></h4>
<p>With <code>contract.tx.MessageName</code> you can execute the contract's transactions. For example.</p>
<pre><code class="language-typescript">const result = await contract.tx.transfer(someddress, 7)
</code></pre>
<p>Unlike polkadotjs, this function returns a promise that will wait until the transaction is up, or until an error occurs before it is resolved.</p>
<p>The return value type is as follows.</p>
<pre><code class="language-typescript">export interface TransactionResponse {
  from: string;
  txHash?: string;
  blockHash?: string;
  error?: {
    message?: any;
    data?: any;
  };
  result: SubmittableResult;
  events?: DecodedEvent[];
}

export interface DecodedEvent {
  args: Codec[];
  name: string;
  event: AbiEvent;
}
</code></pre>
<p>You can get the events of the parsed contract directly via <code>result.events</code>. If the execution goes wrong, you can get the error message via <code>result.error.message</code>.</p>
<p>overrides are optional and can be used to specify gasLimit, value, signer, etc.</p>
<pre><code class="language-typescript">const contract = await contract.tx.transfer(someddress, 7, {
  gasLimit: '1231231231231233123123'
  value: '32133210000000000000000000000'
  signer: signers[1]
});
</code></pre>
<p>gasLimit refers to the maximum value of gas that can be used for this transaction.</p>
<p>value refers to the amount to be passed to the contract to be created.</p>
<p>signer is used to override the default signer.</p>
<h4><a class="header" href="#contractattachaddress-contract" id="contractattachaddress-contract"><code>contract.attach(address): Contract</code></a></h4>
<p>Generates a <code>Contract</code> instance using the specified contract address</p>
<h4><a class="header" href="#contractconnectsigner-contractfactory" id="contractconnectsigner-contractfactory"><code>contract.connect(signer): contractFactory</code></a></h4>
<p>Create a new contract instance with the specified signer</p>
<h2><a class="header" href="#redspotchai" id="redspotchai">@redspot/chai</a></h2>
<p>This plugin provides a set of matchers for writing contract test cases, inspired by <a href="https://ethereum-waffle.readthedocs.io/en/latest/matchers.html">waffle</a>.</p>
<p>Introducing @redspot/chai. This plugin will automatically modify the chai matchers without having to call them manually.</p>
<pre><code>// redspot.config.ts

import { RedspotUserConfig } from 'redspot/types';
import '@redspot/chai'; 

export default {
 ...
} as RedspotUserConfig;
</code></pre>
<p>For a full example of using @redspot/chai.</p>
<pre><code class="language-typescript">import BN from 'bn.js';
import { expect } from 'chai';
import { patract, network, artifacts } from 'redspot';

const { getContractFactory, getRandomSigner } = patract;

const { api, getSigners } = network;

describe('ERC20', () =&gt; {
  after(() =&gt; {
    return api.disconnect();
  });

  async function setup() {
    const one = new BN(10).pow(new BN(api.registry.chainDecimals[0]));
    const signers = await getSigners();
    const Alice = signers[0];
    const sender = Alice;
    const contractFactory = await getContractFactory('erc20', sender);
    const contract = await contractFactory.deploy('new', '1000');
    const abi = artifacts.readArtifact('erc20');
    const receiver = await getRandomSigner();

    return { sender, contractFactory, contract, abi, receiver, Alice, one };
  }

  it('Assigns initial balance', async () =&gt; {
    const { contract, sender } = await setup();
    const result = await contract.query.balanceOf(sender.address);
    expect(result.output).to.equal(1000);
  });

  it('Transfer adds amount to destination account', async () =&gt; {
    const { contract, receiver } = await setup();
    await expect(() =&gt;
      contract.tx.transfer(receiver.address, 7)
    ).to.changeTokenBalance(contract, receiver, 7);

    await expect(() =&gt;
      contract.tx.transfer(receiver.address, 7)
    ).to.changeTokenBalances(contract, [contract.signer, receiver], [-7, 7]);
  });

  it('Transfer emits event', async () =&gt; {
    const { contract, sender, receiver } = await setup();

    await expect(contract.tx.transfer(receiver.address, 7))
      .to.emit(contract, 'Transfer')
      .withArgs(sender.address, receiver.address, 7);
  });

  it('Can not transfer above the amount', async () =&gt; {
    const { contract, receiver } = await setup();

    await expect(contract.tx.transfer(receiver.address, 1007)).to.not.emit(
      contract,
      'Transfer'
    );
  });

  it('Can not transfer from empty account', async () =&gt; {
    const { contract, Alice, one, sender } = await setup();

    const emptyAccount = await getRandomSigner(Alice, one.muln(10000));

    await expect(
      contract.tx.transfer(sender.address, 7, {
        signer: emptyAccount
      })
    ).to.not.emit(contract, 'Transfer');
  });
});

</code></pre>
<p>There are more built-in uses for chai, see the chai documentation: https://www.chaijs.com/.</p>
<h3><a class="header" href="#equal" id="equal">equal</a></h3>
<p>@redspot/chai will modify the default equal match. The default equal does not support matching objects. But @redspot/chai can.</p>
<pre><code class="language-typescript">expect(new BN(1000)).to.equal(1000) // true
expect(AccountId).to.equal('5Gdjkw....') // true
expect(Uint8Array([1,2,3])).to.equal('0x010203') // true
</code></pre>
<p>For BN types, equal to call <code>new BN(expected).eq(actual)</code> to determine if it is equal</p>
<p>For types defined in polkadotjs, equal calls <code>Type.eq(actual)</code> to determine if they are equal</p>
<p>For uint8Array types, equal converts them all to hex and then compares them for equality</p>
<p>For other types, the default method of determining equality is used</p>
<h3><a class="header" href="#changetokenbalance" id="changetokenbalance">changeTokenBalance</a></h3>
<p>This matcher detects changes in the balance of erc20 and internally calls the balanceOf interface to determine the balance. Since the erc20-trait interface for getting balance is <code>baseErc20,balanceOf</code> </p>
<p>so it does not apply to erc20-trait.</p>
<pre><code class="language-typescript">await expect(() =&gt;
  contract.tx.transfer(receiver.address, 7)
).to.changeTokenBalance(contract, receiver, 7);

await expect(() =&gt;
  contract.tx.transfer(receiver.address, 7)
).to.changeTokenBalances(contract, [contract.signer, receiver], [-7, 7]);
</code></pre>
<h3><a class="header" href="#emit" id="emit">emit</a></h3>
<p>This matcher detects if the contract emits an event, e.g. to detect if a Transfer event has been emitted.</p>
<pre><code class="language-typescript">await expect(contract.tx.transfer(receiver.address, 7))
    .to.exit(contract, 'Transfer')
</code></pre>
<p>Detects if the event contains the specified parameters.</p>
<pre><code class="language-typescript">await expect(contract.tx.transfer(receiver.address, 7))
    .to.exit(contract, 'transfer')
    .withArgs(sender.address, receiver.address, 7);
</code></pre>
<p>Not expecting to emit events</p>
<pre><code class="language-typescript">await expect(
  contract.tx.transfer(sender.address, 7, {
    signer: emptyAccount
  })
).to.not.exit(contract, 'Transfer');

</code></pre>
<h2><a class="header" href="#redspotgas-reporter" id="redspotgas-reporter">@redspot/gas-reporter</a></h2>
<p>The plugin prints out the gas usage of the transaction for the called contract when the test completes at</p>
<p>! <a href="https://user-images.githubusercontent.com/7029338/101343840-7700ab00-38e9-11eb-80a0-c6b6d38a9640.png"></a></p>
<p>As with @redspot/chai, just add to redspot.config.ts, after introducing @redspot/gas-reporter, the following.</p>
<pre><code>// redspot.config.ts

import { RedspotUserConfig } from 'redspot/types';
import '@redspot/gas-reporter'; 

export default {
 ...
} as RedspotUserConfig;
</code></pre>
<p>which is ready to run automatically.</p>
<h1><a class="header" href="#redspotchai-1" id="redspotchai-1">@redspot/chai</a></h1>
<h1><a class="header" href="#redspotgas-reporter-1" id="redspotgas-reporter-1">@redspot/gas-reporter</a></h1>
<h1><a class="header" href="#redspotpatract-1" id="redspotpatract-1">@redspot/patract</a></h1>
<h1><a class="header" href="#europa" id="europa">Europa</a></h1>
<p>Europa is a sandbox environment for running <code>FRAME Contracts pallet</code> and **simulating nodes. It is also a framework for running Substrate runtime.</p>
<ol>
<li>When Europa is used as a sandbox for contract debugging, Europa modified the <code>FRAME Contracts pallet</code> module to track the contract execution process, which can provide contract developers with richest contract execution information to allow contract execution The process is no longer a black box**, helping contract developers to debug Wasm contracts;</li>
<li>When using Europa as the framework of Substrate, you can do Substrate Runtime development (mostly used for experimental functions) without being disturbed by Wasm compilation problems.</li>
</ol>
<h2><a class="header" href="#as-the-framework-of-substrate-runtime" id="as-the-framework-of-substrate-runtime">As the framework of Substrate runtime</a></h2>
<ol>
<li>
<p>Europa removed some unnecessary functional modules, such as WASM executor, p2p, etc., and only retained the native execution environment.</p>
</li>
<li>
<p>The block generation method of <code>manual_seal</code> is used (the block generation is triggered when a new transaction is received), so that developers do not have to be affected by consensus block generation, and can focus more on contract development, debugging and log analysis.</p>
</li>
<li>
<p>The <code>state-kv</code> database is provided, which records the state changes of each block.</p>
<pre><code class="language-bash"># print the modified state kvs for block 1
$ ./target/debug/europa state-kv 1 -d europa_database
Nov 12 15:53:27.699 INFO modified state for block:0x6c119a8f7de42e330aca8b9d3587937aacbbc203cc21650b60644c2f2d33e7fb
Nov 12 15:53:27.699 INFO key:26aa394eea5630e07c48ae0c9558cef702a5c1b19ab7a04f536c519aca4983ac|value:[DELETED]
Nov 12 15:53:27.699 INFO key:26aa394eea5630e07c48ae0c9558cef70a98fdbe9ce6c55837576c60c7af3850|value:05000000
# ...
</code></pre>
</li>
<li>
<p>In addition to providing the basic rpc in the Substrate framework, Europa also has some special rpc:</p>
<ul>
<li><code>europa_forwardToHeight (params: [height: NumberOf&lt;B&gt;])</code>: Fast forward the block to the specified height, which is very helpful for testing functions related to the block height.</li>
<li><code>europa_backwardToHeight (params: [height: NumberOf&lt;B&gt;])</code>: Return the block to the specified height, mainly used to restore the state.</li>
<li><code>europa_modifiedStateKvs (params: [number_or_hash: NumberOrHash&lt;B&gt;])</code>: Provide block height or block hash, query the state change in the corresponding block.</li>
</ul>
</li>
<li>
<p>In addition to using the optional command of <code>-d/--base-path</code> to divide different working directories, Europa can also use <code>-w/--workspace</code> to declare different workspaces under the working directory.</p>
</li>
</ol>
<h2><a class="header" href="#as-a-sandbox-environment-for-frame-contracts-pallet" id="as-a-sandbox-environment-for-frame-contracts-pallet">As a sandbox environment for <code>FRAME Contracts pallet</code></a></h2>
<p>When developing contracts, Europa provides developers with <strong>more detailed log information</strong> to assist contract developers in locating problems, including contracts execution logs and wasm execution stacks. At the same time, this sandbox environment also has the functions of the aforementioned Europa framework. For example, you can use rpc such as <code>europa_forwardToHeight</code> to control the execution of the contract.</p>
<p>Contract errors may appear in three places: the <code>ink!</code> layer, the internal business logic of the contract, and the <code>pallet_contracts</code> layer. With these detailed logs, developers can quickly locate problems during debugging, especially in the case of mutual calls between contracts, Europa can greatly improve the development experience.</p>
<p>Currently, there are two custom ChainExtensions available on Europa, namely Contract logger and ZKP feature.</p>
<h2><a class="header" href="#focus-of-this-chapter" id="focus-of-this-chapter">Focus of this chapter</a></h2>
<p>Since the main focus of this book is Substrate's Wasm contract, the Europa-related introductions in the following chapters are all related to the use of Europa contract debugging.</p>
<h1><a class="header" href="#europa-tutorial" id="europa-tutorial">Europa tutorial</a></h1>
<p>Europa is a simulated node sandbox environment with contract functions, and its interface (mainly rpc) is compatible with most third-party tools, so Europa can be regarded as an independent node for operation.</p>
<h2><a class="header" href="#set-up-development-environment" id="set-up-development-environment">Set up development environment</a></h2>
<p>The environment of Europa is the same as the environment of normal use of node debugging contracts. The only difference is that if you need to print the backtrace of Wasm, you need to use a fork version of <code>cargo-contract</code> provided by Patract until parity (official)<code>cargo- contract</code> before merging the features submitted by Patract. If you don't need to print the Wasm backtract when the contract execution crashes, just use the official <code>cargo-contract</code>.</p>
<ul>
<li>
<p>Compile and run Europa node</p>
<pre><code class="language-bash">$ git clone --recurse-submodules https://github.com/patractlabs/europa.git
## or do following commands
$ git clone https://github.com/patractlabs/europa.git
$ cd europa/vendor
$ git submodule update --init --recursive
</code></pre>
<p>You can also install Europa directly using <code>cargo install</code>. (Note to add <code>--locked</code> to use the Substrate version that Europa currently depends on)</p>
<pre><code class="language-bash">$ cargo install europa --git=https://github.com/patractlabs/europa.git --force --locked
</code></pre>
<p>Run Europa:</p>
<pre><code class="language-bash">$ ./target/release/europa --log=runtime=debug -d ./europa_database
# If there is no need to retain data, you can also use `--tmp` to run Europa
$ ./target/release/europa --log=runtime=debug --tmp
</code></pre>
</li>
<li>
<p>Install <a href="https://github.com/patractlabs/cargo-contract">PatractLabs's <code>cargo-contract</code></a> (optional, only needed if the Wasm contract executes backtrace when it crashes)</p>
<pre><code>$ cargo install cargo-contract --git https://github.com/patractlabs/cargo-contract --branch=v0.10.0 --force
</code></pre>
<p>If the developer has installed the official <code>cargo-contract</code> and does not want to overwrite the installation, you can use manual compilation:</p>
<pre><code class="language-bash">$ git clone https://github.com/patractlabs/cargo-contract --branch=v0.10.0
$ cd cargo-contract
$ cargo build --release
</code></pre>
</li>
<li>
<p>Compile contract</p>
<p>The <code>--debug</code> option is provided by Patract's <code>cargo-contract</code>. If you use the <code>cargo-contract</code> provided by parity, you do not need the <code>--debug</code> option in the following commands.</p>
<pre><code class="language-bash">$ cargo-contract build --debug
# or
$ cargo +nightly contract build --debug
</code></pre>
<p><code>-d/--debug</code> can <strong>replace</strong> the original <code>*.wasm</code> and <code>*.contract</code> files in the <code>target/ink</code> directory. The replaced Wasm and Contract files close the compilation process Code optimization conditions, and include the &quot;name section&quot; part to help analyze the information of the wasm call stack.</p>
<blockquote>
<p>If the contract is compiled without using the <code>cargo-contract</code> in the Patract warehouse and carrying the <code>-d/--debug</code> parameter when compiling the contract, the following log may appear when a wasm panic occurs during the execution of the contract:</p>
<pre><code>wasm_error: Error::WasmiExecution(Trap(Trap {kind: Unreachable }))
wasm backtrace:
| &lt;unknown&gt;[...]
| &lt;unknown&gt;[...]
╰─&gt;&lt;unknown&gt;[...]
</code></pre>
</blockquote>
<blockquote>
<p>The compiled product produced after adding <code>-d/--debug</code> is generally several hundred times larger than the original product (for example, the original product 2.5k, the new product 700k), because the new product is not optimized and retains a lot of debugging information. Therefore, the developer can roughly determine whether it is the product after adding the <code>-d/--debug</code> option by the product size.</p>
</blockquote>
</li>
</ul>
<h2><a class="header" href="#deploy-contract" id="deploy-contract">Deploy contract</a></h2>
<p>Developers can use <a href="https://redspot.patract.io/zh-CN/tutorial/">Redspot</a> or <a href="https://polkadot.js.org/apps/#/explorer">Substrate Protal</a> to deploy contracts .</p>
<p>Note that Europa's <code>extending types</code> are as follows:</p>
<pre><code class="language-json">{
  &quot;LookupSource&quot;: &quot;MultiAddress&quot;,
  &quot;Address&quot;: &quot;MultiAddress&quot;
}
</code></pre>
<p>For example, use Redspot to deploy, use apps to execute transactions and view status.</p>
<p>Redspot deploys a contract:</p>
<pre><code class="language-bash">$ npx redspot run scripts/deploy.js
</code></pre>
<p>Get the successfully deployed contract address, and add an existing contract to apps:</p>
<p><img src="europa/./imgs/add_exist.png" alt="add_exist" /></p>
<h2><a class="header" href="#analysis-log" id="analysis-log">Analysis log</a></h2>
<p>In the process of deploying and executing the contract using Europa, the following detailed information will be printed. This information is the information in the execution of the contract, which can conveniently help developers locate problems in the contract. With this information, the execution process of the contract is no longer a black box.</p>
<p>Examples of log printing effects:</p>
<pre><code class="language-bash">1: NestedRuntime {
    ext_result: [success] ExecReturnValue { flags: 0, data:  },
    caller: d43593c715fdd31c61141abd04a99fd6822c8558854ccde39a5684e7a56da27d (5GrwvaEF...),
    self_account: 0144d6fc570d7bddda6f8e36141f179cd172324599b556ef514193f3105865f6 (5C6NMXaS...),
    selector: 0x9bae9d5e,
    args: 0x40420f00000000000000000000000000,
    value: 10000000000000000,
    gas_limit: 200000000000,
    gas_left: 190018947968,
    env_trace: [
        seal_input(Some(0x9bae9d5e40420f00000000000000000000000000)),
        seal_caller(Some(0xd43593c715fdd31c61141abd04a99fd6822c8558854ccde39a5684e7a56da27d)),
        ...
       seal_set_storage((Some(0x0300000001000000000000000000000000000000000000000000000000000000), Some(0x000000000000000000000000))),
    ],
    sandbox_result_ok: Value(
        I32(
            0,
        ),
    ),
    nest: [],
}
</code></pre>
<h3><a class="header" href="#contract-execution-log" id="contract-execution-log">Contract execution log</a></h3>
<p>For the log cases listed above, we can simply analyze the following information:</p>
<ul>
<li><code>ext_result</code>: It can surface the execution result of this contract call execution (call through transaction and rpc call belong to contract call);</li>
<li><code>caller</code>: The public key of the caller is displayed, and the contract calling contract is the public key of the parent contract (consistent with the EVM model);</li>
<li><code>self_account</code>: The address of this contract on the surface;</li>
<li><code>selector</code>: The selector of the method being called. Through this attribute, it can be judged which method of the contract is called this time;</li>
<li><code>args</code>, <code>value</code>, <code>gas_limit</code>, <code>gas_limit</code>, etc. indicate the relevant parameters and gas consumption of this execution;</li>
<li><code>env_trace</code> and <code>sandbox_result_ok</code>: surface the interaction information between contract Wasm execution and <code>pallet-contracts</code>, and the final result of Wasm executor (Wasm executor result and contract execution result are different concepts)</li>
<li><code>nest</code>: Describes the relationship between the contract calling the contract. Since this is empty, it appears that this call only involves the execution of one contract. See the following text for details;</li>
</ul>
<p>It can be seen that the contract log provided by Europa can clearly surface many detailed information in a contract call. If the developer of the contract has a better understanding of the contract module <code>pallet-contracts</code>, a lot of important debugging information can be obtained to assist in locating contract problems. If the contract developer knows less about the contract module, information such as <code>selector</code>, <code>caller</code>, <code>nest</code>, etc. can also bring great help to the contract development process and reduce the time for debugging the contract.</p>
<p>**Note that when viewing messages in contracts on apps, apps will automatically call the read-only messages of the contract to obtain some values ​​of the current contract, causing Europa to display some logs of read calls, which interferes with normal judgment. Therefore, developers need to distinguish clearly which log is what they need. ** If you use a third-party client that sends requests that can be controlled by yourself, there is no concern in this regard.</p>
<blockquote>
<p>When the developer uses apps to send a request, he identifies the small tip that needs to be logged in Europa:</p>
<p><code>1: NestedRuntime {}</code> There is a <code>selector</code> field under the block, which indicates the selector used for this contract execution. Developers can find out what the selector corresponding to the currently called method name is in the <code>messages</code> section of metadata.json, for example:</p>
<pre><code class="language-json">&quot;messages&quot;: [
    {
      &quot;name&quot;: [
        &quot;flip&quot;
      ],
      &quot;selector&quot;: &quot;0x633aa551&quot;
    }
]
</code></pre>
<p>Therefore, you can compare the <code>selector</code> field with the <code>selector</code> in the log to determine the part of the log corresponding to the current contract call issued through apps.</p>
</blockquote>
<h3><a class="header" href="#wasmi-panic-backtrace" id="wasmi-panic-backtrace">wasmi panic backtrace</a></h3>
<p>Suppose the method of writing a contract in <code>ink!</code> is as follows:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[ink(message)]
pub fn transfer(&amp;mut self, to: AccountId, value: Balance) -&gt; Result&lt;()&gt; {
    let from = self.env().caller();
    self.transfer_from_to(from, to, value)?;
    panic!(&quot;123&quot;);
    Ok(())
}
<span class="boring">}
</span></code></pre></pre>
<p>When this method is called, EuropThe following log will be printed in a (please note that the current contract needs to use Patract's <code>cargo-contract</code> to print Wasm's Backtrace):</p>
<pre><code class="language-bash">1: NestedRuntime {
	ext_result: [failed] ExecError { error: DispatchError::Module {index:5, error:17, message: Some(&quot;ContractTrapped&quot;), orign: ErrorOrigin::Caller }}
    caller: d43593c715fdd31c61141abd04a99fd6822...(5GrwvaEF...),
    self_account: b6484f58b7b939e93fff7dc10a654af7e.... (5GBi41bY...),
    selector: 0xfae3a09d,
    args: 0x1cbd2d43530a44705ad088af313e18f80b5....,
    value: 0,
    gas_limit: 409568000000,
    gas_left: 369902872067,
    env_trace: [
        seal_value_transferred(Some(0x00000000000000000000000000000000)),
        seal_input(Some(0xfae3a09d1cbd.....)),
        seal_get_storage((Some(0x0100000000000....), Some(0x010000000100000001000000))),
        # ...
        seal_caller(Some(0xd43593c715fdd31c61141abd...)),
        seal_hash_blake256((Some(0x696e6b20686173....), Some(0x0873b31b7a3cf....))),
      	# ...  
        seal_deposit_event((Some([0x45726332303a....00000000000]), Some(0x000..))),
    ],
	trap_reason: TrapReason::SupervisorError(DispatchError::Module { index: 5, error: 17, message: Some(&quot;ContractTrapped&quot;) }),
    wasm_error: Error::WasmiExecution(Trap(Trap { kind: Unreachable }))
        wasm backtrace: 
        |  core::panicking::panic[28]
        |  erc20::erc20::_::&lt;impl erc20::erc20::Erc20&gt;::transfer[1697]
        |  &lt;erc20::erc20::_::__ink_Msg&lt;[(); 2644567034]&gt; as ink_lang::traits::MessageMut&gt;::CALLABLE::{{closure}}[611]
        |  core::ops::function::FnOnce::call_once[610]
        |  &lt;erc20::erc20::_::_::__ink_MessageDispatchEnum as ink_lang::dispatcher::Execute&gt;::execute::{{closure}}[1675]
        |  ink_lang::dispatcher::execute_message_mut[1674]
        |  &lt;erc20::erc20::_::_::__ink_MessageDispatchEnum as ink_lang::dispatcher::Execute&gt;::execute[1692]
        |  erc20::erc20::_::&lt;impl ink_lang::contract::DispatchUsingMode for erc20::erc20::Erc20&gt;::dispatch_using_mode[1690]
        |  call[1691]
        ╰─&gt;&lt;unknown&gt;[2387]
    ,
    nest: [],
}
</code></pre>
<p>From Europa's log, we can analyze the following calling process:</p>
<pre><code class="language-bash">call -&gt; dispatch_using_mode -&gt; ... -&gt; transfer -&gt; panic
</code></pre>
<p>Therefore, the contract developer can locate the cause of the panic because of the occurrence of the panic in the transfer function.</p>
<p>The above is a simple log analysis description, more special cases will be introduced in the following &quot;Examples&quot; chapter.</p>
<h2><a class="header" href="#custom-chainextensions" id="custom-chainextensions">Custom ChainExtensions</a></h2>
<h3><a class="header" href="#ink-logger" id="ink-logger">ink logger</a></h3>
<p>Check <a href="https://github.com/patractlabs/ink-log">ink-log</a>.</p>
<h3><a class="header" href="#zkp-feature" id="zkp-feature">ZKP feature</a></h3>
<p>Check <a href="https://github.com/patractlabs/zkMega">zkMega</a>, related contract example <a href="https://github.com/patractlabs/metis/tree/master/groth16">metis/groth16</a>.</p>
<h1><a class="header" href="#europa-contract-execution-log-information-interpretation" id="europa-contract-execution-log-information-interpretation">Europa contract execution log information interpretation</a></h1>
<p>The structure for recording contract execution information in the current Europa <code>pallet-contract</code> is as follows. The notes briefly explain the information that each attribute represents:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Record the contract execution context.
pub struct NestedRuntime {
	/// Current depth
    depth: usize,
	/// The current contract execute result
	ext_result: ExecResultTrace,
	/// The value in sandbox successful result
	sandbox_result_ok: Option&lt;ReturnValue&gt;,
	/// Who call the current contract
    caller: AccountId32,
	/// The account of the current contract
    self_account: Option&lt;AccountId32&gt;,
	/// The input selector
    selector: Option&lt;HexVec&gt;,
	/// The input arguments
    args: Option&lt;HexVec&gt;,
	/// The value in call or the endowment in instantiate
    value: u128,
	/// The gas limit when this contract is called
    gas_limit: Gas,
	/// The gas left when this contract return
    gas_left: Gas,
	/// The host function call stack
    env_trace: EnvTraceList,
	/// The error in wasm
    wasm_error: Option&lt;WasmErrorWrapper&gt;,
	/// The trap in host function execution
    trap_reason: Option&lt;TrapReason&gt;,
	/// Nested contract execution context
    nest: Vec&lt;NestedRuntime&gt;,
}
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#log-example-corresponding-to-this-structure" id="log-example-corresponding-to-this-structure">Log example corresponding to this structure:</a></h2>
<pre><code class="language-bash">1: NestedRuntime {
    ext_result: [success] ExecReturnValue { flags: 0, data:  },
    caller: d43593c715fdd31c61141abd04a99fd6822c8558854ccde39a5684e7a56da27d (5GrwvaEF...),
    self_account: 0144d6fc570d7bddda6f8e36141f179cd172324599b556ef514193f3105865f6 (5C6NMXaS...),
    selector: 0x9bae9d5e,
    args: 0x40420f00000000000000000000000000,
    value: 10000000000000000,
    gas_limit: 200000000000,
    gas_left: 190018947968,
    env_trace: [
        seal_input(Some(0x9bae9d5e40420f00000000000000000000000000)),
        seal_caller(Some(0xd43593c715fdd31c61141abd04a99fd6822c8558854ccde39a5684e7a56da27d)),
        ...
       seal_set_storage((Some(0x0300000001000000000000000000000000000000000000000000000000000000), Some(0x000000000000000000000000))),
    ],
    sandbox_result_ok: Value(
        I32(
            0,
        ),
    ),
    nest: [],
}
</code></pre>
<h2><a class="header" href="#log-field-description" id="log-field-description">Log field description:</a></h2>
<ul>
<li>
<p><code>1: NestedRuntime</code>: The contract execution log with a call depth of 1.</p>
</li>
<li>
<p><code>ext_result</code>: The execution result of the contract at the <code>pallet-contract</code> level, there are two cases: <code>[success]</code> and <code>[failed]</code>.</p>
<ul>
<li><code>[success]</code> can only indicate that the execution was successful at the <code>pallet-contract</code> level, but the business logic of the contract itself may throw an Error. The data value in <code>ExecResultValue {flag:0, data: 0x...}</code> may be the return value of the contract, or the enumeration value of Error defined in the contract.</li>
<li><code>[failed]</code> will be followed by an <code>ExecError {.. }</code>, the error message is defined in <code>pallet-contracts</code>.</li>
</ul>
</li>
<li>
<p><code>caller</code>: The caller of the contract, which may be a user or another contract account. When the value is <code>0x000...</code>, it is called by rpc.</p>
</li>
<li>
<p><code>self_account</code>: The current contract account.</p>
</li>
<li>
<p><code>selector</code>: The function identifier passed to the contract, and the corresponding relationship can be queried in the contract's metadata.json.</p>
</li>
<li>
<p><code>args</code>: The parameters passed to the contract calling function.</p>
</li>
<li>
<p><code>value</code>: transfer amount to the current contract.</p>
</li>
<li>
<p><code>gas_limit</code>: The maximum amount of gas that can be used by the current contract.</p>
</li>
<li>
<p><code>gas_left</code>: The amount of gas remaining when exiting the current contract.</p>
</li>
<li>
<p><code>env_trace</code>: During the execution of the current contract, the call stack of host_function gives the parameters of each function in detail. Take <code>seal_call</code> as an example. If input is Some(xxx) and output is None, then there may be an error in the process of calling each other between the contracts.</p>
</li>
<li>
<p><code>trap_reason</code>: The reason for trap encountered during host_function execution.</p>
<ul>
<li>Return &amp; Termination &amp; Restoration: It is the normal exit strategy executed by the contract, not Error.</li>
<li>SupervisorError: DispatchError defined in <code>pallet_contracts</code>.</li>
</ul>
</li>
<li>
<p><code>wasm_error</code>: If a wasm execution error occurs in the contract, the wasm call stack will be printed in this field. If and only if <code>ext_result</code> is <code>[failed]</code>.</p>
</li>
<li>
<p><code>sandbox_result_ok</code>: If there is no <code>trap</code> and no <code>wasm_error</code> during the execution of host_function, then the contract is considered to be executed successfully and this field is printed. This field carries a <code>ReturnValue</code> information. In <code>ink!</code>, if the value returned is not 0, then an Error defined in <code>ink!</code> may have occurred, and the corresponding [<code>DispatchError</code>] needs to be queried. (https://github.com/paritytech/ink/blob/abd5cf14c0883cb2d5acf81f2277aeec330aa843/crates/lang/src/error.rs#L66-L80).</p>
</li>
<li>
<p><code>nest</code>: The contract log of nested calls. If the current contract calls other contracts, the execution log of the called contract will be nested in this field.</p>
<p>For a detailed explanation of this part, please refer to the subsequent chapter &quot;Contract Nested Call&quot;.</p>
</li>
</ul>
<h2><a class="header" href="#contract-nested-call" id="contract-nested-call">Contract nested call</a></h2>
<p>The logs of the mutual calls between the contracts are as follows:</p>
<ul>
<li>In contract A, call contract C after calling contract B</li>
</ul>
<p><img src="europa/./imgs/call_other_1.png" alt="call_other_1" /></p>
<p>The log is as follows:</p>
<pre><code class="language-bash">1: NestedRuntime {
	self_account: A,
	nest:[
		2: NestedRuntime {
			self_account: B,
			nest:[],
		},
		2: NestedRuntime {
			self_account: C,
			nest:[],
		}
	]
}
</code></pre>
<ul>
<li>In contract A, call contract B, in contract B, call contract C</li>
</ul>
<p><img src="europa/./imgs/call_other_2.png" alt="call_other_2" /></p>
<p>The log is as follows:</p>
<pre><code class="language-bash">1: NestedRuntime {
	self_account: A,
	nest:[
		2: NestedRuntime {
			self_account: B,
			nest:[
				3: NestedRuntime {
				self_account: C,
				nest:[],
			}
			],
		}  
	]
}
</code></pre>
<h1><a class="header" href="#europa-debugging-example" id="europa-debugging-example">Europa debugging example</a></h1>
<h2><a class="header" href="#duplicate-topics" id="duplicate-topics">Duplicate topics</a></h2>
<ol>
<li>
<p>checkout <code>ink!</code> to commit <code>8e8fe09565ca6d2fad7701d68ff13f12deda7eed</code></p>
<pre><code class="language-bash">$ cd ink
$ git checkout 8e8fe09565ca6d2fad7701d68ff13f12deda7eed -b tmp
</code></pre>
</li>
<li>
<p>In <code>ink/examples/erc20/lib.rs:L90</code>, in the <code>Transfer</code> event, change the value to <code>0_u128</code></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[ink(constructor)]
pub fn new(initial_supply: Balance) -&gt; Self {
     //...
     Self::env().emit_event(Transfer {
        from: None,
        to: Some(caller),
        // change this from `initial_supply` to `0_u128`
        value: 0_u128.into() // initial_supply,
     });
     instance
}
<span class="boring">}
</span></code></pre></pre>
</li>
<li>
<p>Execute <code>cargo +nightly contract build --debug</code> to compile the contract</p>
</li>
<li>
<p>Use <a href="https://redspot.patract.io/en/tutorial/">RedSpot</a> or <a href="https://polkadot.js.org/apps"><code>Polkadot/Substrate Portal</code></a> to deploy the contract (note that this must be Use erc20.wasm instead of erc20-opt.wasm, otherwise the wasm backtrace cannot be printed normally)</p>
</li>
</ol>
<p>During the deployment process, you will encounter <code>DuplicateTopics</code>, the Europa log is as follows:</p>
<pre><code class="language-bash">1: NestedRuntime {
    #...
    env_trace: [
        seal_input(Some(0xd183512b0)),
		#...    
		seal_deposit_event((Some([0x45726332303a3a5472616e736....]), None)),
    ],
    trap_reason: TrapReason::SupervisorError(DispatchError::Module { index: 5, error: 23, message: Some(&quot;DuplicateTopics&quot;) }),
    wasm_error: Error::WasmiExecution(Trap(Trap { kind: Host(DummyHostError) }))
    	wasm backtrace: 
    	|  ink_env::engine::on_chain::ext::deposit_event[1623]
    	|  ink_env::engine::on_chain::impls::&lt;impl ink_env::backend::TypedEnvBackend for ink_env::engine::on_chain::EnvInstance&gt;::emit_event[1564]
    	|  ink_env::api::emit_event::{{closure}}[1563]
    	|  &lt;ink_env::engine::on_chain::EnvInstance as ink_env::engine::OnInstance&gt;::on_instance[1562]
    	|  ink_env::api::emit_event[1561]
    	|  erc20::erc20::_::&lt;impl ink_lang::events::EmitEvent&lt;erc20::erc20::Erc20&gt; for ink_lang::env_access::EnvAccess&lt;&lt;erc20::erc20::Erc20 as ink_lang::env_access::ContractEnv&gt;::Env&gt;&gt;::emit_event[1685]
        # ...
        # ...
    	|  deploy[1691]
    	╰─&gt;&lt;unknown&gt;[2385]
    ,
    nest: [],
}
</code></pre>
<p>In the log, you can find:</p>
<ol>
<li>The last record in <code>env_trace</code> is <code>seal_deposit_event</code> instead of <code>seal_return</code>. If the contract is executed normally, the last record should be <code>seal_return</code>.</li>
<li>The second parameter of <code>seal_deposit_event</code> is <code>None</code>, which means this host_function is not executed normally. <a href="https://github.com/patractlabs/substrate/blob/3624deb47cabe6f6cd44ec2c49c6ae5a29fd2198/frame/contracts/src/wasm/runtime.rs#L1399">Related Implementation</a>.</li>
<li>Combined with wasm backtrace, you can see that the top of the stack is <code>deposit_event</code>.</li>
</ol>
<p>In summary, it can be concluded that the error occurred in the host_function of <code>seal_deposit_event</code>.</p>
<h2><a class="header" href="#balance-types-are-inconsistent" id="balance-types-are-inconsistent">Balance types are inconsistent</a></h2>
<p>Assuming that the balance on the chain is defined as u64 and the Balance in <code>ink!</code> is defined as u128, an ordinary erc20 contract is deployed.</p>
<p>When reading <code>total_supply</code>, the log in Europa is as follows:</p>
<pre><code class="language-bash">1: NestedRuntime {
    ext_result: [failed] ExecError { error: DispatchError::Module { index: 5, error: 17, message: Some(&quot;ContractTrapped&quot;) }, origin: ErrorOrigin::Caller },
    caller: 0000000000000000000000000000000000000000000000000000000000000000 (5C4hrfjw...),
    self_account: 2fe715301c9609c0c5ab75b24f2d8ad7dbe9671d7aebfeed80ed8963bc017955 (5D9Wkfa3...),
    selector: 0xdb6375a8,
    args: None,
    value: 0,
    gas_limit: 4999999999999,
    gas_left: 4999865113466,
    env_trace: [
        seal_value_transferred(Some(0x0000000000000000)),
    ],
    wasm_error: Error::WasmiExecution(Trap(Trap { kind: Unreachable }))
    	wasm backtrace:
    	|  core::panicking::panic_fmt.48[1956]
    	|  core::result::unwrap_failed[1057]
    	|  core::result::Result&lt;T,E&gt;::expect[1060]
    	|  ink_lang::dispatcher::deny_payment[1878]
    	|  call[1906]
    	╰─&gt;&lt;unknown&gt;[2614]
    ,
    nest: [],
}
</code></pre>
<p>When calling <code>tranfer</code>, the log in Europa is as follows:</p>
<pre><code class="language-bash">1: NestedRuntime {
    ext_result: [failed] ExecError { error: DispatchError::Module { index: 5, error: 17, message: Some(&quot;ContractTrapped&quot;) }, origin: ErrorOrigin::Caller },
    caller: 0000000000000000000000000000000000000000000000000000000000000000 (5C4hrfjw...),
    self_account: 2fe715301c9609c0c5ab75b24f2d8ad7dbe9671d7aebfeed80ed8963bc017955 (5D9Wkfa3...),
    selector: 0xdb6375a8,
    args: None,
    value: 0,
    gas_limit: 4999999999999,
    gas_left: 4999865113466,
    env_trace: [
        seal_value_transferred(Some(0x0000000000000000)),
    ],
    wasm_error: Error::WasmiExecution(Trap(Trap { kind: Unreachable }))
    	wasm backtrace:
    	|  core::panicking::panic_fmt.48[1956]
    	|  core::result::unwrap_failed[1057]
    	|  core::result::Result&lt;T,E&gt;::expect[1060]
    	|  ink_lang::dispatcher::deny_payment[1878]
    	|  call[1906]
    	╰─&gt;&lt;unknown&gt;[2614]
    ,
    nest: [],
}
</code></pre>
<p>It can be found that whether it is a read or write operation, there will be a call process such as <code>call -&gt; deny_payment -&gt; expect</code>. The reason is that in <code>ink!</code>, there is the following code:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[no_mangle]
fn call() -&gt; u32 {
    if true {
     ::ink_lang::deny_payment::&lt;&lt;Erc20 as ::ink_lang::ContractEnv&gt;::Env&gt;()
    		.expect(&quot;caller transferred value even though all ink! message deny payments&quot;)
    }
    ::ink_lang::DispatchRetCode::from(
        &lt;Erc20 as ::ink_lang::DispatchUsingMode&gt;::dispatch_using_mode(
            ::ink_lang::DispatchMode::Call,
        ),
    )
    .to_u32()
}

pub fn deny_payment&lt;E&gt;() -&gt; Result&lt;()&gt;
where
    E: Environment,
{
    let transferred = ink_env::transferred_balance::&lt;E&gt;()
        .expect(&quot;encountered error while querying transferred balance&quot;);
    if transferred != &lt;E as Environment&gt;::Balance::from(0u32) {
        return Err(DispatchError::PaidUnpayableMessage)
    }
    Ok(())
}
<span class="boring">}
</span></code></pre></pre>
<p>In <code>ink!</code>, the timing of <code>expect</code> is different for <code>off_chain</code> and <code>on_chain</code>. In <code>off_chain</code>, it is because <code>ink_env::transferred_balance::&lt;E&gt;()</code> cannot be decoded correctly. In <code>on_chain</code>, <code>deny_payment</code> returns Error due to <code>transferred!=0</code>, and <code>expect</code> appears in <code>call</code>.</p>
<p>It can be seen that the current <code>ink!</code> in <code>off_chain</code> and <code>on_chain</code> is not exactly the same for some situations, causing debugging troubles.</p>
<h1><a class="header" href="#europa-wasm-executor" id="europa-wasm-executor">Europa Wasm executor</a></h1>
<p>TODO: Not completed</p>
<p>Europa offers different Wasm actuators to execute contracts. Currently <code>wasmi</code> and <code>wasmtime</code> are provided.</p>
<p>#Europa's Wasm Backtrace</p>
<p>The execution of <code>pallet-contracts</code> includes the execution in the &quot;contract model&quot; and the execution in Wasm. among them</p>
<ul>
<li>The execution process in the contract model is transferred to the <code>pallet-contracts</code> module through Wasm's host_function. If panic or incorrect positioning occurs, the node runtime can be located in the form of native operation.</li>
<li>Since the execution process in Wasm is in the Wasm virtual machine, it is a black box to the outside world. If the internal execution process has a crash exception, it can only be displayed by the Wasm executor.</li>
</ul>
<p>Europa's <code>pallet-contracts</code> module currently supports 2 types of actuators:</p>
<ul>
<li><code>wasmi</code>: Wasm interpreter developed by parity. When Wasm executes panic, it will only return an error without Backtrace. Patract forks the wasmi of parity, and adds tracking and printing of the execution stack on the original basis. When Panic appears during Wasm's execution, the current execution stack and corresponding information will be returned with an error.</li>
<li><code>wasmtime</code>: Wasm's JIT executor, which already comes with Backtrace when it crashes.</li>
</ul>
<h2><a class="header" href="#europa-can-print-out-wasm-backtrace-conditions" id="europa-can-print-out-wasm-backtrace-conditions">Europa can print out Wasm Backtrace conditions</a></h2>
<p>Wasm can print Backtrace, requiring the &quot;name section&quot; section in the Wasm file compiled by the contract. Since the <code>cargo-contract</code> provided by parity has already encapsulated many operations, ** in the current ** default operation, the contract is compiled in the most optimal way, and the &quot;name section&quot; section will be removed in this process. On the other hand, <code>cargo-contract</code> does not provide corresponding interfaces or options to allow developers to adjust the optimization conditions used in contract compilation and whether to retain some debugging information. Therefore, Patract can only provide a modified version of <code>cargo-contract</code>. Developers can use this modified version of <code>cargo-contract</code> to compile the contract Wasm file with the &quot;name section&quot; section.</p>
<p>On the other hand, the original code will be optimized during the release compilation. The optimized Backtrace to locate the bug may be disturbed, so it is best to reduce the optimization level, so that the Backtrace will be the same as the original code when it crashes. match.</p>
<h2><a class="header" href="#install-cargo-contract-under-patract-warehouse" id="install-cargo-contract-under-patract-warehouse">Install <code>cargo-contract</code> under Patract warehouse</a></h2>
<ol>
<li>
<p>Install <a href="https://github.com/patractlabs/cargo-contract">PatractLabs's <code>cargo-contract</code></a></p>
<pre><code>$ cargo install cargo-contract --git https://github.com/patractlabs/cargo-contract --branch=v0.10.0 --force
</code></pre>
<blockquote>
<p>Since the current version of parity's <code>cargo-contract</code> is <code>v0.10.0</code>, our Patract has added features based on this version. If <code>cargo-contract</code> continues to be upgraded in the future, Patract will continue to be maintained.</p>
</blockquote>
<p>The <code>cargo-contract</code> installed in this way will <strong>overwrite</strong> the installed <code>cargo-contract</code>. Therefore, please pay attention to which warehouse the <code>cargo-contract</code> in the current environment comes from to prevent interference when locating problems.</p>
<p>Excuting an order:</p>
<pre><code class="language-bash">$ cargo install --list | grep cargo-contract
cargo-contract v0.10.0 (https://github.com/patractlabs/cargo-contract?branch=v0.10.0#106081f1):
cargo-contract
</code></pre>
<p>The results listed can be used to determine what source the <code>cargo-contract</code> installation in the current environment comes from. For example, the above result is from Patract. If there is no parenthesis and the content in it, it means it is from <code>crates.io</code>.</p>
</li>
<li>
<p>If the developer has installed the official <code>cargo-contract</code> and does not want to overwrite the installation, you can use manual compilation.</p>
<pre><code class="language-bash">$ git clone https://github.com/patractlabs/cargo-contract --branch=v0.10.0
$ cd cargo-contract
$ cargo build --release
</code></pre>
<p>After compilation, you can move the compiled product to any path that can be accessed globally, and rename it (in case it conflicts with the installed cargo-contract).</p>
<pre><code class="language-bash">$ cp target/release/cargo-contract &lt;to any path&gt;/patract-cargo-contract
</code></pre>
<p>In the subsequent compilation of the ink! contract, use <code>patract-cargo-contract xxx</code> instead of <code>cargo +nighlty contract xxx</code> to execute the corresponding commands. (Please note that this method requires the default toolchain to be nightly)</p>
</li>
</ol>
<h2><a class="header" href="#use-patracts-cargo-contract-to-generate-wasmcontract-files-with-name-section-section" id="use-patracts-cargo-contract-to-generate-wasmcontract-files-with-name-section-section">Use Patract's cargo-contract to generate <code>*.wasm/*.contract</code> files with &quot;name section&quot; section</a></h2>
<p>Patract's <code>cargo-contract</code> provides <code>-d/--debug</code> options. When the following command is executed:</p>
<pre><code class="language-bash">$ cargo +nightly contract build
</code></pre>
<p>The generated <code>*.wasm/*.contract</code> file is consistent with parity's official <code>cargo-contract</code> execution result.</p>
<p>When the following command is executed:</p>
<pre><code class="language-bash">$ cargo +nightly contract build --debug
</code></pre>
<p>The generated <code>*.wasm/*.contract</code> file is the <code>*.wasm/*.contract</code> file that is not optimized and carries the &quot;name section&quot; section. It is equivalent to the files generated in this way <strong>replace</strong> the files generated by the original generation logic.</p>
<p><strong>Please note that the size of the compiled product generated by this mode is generally several hundred times the size of the original product</strong>. Therefore, the developer can pay attention to the size of the generated product to roughly determine the compiled product generated by which compilation method.</p>
<p>For example, the following example:</p>
<pre><code class="language-bash">$ cd target/ink
$ ls -h
-rw-rw-r-- 1 root root 1.5M 3月  12 16:01 flipper.contract
-rw-rw-r-- 1 root root 6.1K 3月  12 15:34 flipper.contract.old
-rw-rw-r-- 1 root root 732K 3月  12 16:00 flipper.wasm
-rw-rw-r-- 1 root root 2.5K 3月  12 15:34 flipper.wasm.old
-rw-rw-r-- 1 root root 2.1K 3月  12 16:01 metadata.json
</code></pre>
<p>The file with <code>*.old</code> means it was generated by the parity version of <code>cargo-contract</code> (renamed after the first compilation), on the contrary, the file with the same name is from Patract's <code>cargo-contract</code> with the addition of <code>-- The debug</code> command is generated. You can see that the new file is many times larger than the old file. And <code>metadata.json</code> is unchanged.</p>
<h2><a class="header" href="#wasm-backtrace-explained" id="wasm-backtrace-explained">Wasm Backtrace explained</a></h2>
<p>TODO: To be completed</p>
<h2><a class="header" href="#experimental-features" id="experimental-features">Experimental features</a></h2>
<h3><a class="header" href="#wasm-backtrace-print-line-number-only-wasmtime-is-supported" id="wasm-backtrace-print-line-number-only-wasmtime-is-supported">Wasm Backtrace print line number (only Wasmtime is supported)</a></h3>
<p>TODO: This part is not completed</p>
<p>Add <code>WASMTIME_BACKTRACE_DETAILS=1</code> when starting Europa or set this variable as an environment variable:</p>
<pre><code class="language-bash">WASMTIME_BACKTRACE_DETAILS=1 europa --tmp
# or use
export WASMTIME_BACKTRACE_DETAILS=1
europa --tmp # run europa in normal way
</code></pre>
<p>Then in the <code>wasm_error</code> part of europa's Japanese, there will be a line number in the original code corresponding to the crash stack:</p>
<pre><code class="language-bash">wasm_error: Error::Trap(
    Trap {
        code: TrapCode::UnreachableCodeReached,
        trace: [
            &quot;wasm trap: unreachable&quot;,
            &quot;wasm backtrace:&quot;,
            &quot;    0: 0x31b2 - &lt;unknown&gt;!core::panicking::panic::he000af669cfcac01&quot;,
            &quot;    1: 0x3c8c - &lt;unknown&gt;!flipper::flippter::_::&lt;impl flipper::flippter::Flippter&gt;::flip::h12b84979a77ae484&quot;,
            &quot;    2: 0x10fa - core::result::Result&lt;T,E&gt;::map_err::h576871030fe833d4&quot;,
            &quot;                    at /home/clearloop/.cargo/registry/src/github.com-1ecc6299db9ec823/parity-scale-codec-2.0.1/src/codec.rs:1199:31&quot;,
            &quot;    3: 0x10d6 - core::result::Result&lt;T,E&gt;::map_err::h576871030fe833d4&quot;,
            &quot;                    at /home/clearloop/.cargo/registry/src/github.com-1ecc6299db9ec823/parity-scale-codec-2.0.1/src/codec.rs:1198&quot;,
            &quot;    4: 0x3966 - &lt;unknown&gt;!&lt;flipper::flippter::_::_::__ink_MessageDispatchEnum as ink_lang::dispatcher::Execute&gt;::execute::{{closure}}::hf35b139aaf5fba3b&quot;,
            &quot;    5: 0x3941 - &lt;unknown&gt;!ink_lang::dispatcher::execute_message_mut::hf62eb790d230d371&quot;,
            &quot;    6: 0x3c12 - &lt;unknown&gt;!&lt;flipper::flippter::_::_::__ink_MessageDispatchEnum as ink_lang::dispatcher::Execute&gt;::execute::heae3e5bbfc02afa0&quot;,
            &quot;    7: 0x3a7a - &lt;unknown&gt;!flipper::flippter::_::&lt;impl ink_lang::contract::DispatchUsingMode for flipper::flippter::Flippter&gt;::dispatch_using_mode::h8e0c4495e09cd910&quot;,
            &quot;    8: 0x3ba3 - &lt;unknown&gt;!call&quot;,
            &quot;    9: 0xf704 - &lt;unknown&gt;!&lt;wasm function 638&gt;&quot;,
            &quot;&quot;,
        ],
    },
),
</code></pre>
<p>In this backtrace log, some parts that can parse the line number will be appended with the line number corresponding to the function in the error stack at the end of that line, for example:</p>
<pre><code class="language-bash">&quot;2: 0x10fa - core::result::Result&lt;T,E&gt;::map_err::h576871030fe833d4&quot;,
            &quot;                    at /home/clearloop/.cargo/registry/src/github.com-1ecc6299db9ec823/parity-scale-codec-2.0.1/src/codec.rs:1199:31&quot;
</code></pre>
<p>The part of <code>codec.rs:1199:31</code> means that this frame in the error stack corresponds to line <code>1199</code> and column <code>31</code> of the file <code>codec.rs</code>. The remaining lines do not have line numbers due to insufficient parsing or because the code is generated by macros.</p>
<h1><a class="header" href="#zkmega" id="zkmega">zkMega</a></h1>
<p>zkMega is a zero-knowledge proof tool set building for the Polkadot ecology. </p>
<ul>
<li>Polkadot Treasury report for v0.1: https://polkadot.polkassembly.io/post/221. </li>
</ul>
<h2><a class="header" href="#zk-rollup-introduction" id="zk-rollup-introduction">ZK Rollup Introduction</a></h2>
<p>Compared with the privacy function, the performance improvement brought by Rollup is the
early application direction of zero-knowledge proof. At present, the Layer 2 expansion
plan of the blockchain is to transfer a considerable part of the on-chain workload to 
off-chain to complete, and the most watched one is ZK Rollup. The essence of ZK Rollup 
is to compress the application on-chain state and store it in a Merkle tree, and move 
the state transition funtions to off-chain. At the same time, the correctness of the 
off-chain state transition process is guaranteed through the proof of zkSNARK. Compared 
with the high cost of directly processing state changes on the chain, the ZK Proof's 
on-chain smart contract verification is extremely cost low. At the same time, the 
compressed information will also be submitted to the chain together with the proof, 
which ensures data availability and obtains the same level of security as Layer 1.</p>
<p>The Ethereum Layer 2 protocols related to ZK Rollup are: <a href="https://zksync.io/">zkSync</a>, <a href="https://aztec.network/">aztec</a>, 
etc. Their contract verification modules share a part of the elliptic curve's basic algorithms. 
In 2017, Ethereum integrated three basic cryptographic calculation units of the alt
bn128 curve in the form of pre-compiled contracts, which are <a href="https://github.com/ethereum/EIPs/blob/master/EIPS/eip-196.md">EIP196</a>’s ADD and Scalar_MUL 
algorithms, and <a href="https://github.com/ethereum/EIPs/blob/master/EIPS/eip-197.md">EIP197</a>’s Pairing algorithm. On top of this, due to the lack of rapid 
upgrade capabilities of Ethereum, the community can only encapsulate some  tool libraries 
through costly Solidity contracts. On top of these basic contract  libraries, many DApps can combine 
ZK Rollup technology to achieve some innovations, such as <a href="https://loopring.org/">loopring</a>, <a href="https://gitcoin.co/">gitcoin</a> 
and <a href="https://uniswap.org/">uniswap</a> etc. However, in the past 3 years, ZK technology has further developed, 
such as the more practical <a href="https://electriccoin.co/blog/new-snark-curve/">BLS curve</a>, and <a href="https://eprint.iacr.org/2019/953/20190827:165656">PLONK algorithm</a> etc. 
Ethereum has not yet supported it.</p>
<h2><a class="header" href="#what-zkmega-does" id="what-zkmega-does">What zkMega does</a></h2>
<p>zkMega 目的是为了给Wasm合约生态<strong>引入零知识原语</strong>，类似于 Ethereum，开发者可以在合约生态中基于零知识原语构建出零知识的dapp及服务于部分Layer2的需求。因此 zkMega 在链的角度上实现的功能为几个基本的 零知识原语 的调用接口。而后续将会继续提供链下开发零知识合约功能的工具包组件等。</p>
<p>zkMega 首先会实现链上的零知识的接口调用功能，并提供合约示例。零知识的接口调用功能分为 Runtime 的实现以及 <code>pallet-contracts</code>合约接口的实现。而 <code>pallet-contracts</code>的实现本质上是通过<code>ChainExtentions</code>调用了Runtime的实现。</p>
<p>而 zkMega 实现零知识的方式是使用了 arkwork 的零知识实现库，该库可以编译成 Wasm 被使用。因此 zkMega 做了对于 Native 执行零知识调用与 Wasm 中执行零知识调用的性能对比（benchmark）。基于Substrate的链引入 zkMega 时，可以根据自己是否愿意导出 zkMega 使用的零知识的 host_function，来以 Wasm 或是 Native 的形式运行零知识的计算过程。详情请参照文档 <a href="zkmega/./benchmark.html">benchmark</a>。</p>
<p>在<code>pallet-contracts</code>的模块引入了 zkMega 的链中，部署于<code>pallet-contracts</code>中的合约模块可以通过<code>ChainExtentions</code>在合约中调用链里 zkMega 提供的零知识的功能。由于<code>ChainExtentions</code>是通过<code>func_id</code>来区分调用的方法，因此 Patract 希望通过 <a href="https://github.com/patractlabs/pips">Patract/pallet-contracts/Polkadot Improvement Proposals (PIPs)</a> 来协定 func_id 与参数。因此 Patract 通过 Pip-101 <a href="https://github.com/patractlabs/PIPs/blob/main/PIPs/pip-101.md">Function ids for Patract Labs zkMega</a> 来约定 zkMega 在 <code>ChainExtentions</code> 部分使用的 <code>func_id</code>。</p>
<p>另一方面 zkMega 为了丰富开发人员的基础库，仿照 Ethereum 生态中的 <code>libsnark</code> 库，提供了例如 <code>MIMC</code>，<code>Merkle Tree</code> 等实用公共函数。这些库可以直接在ink!中被调用。详情可以参考 <a href="zkmega/./example.html">example</a>。</p>
<h2><a class="header" href="#license" id="license">LICENSE</a></h2>
<p>Apache-2.0</p>
<h1><a class="header" href="#tutorial-2" id="tutorial-2">tutorial</a></h1>
<h2><a class="header" href="#the-chain-based-on-substrate-introduces--zkmegas-zero-knowledge-primitives" id="the-chain-based-on-substrate-introduces--zkmegas-zero-knowledge-primitives">The chain based on Substrate introduces 　zkMega's zero-knowledge primitives</a></h2>
<p>The chain integration zkMega with <code>pallet-contracts</code> can refer to Jupiter's integration method: [https://github.com/patractlabs/jupiter/blob/master/primitives/chain-extension/src/lib.rs](https:/ /github.com/patractlabs/jupiter/blob/master/primitives/chain-extension/src/lib.rs)</p>
<p>The main steps are mainly divided into the following steps:</p>
<ol>
<li>
<p>Design a structure implemented in <code>ChainExtension</code></p>
</li>
<li>
<p>Determine the range of <code>func_id</code> in the implementation of <code>call</code> of <code>ChainExtension</code>, according to <a href="https://github.com/patractlabs/PIPs/blob/main/PIPs/pip-101.md">PIP-101</a>, the current range required to use zkMega is <code>0x01000000..=0x010000ff</code>. Therefore, it can be introduced in the implementation:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>match func_id {
        // 0x01000000-0x010000ff Patract ZKP Support
        0x01000000..=0x010000ff =&gt; {

        }
}
<span class="boring">}
</span></code></pre></pre>
</li>
<li>
<p>Then introduce the gas billing method in the code block of <code>0x01000000..=0x010000ff</code>. Different chains may design different billing methods for the methods called by zkMega. In Jupiter's case, only the simplest way to design a fixed consumption of gas:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let simple_weight = match func_id &amp; 0x01 {
        0 =&gt; 100_000,   // add, In ethereum: 500
        1 =&gt; 8_000_000, // 80x then add, In ethereum: 40000
        2 =&gt; {/* ...*/ }
        _ =&gt; return Err(DispatchError::Other(&quot;Unimplemented Patract ZKP func_id&quot;));
    };
env.charge_weight(simple_weight)?;
<span class="boring">}
</span></code></pre></pre>
</li>
<li>
<p>Implement different implementations according to whether the chain itself needs Native call or Wasm call:</p>
<p>For example, if the chain only wants to support Wasm calls, use the following method:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>zkmega_arkworks::call(&amp;func_id, &amp;input);
<span class="boring">}
</span></code></pre></pre>
<p>If the chain wants to execute the call on Native, it can be similar to Jupiter, design <code>runtime_inferface</code> to wrap the call of <code>zkmega_arkworks::call</code>, and put the call process under std to compile. Then call the method exported by <code>runtime_interface</code> in the implementation of <code>ChainExtensions</code>.</p>
</li>
</ol>
<h2><a class="header" href="#the-interface-for-calling-zkmegas-zero-knowledge-primitives-in-the-contract" id="the-interface-for-calling-zkmegas-zero-knowledge-primitives-in-the-contract">The interface for calling zkMega's zero-knowledge primitives in the contract</a></h2>
<p>It is relatively simple to use zkMega in the contract. First introduce <code>megaclite-arkworks</code> in contract dependencies</p>
<pre><code class="language-toml">[dependencies]
megaclite-arkworks = { git = &quot;https://github.com/patractlabs/zkmega&quot;, features = [ &quot;ink&quot; ], default-features = false }
</code></pre>
<p>Please note that you need to use the <code>ink</code> feature when importing the zkMega library.</p>
<p>Then you can use the methods provided by zkMega in the contract:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>megaclite_arkworks::verify(...);
<span class="boring">}
</span></code></pre></pre>
<p>If it is a relatively low-level call, you can call it directly through <code>call</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let func_id = /*id defined in PIP-101*/
megaclite_arkworks::verify(func_id, ...);
<span class="boring">}
</span></code></pre></pre>
<h1><a class="header" href="#contract-3" id="contract-3">Contract</a></h1>
<blockquote>
<p>Currently we (Patract) support zkMega in testnet Jupiter (<a href="https://github.com/patractlabs/jupiter">https://github.com/patractlabs/jupiter</a>) and contract debug 
sandbox Europa (<a href="https://github.com/patractlabs/europa">https://github.com/patractlabs/europa</a>). And any substrate based chain which uses <code>pallet-contracts</code> v3.0.0 could integrate zkMega.</p>
<p>if the <code>pallet-contracts</code> Wasm contract chain use zkMega, then the following contract could run normally in those chain.</p>
</blockquote>
<h2><a class="header" href="#example-1" id="example-1">Example</a></h2>
<p>TODO this example is wrong for current version!</p>
<pre><code class="language-rust ignore">#![cfg_attr(not(feature = &quot;std&quot;), no_std)]

#[ink::contract]
mod altbn128 {
    use ink_env::zk_snarks::AltBn128;
    use ink_prelude::string::String;

    #[ink(storage)]
    pub struct Altbn128 {
        value: String,
    }

    impl Altbn128 {
        #[ink(constructor)]
        pub fn new(init_value: String) -&gt; Self {
            Self { value: init_value }
        }

        #[ink(constructor)]
        pub fn default() -&gt; Self {
            Self::new(&quot;hello, world&quot;.into())
        }

        #[ink(message)]
        pub fn bn_256_add(&amp;mut self) {
            let mut result = [0; 64];
            ink_env::inflect_add::&lt;AltBn128&gt;(&amp;[], &amp;[], &amp;mut result);
            self.value = ink_prelude::format!(&quot;0x{:x?}&quot;, result);
        }

        #[ink(message)]
        pub fn get(&amp;self) -&gt; String {
            ink_prelude::format!(&quot;{}&quot;, &amp;self.value)
        }
    }
}
</code></pre>
<h1><a class="header" href="#example-2" id="example-2">Example</a></h1>
<h2><a class="header" href="#call-curves-in-ink" id="call-curves-in-ink">Call curves in ink!</a></h2>
<table><thead><tr><th>curve</th><th>add</th><th>mul</th><th>pairing</th></tr></thead><tbody>
<tr><td>bls12_377</td><td>0x01000000</td><td>0x01000001</td><td>0x01000002</td></tr>
<tr><td>bls12_381</td><td>0x01000010</td><td>0x01000011</td><td>0x01000012</td></tr>
<tr><td>bn254</td><td>0x01000020</td><td>0x01000021</td><td>0x01000022</td></tr>
<tr><td>bw6_761</td><td>0x01000030</td><td>0x01000031</td><td>0x01000032</td></tr>
</tbody></table>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let result = ink_env::call_chain_extension(func_id, &amp;Vec::from(input))?
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#mimc" id="mimc">MIMC</a></h2>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use zkp_u256::{U256, Zero};
use merkle_tree::mimc::{mimc,mimc_with_key}
let message = U256::from_decimal_str(&quot;49&quot;).unwrap();
let in_key = U256::zero();
assert_eq!(
    mimc(b&quot;1&quot;),
    mimc_with_key(vec![&amp;message], &amp;in_key)
);
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#merkle-tree" id="merkle-tree">Merkle Tree</a></h2>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use merkle_tree::MerkleTree;
let mut mt = MerkleTree::default();
let message = b&quot;49&quot;;
let (leaf, index) = mt.insert(message).unwrap();
assert_eq!(mt.update(), mt.get_root());
let merkle_proof = mt.get_proof(index);
assert!(mt.verify_merkle_proof(leaf, merkle_proof, index));

let message = b&quot;50&quot;;
let (leaf, index) = mt.insert(message).unwrap();
assert_eq!(mt.update(), mt.get_root());
let merkle_proof = mt.get_proof(index);
assert!(mt.verify_merkle_proof(leaf, merkle_proof, index));

let message = b&quot;51&quot;;
let (leaf, index) = mt.insert(message).unwrap();
assert_eq!(mt.update(), mt.get_root());
let merkle_proof = mt.get_proof(index);
assert!(mt.verify_merkle_proof(leaf, merkle_proof, index));
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#eddsa" id="eddsa">EDDSA</a></h2>
<blockquote>
<p>TODO</p>
</blockquote>
<h1><a class="header" href="#benchmark" id="benchmark">Benchmark</a></h1>
<p>We have constructed <a href="https://github.com/patractlabs/zkmega/tree/master/crates/arkworks/src/tests">the tests of zkMega curves</a> in <a href="https://github.com/patractlabs/substrate/blob/features/curve-benchmark/bin/node-template/pallets/template/src/lib.rs">pallet-template</a> which imports the 
curves from zkMega directly(<em>Wasm</em>) and with <a href="https://github.com/patractlabs/substrate/blob/features/curve-benchmark/bin/node-template/io/src/lib.rs">runtime-interface</a>(<em>Native</em>).</p>
<h2><a class="header" href="#building" id="building">Building</a></h2>
<pre><code class="language-bash"># Clone the branch `curve-benchmark` of our fork
git clone https://github.com/patractlabs/jupiter.git \
    --branch features/runtime-interfaces \
    --depth =1

# Build the template
cargo build -p jupiter-dev --all-features --release

# Check the command benchmark works fine
# ./target/release/jupiter-dev benchmark -p pallet_template -e wasm_bls_12_381_add
./target/release/jupiter-dev benchmark -p pallet_template -e wasm_bls_12_381_add

</code></pre>
<h2><a class="header" href="#result" id="result">Result</a></h2>
<table><thead><tr><th>memory</th><th>processor</th></tr></thead><tbody>
<tr><td>64GiB System memory</td><td>AMD Ryzen 9 5900X 12-Core Processor</td></tr>
</tbody></table>
<p>Here we test the curevs on ubuntu LTS 20.04, Time is measured in us</p>
<table><thead><tr><th>Curve</th><th>Native</th><th>Time(us)</th><th>WASM</th><th>Time(us)</th><th>Speed(Native/WASM)</th></tr></thead><tbody>
<tr><td>bls12_377(~9.5x)</td><td>native_bls12_377_add</td><td>9.588</td><td>wasm_bls12_377_add</td><td>29.02</td><td>~3x</td></tr>
<tr><td></td><td>native_bls12_377_mul</td><td>183.1</td><td>wasm_bls12_377_mul</td><td>1893</td><td>~10x</td></tr>
<tr><td></td><td>native_bls12_377_pairing_two</td><td>1732</td><td>wasm_bls12_377_pairing_two</td><td>15310</td><td>~7x</td></tr>
<tr><td></td><td>native_bls12_377_mimc_verify</td><td>7484</td><td>wasm_bls12_377_mimc_verify</td><td>64680</td><td>~9x</td></tr>
<tr><td>bls12_381(~10x)</td><td>native_bls12_381_add</td><td>13.9</td><td>wasm_bls12_381_add</td><td>28.31</td><td>~2x</td></tr>
<tr><td></td><td>native_bls12_381_mul</td><td>177.1</td><td>wasm_bls12_381_mul</td><td>1879</td><td>~10x</td></tr>
<tr><td></td><td>native_bls12_381_pairing_two</td><td>1438</td><td>wasm_bls12_381_pairing_two</td><td>14770</td><td>~10x</td></tr>
<tr><td></td><td>native_bls12_381_mimc_verify</td><td>6411</td><td>wasm_bls12_381_mimc_verify</td><td>63260</td><td>~10x</td></tr>
<tr><td>bn254(~5x)</td><td>native_bn254_add</td><td>5.631</td><td>wasm_bn254_add</td><td>16.05</td><td>~3x</td></tr>
<tr><td></td><td>native_bn254_mul</td><td>107.7</td><td>wasm_bn254_mul</td><td>534.3</td><td>~5x</td></tr>
<tr><td></td><td>native_bn254_pairing_two</td><td>1150</td><td>wasm_bn254_pairing_two</td><td>5061</td><td>~5x</td></tr>
<tr><td></td><td>native_bn254_mimc_verify</td><td>4178</td><td>wasm_bn254_mimc_verify</td><td>19850</td><td>~5x</td></tr>
<tr><td>bw6_761(~13x)</td><td>native_bw6_761_add</td><td>30.35</td><td>wasm_bw6_761_add</td><td>26.79</td><td>\</td></tr>
<tr><td></td><td>native_bw6_761_mul</td><td>963.8</td><td>wasm_bw6_761_mul</td><td>14630</td><td>~15x</td></tr>
<tr><td></td><td>native_bw6_761_pairing_two</td><td>5715</td><td>wasm_bw6_761_pairing_two</td><td>60960</td><td>~10x</td></tr>
<tr><td></td><td>native_bw6_761_mimc_verify</td><td>20330</td><td>wasm_bw6_761_mimc_verify</td><td>299800</td><td>~15x</td></tr>
</tbody></table>
<pre><code class="language-bash"># 1. Under the jupiter repo
# 2. Has compiled jupiter-dev
sh ./benchmark.sh
</code></pre>
<h1><a class="header" href="#himalia" id="himalia">Himalia</a></h1>
<p>Himalia is the general name of the SDK library of the pallet-contracts contract module built by Patract for a series of access chains in different languages. For Substrate, there are already some SDKs for access chains in different languages. However, due to the particularity of the <code>pallet-contracts</code> module, it is necessary to continue to build an SDK based on the access contract module on the SDK of the access chain. Its particularity is mainly manifested in:</p>
<ul>
<li>The deployment and invocation of the contract (including rpc invocation and transaction invocation) need to be based on the order and coding of the information provided by the contract's metadata.json (similar to Solidity's abi file), and the chain's metadata can only inform the chain's SDK There are methods such as <code>instantiate</code> and <code>call</code> of the contract module on this chain, and it is impossible to inform the call parameter information of a certain contract. Therefore, for contracts, it is necessary to build a function that can parse and support contract metadata.</li>
<li>The event of the contract also needs to be parsed according to the metadata.json of the contract. Therefore, if you use the chain's SDK, you can only monitor the event of the contract module, but you cannot parse the content of the event. Therefore, it is necessary to provide the sdk of the contract to support event monitoring.</li>
<li>The state (storage) of the contract is located in the subtree, and its key encoding and distribution method are inconsistent with the runtime. The code distribution method of the key stored in the contract is related to the contract language framework used by the contract (for example, the implementation of Ask! may be different from ink!), so it is necessary to implement corresponding storage analysis methods for different contract language frameworks. At the same time, this parsing process is also very dependent on the metadata provided by the contract itself.</li>
<li>The developers of the contract are the majority of the project parties, and most of the chain developers are the project parties of the development chain. Therefore, there will be a big difference in the scenario of managing the private key. In many cases, the private key management related to chain high authority is the node itself, which is relatively small and has a high threshold, or in many cases it relies on multi-signature or voting control. However, there are a wide range of contract developers, and the quality of back-end security management is uneven. On the other hand, many contracts only have a private key to control. Therefore, in the invocation of contract modules, a solution with high security and low threshold is needed in terms of private key management. Therefore, the contract SDK can do special processing in these scenarios to reduce the threshold for the security management of contract developers.</li>
</ul>
<p>Therefore, Himalia has a very important reason for existence. Himalia's positioning is similar to Web3J, Web3py, etc. in the Ethereum ecosystem.</p>
<h2><a class="header" href="#project-warehouse-address" id="project-warehouse-address">Project warehouse address</a></h2>
<p>The contract SDKs in different languages ​​currently provided by Himalia have the following versions:</p>
<ul>
<li>go: https://github.com/patractlabs/go-patract</li>
<li>python: https://github.com/patractlabs/py-patract</li>
<li>java: Not yet implemented</li>
<li>c#(.net): Not yet implemented</li>
</ul>
<h1><a class="header" href="#tutorial-3" id="tutorial-3">tutorial</a></h1>
<p>The SDK used by Himalia to interact with the contract part of the chain needs to start a node before proceeding with the subsequent execution process.</p>
<p>For nodes with <code>pallet-contracts</code> function, we recommend Europa as an alternative to nodes. For more information, please refer to Europa's <a href="himalia/./europa.html">Document</a>.</p>
<p>Europa can be easily installed and used with the following commands:</p>
<pre><code class="language-bash">git install --recurse-submodules https://github.com/patractlabs/europa.git --force --locked
europa --tmp
</code></pre>
<p>On the other hand, you can also use Patract’s testnet <a href="https://github.com/patractlabs/jupiter">Jupiter</a>, or the contract testnet provided by Parity [Canvas-node](https://github.com/paritytech/ canvas-node.git)</p>
<h2><a class="header" href="#go" id="go">go</a></h2>
<p>PatractGo relies on <a href="https://github.com/centrifuge/go-substrate-rpc-client">GSRPC</a>. The Go version of Himalia project is called <a href="https://github.com/patractlabs/go-patract">go-patract</a></p>
<p>After installing PatractGo, you can use the following methods to quickly deploy and call a contract. For the complete case, please refer to <a href="https://github.com/patractlabs/go-patract/blob/master/contracts/erc20/transfer_test.go">transfer_test</a></p>
<h3><a class="header" href="#deploy-the-contract" id="deploy-the-contract">Deploy the contract</a></h3>
<pre><code class="language-go">// read the code wasm from file
codeBytes, err := ioutil.ReadFile(&quot;/path/to/contracts.wasm&quot;)
if err != nil {
    return err
}
// create the api
cApi, err := rpc.NewContractAPI(env.URL())

// read the abi(metadata) for contract
metaBz, err := ioutil.ReadFile(&quot;/path/to/contracts_metadata.json&quot;)
cApi.WithMetaData(metaBz)

// create context with from auth, like Alice
ctx := api.NewCtx(context.Background()).WithFrom(authKey)

// put code
_, err = cApi.Native().PutCode(ctx, codeBytes)

codeHash := readCodeHash() // get code hash

var codeBz []byte

if err := cApi.Native().Cli.GetStorageLatest(&amp;codeBz,
    &quot;Contracts&quot;, &quot;PristineCode&quot;,
    []byte(codeHash), nil); err != nil {
        return err
    }

var endowment uint64 = 1000000000000

// Instantiate
_, contractAccount, err := cApi.Instantiate(ctx,
    types.NewCompactBalance(endowment),
    types.NewCompactGas(test.DefaultGas),
    contracts.CodeHashERC20,
    types.NewU128(totalSupply),
)
</code></pre>
<h3><a class="header" href="#call-contract" id="call-contract">Call contract</a></h3>
<h4><a class="header" href="#rpc-call" id="rpc-call">rpc call</a></h4>
<p>Call <code>total_supply</code> to get the current total supply.</p>
<pre><code class="language-go">var res types.U128

err := a.CallToRead(ctx,
    &amp;res,
    a.ContractAccountID,
    []string{&quot;total_supply&quot;},
)
</code></pre>
<h4><a class="header" href="#transaction-call" id="transaction-call">Transaction call</a></h4>
<p>Call <code>transfer</code> to transfer a fund.</p>
<pre><code class="language-go">toParam := struct {
    Address AccountID
}{
    Address: to,
}

valueParam := struct {
    Value U128
}{
    Value: amt,
}

return a.CallToExec(ctx,
    a.ContractAccountID,
    types.NewCompactBalance(0),
    types.NewCompactGas(test.DefaultGas),
    []string{&quot;transfer&quot;},
    toParam, valueParam,
)
</code></pre>
<h2><a class="header" href="#python" id="python">python</a></h2>
<p>PatractPy relies on <a href="https://github.com/polkascan/py-substrate-interface">py-substrate-interface</a> The Python version of the Himalia project is called [py-patract](https://github.com/patractlabs/py -patract)</p>
<h3><a class="header" href="#installation" id="installation">Installation</a></h3>
<pre><code class="language-bash">pip3 install -U patract-interface
</code></pre>
<p>Can be used in python script</p>
<pre><code class="language-bash">from patractinterface import ContractFactory, ContractAPI

// ... So something ...
</code></pre>
<h3><a class="header" href="#quick-use" id="quick-use">Quick use</a></h3>
<pre><code class="language-python">import os
from substrateinterface import SubstrateInterface, Keypair
from patractinterface.contract import ContractAPI, ContractFactory
from patractinterface.observer import ContractObserver

def main():
    # use [europa](https://github.com/patractlabs/europa) as test node endpoint, notice `type_registry` should set correctly.
    substrate=SubstrateInterface(url='ws://127.0.0.1:9944', type_registry_preset=&quot;default&quot;, type_registry={'types': {'LookupSource': 'MultiAddress'}})
    # load deployer key
    alice = Keypair.create_from_uri('//Alice')
    bob = Keypair.create_from_uri('//Bob')
    # 1. load a contract from WASM file and metadata.json file (Those files is complied by [ink!](https://github.com/paritytech/ink))
    # in this example, we use `ink/example/erc20` contract as example.
    contract = ContractFactory.create_from_file(
            substrate=substrate, # should provide a subtrate endpoint
            code_file= os.path.join(os.path.dirname(__file__), 'res', 'erc20.wasm'),
            metadata_file= os.path.join(os.path.dirname(__file__), 'res', 'erc20.json')
        )
    # upload code to chain directly
    res = contract.put_code(alice)
    print(&quot;update code hash{} res:{}&quot;.format(contract.code_hash.hex(), res.is_succes))
    # 2. instantiate the uploaded code as a contract instance
    erc20_ins = contract.new(alice, 1000000 * (10 ** 15), endowment=2*10**10, gas_limit=20000000000, deployment_salt=&quot;0x12&quot;)
    # 2.1 create a observer to listen event
    observer = ContractObserver(erc20_ins.contract_address, erc20_ins.metadata, substrate)
    # 3. send a transfer call for this contract
    res = erc20_ins.transfer(alice, bob.ss58_address, 100000, gas_limit=20000000000)
    print('transfer res', res.is_succes)

    def on_transfer(num, evt):
        print(&quot;on_transfer in {} : {} {} {}&quot;.format(num, evt['from'], evt['to'], evt['value']))

    def on_approval(num, evt):
        print(&quot;on_approval in {} : {} {} {}&quot;.format(num, evt['owner'], evt['spender'], evt['value']))
    # 4 set event callback 
    observer.scanEvents(handlers={
        'Transfer': on_transfer,
        'Approve': on_approval
    })

if __name__ == &quot;__main__&quot;:
    main()
    pass
</code></pre>
<h1><a class="header" href="#go-patract" id="go-patract">go-patract</a></h1>
<h2><a class="header" href="#intruduction" id="intruduction">Intruduction</a></h2>
<p>Most contract behaviors are highly related to context. In addition to interacting with the chain, user-oriented contract applications also need to provide users with current relevant context status information:</p>
<pre><code>+--DAPP-Front-End--------------+        +---Chain-------------------------+
|                              |        |                                 |
| +----+  +------------------+ |        | +-------+     +-------+         |
| |    |  |                  | | Commit | |       |     |       |         |
| |    |  |   Polkadot-JS    +------------&gt; Node  +----&gt;+ Node  |         |
| |    +-&gt;+                  | |   Tx   | |       |     |       |         |
| |    |  |                  | |        | +-------+     +----+-++         |
| |    |  +------------------+ |        |                    ^ |          |
| | UI |                       |        +---------------------------------+
| |    |  +------------------+ |                             | |
| |    |  |                  | |        +--DAPP-Server--------------------+
| |    |  |                  | |  Push  | +--------+     +-----v-------+  |
| |    +&lt;-+   Model          +&lt;-----------+        +-----+             |  |
| |    |  |                  | |        | | Server |     |  PatractGo  |  |
| |    |  |                  +------------&gt;        +-----+             |  |
| +----+  +------------------+ | Query  | +----+---+     +-----+-------+  |
+------------------------------+        |      |               |          |
                                        |      |         +-----v-------+  |
                                        |      |         |             |  |
                                        |      +--------&gt;+   DataBase  |  |
                                        |                |             |  |
                                        |                +-------------+  |
                                        |                                 |
                                        +---------------------------------+
</code></pre>
<p>PatractGo is mainly responsible for implementing micro-services in a DApp. Unlike querying the state of the chain API, PatractGo can monitor the calls and events generated by the specified contract. Developers can obtain the state storage based on this information to maintain consistent state with the chain. Through data services based on a typical API-DB architecture, the front-end DApp can efficiently and concisely obtain the state on the chain as context information.</p>
<p>Based on the API of chain nodes, PatractGo obtains block information and summarizes and filters it, and sends contract-related messages and events based on metadata analysis to the handler protocol specified by the developer. For example, for a typical ERC20 contract, the developer can use the channel to subscribe to all transfer events that occur, and then synchronize them into the database, so that other microservices can provide services corresponding to the token data of the account, such as querying the current token holding distribution and other logics.</p>
<p>Therefor, PatractGo will achieve the following support:</p>
<ul>
<li>Complete the secondary packaging of the contract module interface, complete operations such as <code>put_code</code>, <code>call</code>, <code>instantiate</code>, etc.</li>
<li>Parse the metadata.json information of the contract, and support the automatic generation of http service interface for the metadata corresponding contract</li>
<li>Scanning and monitoring support of the contract status on the chain for statistics and analysis</li>
<li>Basic command line tool support for native interaction with the contract, mainly used to test the security of the contract</li>
<li>SDK development examples for ERC20 contract support</li>
</ul>
<h2><a class="header" href="#design-2" id="design-2">Design</a></h2>
<p>PatractGo consists of the following packages:</p>
<ul>
<li><code>patractgo/metadata</code> contract metadata processing, and metadata-based contract processing</li>
<li><code>patractgo/rpc/native</code> re-encapsulation of the contract module interface to provide the contract-related interaction based on chain RPC</li>
<li><code>patractgo/rpc</code> implement the interaction with the contract based on metadata</li>
<li><code>patractgo/rest</code> implements an http service based on metadata to interact with the contract</li>
<li><code>patractgo/observer</code> Monitoring and Scanning support for contract status on the chain</li>
<li><code>patractgo/contracts/erc20</code> supports ERC20 contracts and examples</li>
<li><code>patractgo/tools</code> some tools for contracts develop</li>
</ul>
<p>Currently, we haven't designed the module which could <strong>auto-gen code</strong> for a contract based on a metadata, thus we provide
<code>patractgo/contracts/erc20</code> as an example to show how to warp a contract as a go source file.</p>
<p>This <strong>auto contract code generator</strong> feature would be developed with <code>java-patract</code> repo later (in next version), <strong>for their have same logic to generate the code for contracts</strong>.</p>
<h1><a class="header" href="#py-patract" id="py-patract">py-patract</a></h1>
<p>PatractPy is a contract SDK to support the development of Python scripts that interact with contracts, including automated scripts to support testing. Unlike PatractGo, PatractPy is mainly for script development, so PatractPy mainly completes contract-related RPC interfaces, and completes contract deployment and instantiation-related operations.</p>
<p>PatractPy will provide support for <a href="https://github.com/patractlabs/europa">europa</a> env, which is a good environment for contract exec sandbox,
With PatractPy, we can write contract unittest by python, which is more friendly to developer and can easy use other test tools.</p>
<p>PatractPy will be based on <a href="https://github.com/polkascan/py-substrate-interface">polkascan's Python Substrate Interface</a>, which is a Python sdk for Substrate.</p>
<p>Element Group for disscusion: https://app.element.io/#/room/#PatractLabsDev:matrix.org</p>
<p>PatractPy will achieve the following support:</p>
<ul>
<li>Some support that missing in <a href="https://github.com/polkascan/py-substrate-interface">polkascan's Python Substrate Interface</a>, which is needed for contracts</li>
<li>Provide Scanning and monitoring support for contract to do statistics and analysis</li>
<li>Provide a SDK development example for ERC20 contract</li>
<li>Support For unittest to canvas or <a href="https://github.com/patractlabs/europa">europa</a> env.</li>
</ul>
<h2><a class="header" href="#basic-apis-for-contracts" id="basic-apis-for-contracts">Basic Apis For Contracts</a></h2>
<p>As <a href="https://github.com/polkascan/py-substrate-interface">polkascan's Python Substrate Interface</a> has provide some support to contract api, so we not need to important the api for contract calls, but there is some api to add:</p>
<ul>
<li><code>SubstrateSubscriber</code> is a subscriber support to subscribe data changes in chain, for example, the events in chain.</li>
<li><code>get_contract_event_type</code> add event decode support for contracts.</li>
</ul>
<p>The basic api split into 2 parts:</p>
<ul>
<li>Contract, include:
<ul>
<li>contractExecutor: This api could construct an extrinsic to call a contract, would be packed into a block and change state.</li>
<li>contractReader: This api could construct a rpc request to call a contract, do not pack into a block and do not change any state.</li>
<li>contractCreator: This api is used for <code>instantiate</code> a contract and holding the WASM code and metadata, receive following parameters:
<ul>
<li><code>gas_limit</code></li>
<li><code>endowment</code></li>
<li><code>deployment_salt</code> (<code>salt</code> parameter in <code>instantiate</code>)</li>
</ul>
</li>
<li>ContractAPI: This api is used for <code>call</code> a contract, is a wrapper for <code>contractExecutor</code> and <code>contractReader</code>, developers could use this api to react with contracts. This api could create a instance depends on the metadata, auto generate the contract access functions based on the contract. And the auto-gen functions receive the parameters which defined in contracts, besides receive following common parameters:
<ul>
<li><code>gas_limit</code></li>
<li><code>value</code> (notice, if current call's <code>payable</code> is false, this <code>value</code> must be <code>0</code>)</li>
</ul>
</li>
<li>ContractFactory: This api is used for constructing a contract instance in python, and developer could use this instance to access contract. This is a wrapper for <code>contractCreator</code> and <code>ContractAPI</code></li>
</ul>
</li>
<li>Observer, include:
<ul>
<li>ContractObserver: This api is used for listen the events in contracts. </li>
</ul>
</li>
</ul>
<p>All methods which belong to the instance of <code>ContractAPI</code> and <code>ContractFactory</code> <strong>receive a keypair as the first parameter</strong>, as the sender for this operation. And from the second parameter, receive the parameters defined in contracts.</p>
<h3><a class="header" href="#contractfactory-and-contractapi-is-used-to-react-with-contracts" id="contractfactory-and-contractapi-is-used-to-react-with-contracts"><code>ContractFactory</code> and <code>ContractAPI</code> is used to react with contracts</a></h3>
<p>we add a factory to put code and deploy contracts to chain:</p>
<pre><code class="language-python">factory = ContractFactory.create_from_file(
    substrate=substrate, 
    code_file=os.path.join(os.path.dirname(__file__), 'constracts', 'ink', 'erc20.wasm'),
    metadata_file=os.path.join(os.path.dirname(__file__), 'constracts', 'ink', 'erc20.json')
)

res = factory.put_code(alice) # alice is the keypair for `//Alice`
print(res.is_succes)

# this api is `ContractAPI`
api = factory.new(alice, 1000000 * (10 ** 15), endowment=10**15, gas_limit=1000000000000)
print(api.contract_address) # contract_address is the deployed contract
</code></pre>
<p>The factory will generate constructors from metadata file.</p>
<p>We add api by metadata for Contract, api will auto generate caller for contract from metadata:</p>
<pre><code class="language-python"># create a ContractAPI from an existed contract address
api = ContractAPI(contract_address, contract_metadata, substrate)

# api will auto generate caller for contract from metadata
alice_balance_old = api.balance_of(bob, alice.ss58_address) # bob is the keypair for `//Bob`

res = api.transfer(alice, bob.ss58_address, 100000, gas_limit=20000000000)
logging.info(f'transfer res {res.error_message}')
print(res.is_succes)

alice_balance = api.balance_of(bob, alice.ss58_address)
logging.info(f'transfer alice_balance {alice_balance}')

bob_balance = api.balance_of(bob, bob.ss58_address)
logging.info(f'transfer bob_balance {bob_balance}')
</code></pre>
<p>The api will generate exec and read api from metadata file, for example:</p>
<pre><code class="language-json">      {
        &quot;args&quot;: [
          {
            &quot;name&quot;: &quot;owner&quot;,
            &quot;type&quot;: {
              &quot;displayName&quot;: [
                &quot;AccountId&quot;
              ],
              &quot;type&quot;: 5
            }
          }
        ],
        &quot;docs&quot;: [
          &quot; Returns the account balance for the specified `owner`.&quot;,
          &quot;&quot;,
          &quot; Returns `0` if the account is non-existent.&quot;
        ],
        &quot;mutates&quot;: false,
        &quot;name&quot;: [
          &quot;balance_of&quot;
        ],
        &quot;payable&quot;: false,
        &quot;returnType&quot;: {
          &quot;displayName&quot;: [
            &quot;Balance&quot;
          ],
          &quot;type&quot;: 1
        },
        &quot;selector&quot;: &quot;0x56e929b2&quot;
      },
</code></pre>
<p>In api, can call by:</p>
<pre><code class="language-python">bob_balance = api.balance_of(bob, bob.ss58_address)
logging.info(f'transfer bob_balance {bob_balance}')
</code></pre>
<h3><a class="header" href="#contractobserver-is-used-to-listen-contracts-events" id="contractobserver-is-used-to-listen-contracts-events"><code>ContractObserver</code> is used to listen contracts events</a></h3>
<p>ContractObserver can observer events for a contract:</p>
<pre><code class="language-python">substrate=SubstrateInterface(url=&quot;ws://127.0.0.1:9944&quot;, type_registry_preset='canvas')
contract_metadata = ContractMetadata.create_from_file(
    metadata_file=os.path.join(os.path.dirname(__file__), 'constracts', 'ink', 'erc20.json'),
    substrate=substrate
)
observer = ContractObserver(&quot;0x8eaf04151687736326c9fea17e25fc5287613693c912909cb226aa4794f26a48&quot;, contract_metadata, substrate)

# for some handlers (callbacks)
observer.scanEvents()
</code></pre>
<p>The handler function can take the erc20 support as a example.</p>
<h2><a class="header" href="#special-case-erc20-api" id="special-case-erc20-api">Special case: ERC20 API</a></h2>
<p>Except react contract by <code>ContractAPI</code>, developers could create the wrapper by themself to react with corresponding contract. <code>py-contract</code> create an <code>ERC20 API</code> as an example to show this.</p>
<p>ERC20 api provide a wapper to erc20 contract exec, read and observer events, it can be a example for contracts api calling.</p>
<pre><code class="language-python">
# init api
substrate=SubstrateInterface(url=&quot;ws://127.0.0.1:9944&quot;, type_registry_preset='canvas')

contract_metadata = ContractMetadata.create_from_file(
    metadata_file=os.path.join(os.path.dirname(__file__), 'constracts', 'ink', 'erc20.json'),
    substrate=substrate
)

alice = Keypair.create_from_uri('//Alice')
bob = Keypair.create_from_uri('//Bob')

# erc20 api
erc20 = ERC20.create_from_contracts(
    substrate= substrate, 
    contract_file= os.path.join(os.path.dirname(__file__), 'constracts', 'ink', 'erc20.wasm'),
    metadata_file= os.path.join(os.path.dirname(__file__), 'constracts', 'ink', 'erc20.json')
)

# deplay a erc20 contract
erc20.put_and_deploy(alice, 1000000 * (10 ** 15))

# read total supply
total_supply = erc20.totalSupply()

# transfer
erc20.transfer_from(alice,
    from_acc=alice.ss58_address, 
    to_acc=bob.ss58_address, 
    amt=10000)

erc20.transfer(alice, bob.ss58_address, 10000)

# get balance
alice_balance = erc20.balance_of(alice.ss58_address)

# approve
erc20.approve(alice, spender=bob.ss58_address, amt=10000)

# get allowance
alice_allowance = erc20.allowance(alice.ss58_address, bob.ss58_address)

</code></pre>
<p><code>ERC20Observer</code> is a event observer for erc20 contract:</p>
<pre><code class="language-python">observer = ERC20Observer.create_from_address(
    substrate = substrate, 
    contract_address = contract_address,
    metadata_file= os.path.join(os.path.dirname(__file__), 'constracts', 'ink', 'erc20.json')
)

def on_transfer(num, evt):
    logging.info(&quot;on_transfer in {} : {} {} {}&quot;.format(num, evt['from'], evt['to'], evt['value']))

def on_approval(num, evt):
    logging.info(&quot;on_approval in {} : {} {} {}&quot;.format(num, evt['owner'], evt['spender'], evt['value']))


observer.scanEvents(on_transfer = on_transfer, on_approval = on_approval)
</code></pre>
<h3><a class="header" href="#observer-for-contracts" id="observer-for-contracts">Observer For Contracts</a></h3>
<p><code>ContractObserver</code> is a observer to listen events by contract with a given address:</p>
<pre><code class="language-python">observer = ContractObserver.create_from_address(
    substrate = substrate, 
    contract_address = 'contract_address',
    metadata_file= os.path.join(os.path.dirname(__file__), 'constracts', 'ink', 'erc20.json')
)

def on_transfer(num, evt):
    logging.info(&quot;on_transfer in {} : {} {} {}&quot;.format(num, evt['from'], evt['to'], evt['value']))

def on_approval(num, evt):
    logging.info(&quot;on_approval in {} : {} {} {}&quot;.format(num, evt['owner'], evt['spender'], evt['value']))

observer.scanEvents(from_num, to_num, {
    'Transfer': on_transfer,
    'Approve': on_approval
})
</code></pre>
<p><code>handlers</code> is a hander dictionary by name to hander function.</p>
<h2><a class="header" href="#unittest-node-environment" id="unittest-node-environment">Unittest Node Environment</a></h2>
<p>PatractPy can support write contract unittest by node environment.</p>
<p>At First We need install <a href="https://github.com/patractlabs/europa">europa</a>.</p>
<pre><code class="language-python">from patractinterface.contracts.erc20 import ERC20
from patractinterface.unittest.env import SubstrateTestEnv

class UnittestEnvTest(unittest.TestCase):
    @classmethod
    def setUp(cls):
        # start env or use canvas for a 6s block
        cls.env = SubstrateTestEnv.create_europa(port=39944)
        cls.env.start_node()

        cls.api = SubstrateInterface(url=cls.env.url(), type_registry_preset=cls.env.typ(), type_registry=cls.env.types())
        cls.alice = Keypair.create_from_uri('//Alice')
        cls.bob = Keypair.create_from_uri('//Bob')

        cls.erc20 = ERC20.create_from_contracts(
            substrate= cls.substrate, 
            contract_file= os.path.join(os.path.dirname(__file__), 'constracts', 'ink', 'erc20.wasm'),
            metadata_file= os.path.join(os.path.dirname(__file__), 'constracts', 'ink', 'erc20.json')
        )
        cls.erc20.put_and_deploy(alice, 1000000 * (10 ** 15))

        return

    def tearDown(cls):
        cls.env.stop_node()

    def test_transfer(self):
        self.erc20.transfer_from(alice,
            from_acc=alice.ss58_address, 
            to_acc=bob.ss58_address, 
            amt=10000)
        # some more test case

if __name__ == '__main__':
    unittest.main()
</code></pre>
<p>By example, we can use python to write testcase for some complex logics, by <a href="https://github.com/patractlabs/europa">europa</a>, we can test the contracts for python scripts.</p>
<h1><a class="header" href="#metis" id="metis">Metis</a></h1>
<p>Metis is the contract standard implementation and example case library led by Patract. In this warehouse, contract language frameworks such as ink!, Ask! that can run on <code>pallet-contracts</code> will be provided with the implementation of corresponding contract standards and common cases.</p>
<p>Metis is similar to OpenZepplin-contracts in the Ethereum ecosystem, providing contract developers with reusable wheels without having to write contract code from scratch. Developers who are new to Polkadot's ecological trial contract development can quickly build common applications with the help of the code in this warehouse after learning simple basic knowledge.</p>
<blockquote>
<p>Since the current ink! contract is not yet stable and the Ask! contract is still under development, neither platform has yet to make standards. Therefore, the current implementations provided in Metis are some mimic implementations that imitate the EIP-related standards in Solidity.</p>
</blockquote>
<h1><a class="header" href="#overview" id="overview">Overview</a></h1>
<h2><a class="header" href="#warehouse-address" id="warehouse-address">Warehouse Address</a></h2>
<p><a href="https://github.com/patractlabs/metis">https://github.com/patractlabs/metis</a></p>
<h2><a class="header" href="#project-structure" id="project-structure">Project structure</a></h2>
<p>The metis project is divided into the following three modules: <code>trait</code>, <code>stubs</code>, and <code>impls</code>.</p>
<h3><a class="header" href="#trait" id="trait">trait</a></h3>
<p>The <code>trait</code> module contains commonly used contract standard definitions, such as: erc20, erc721, etc. The ink! contract defines the common shared contract interface by defining <code>#[ink::trait_definition]</code> to achieve the characteristics similar to solidity <code>interface</code>.</p>
<p>Metis has formulated some widely used <code>trait_definition</code> contract standards based on development practical experience. Developers only need to add the <code>trait</code> package defined in metis to their own project's dependencies,
And implement the method defined in <code>#[ink::trait_definition]</code> like implementing the rust trait, then a common standard contract can be implemented.</p>
<h4><a class="header" href="#example-3" id="example-3">example</a></h4>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use ink_lang as ink;

#[ink::trait_definition]
pub trait IErc20 {
    /// Creates a new ERC-20 contract and initializes it with the initial supply for the instantiator.
    #[ink(constructor)]
    fn new(initial_supply: Balance) -&gt; Self;

    /// Returns the total supply.
    #[ink(message)]
    fn total_supply(&amp;self) -&gt; Balance;

    /// Transfers'amount' from caller to'to'.
    #[ink(message, payable)]
    fn transfer(&amp;mut self, to: AccountId, amount: Balance);
}
<span class="boring">}
</span></code></pre></pre>
<h3><a class="header" href="#stubs" id="stubs">stubs</a></h3>
<p>The <code>stubs</code> module is a <code>stub</code> implementation of the <code>trait definition</code> contract defined in the <code>trait</code> module. The main purpose of stub is to assemble the contract address into a contract object when calling across contracts, and the contract method on the chain corresponding to the contract address can be called through the contract object.</p>
<p>Students who are familiar with solidity know that solidity implements inter-contract calls through interface, such as: <code>interfaceContract _interfaceContract = interfaceContract(_addr);</code>, so you may have questions here: since ink! has been implemented through <code>#[ink:: trait_definition]</code> to implement the contract interface,
Why not use <code>trait</code> to implement cross-contract calls, but need <code>stub</code>? This is indeed a feature that the official parity needs to implement in the next step, but it is not currently supported. Interested students can track the official implementation (https://github.com/paritytech/ink/issues/631).</p>
<p>Therefore, metis implements the function of cross-contract call by providing contract stubs. Developers can introduce stub contracts into the project to implement cross-contract calls.</p>
<blockquote>
<p>The structure of the interface definition is exactly the same as that of the contract, but no function implementation is defined, only they are declared. This type of declaration is usually called a <code>stub</code>;</p>
</blockquote>
<h4><a class="header" href="#example-4" id="example-4">example</a></h4>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use ink_lang as ink;

#[ink::contract]
mod erc20 {
    use ierc20::IErc20;

    #[ink(storage)]
    pub struct Erc20Stub {}

    impl IErc20 for Erc20Stub {
        #[ink(constructor)]
        fn new(initial_supply: Balance) -&gt; Self {unimplemented!()}

        #[ink(message)]
        fn total_supply(&amp;self) -&gt; Balance {unimplemented!()}

        #[ink(message, payable)]
        fn transfer(&amp;mut self, to: AccountId, amount: Balance) {unimplemented!()}
    }
}
<span class="boring">}
</span></code></pre></pre>
<h3><a class="header" href="#impls" id="impls">impls</a></h3>
<p>The impls module provides contract development and implementation cases, including the above-mentioned <code>trait</code>, the use of packages in the <code>stubs</code> module, and contract cases with features such as zkp.</p>
<h4><a class="header" href="#example-5" id="example-5">example</a></h4>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use ink_lang as ink;

#[ink::contract]
mod erc20 {
    use ierc20::IErc20;

    #[ink(storage)]
    pub struct Erc20 {
        total_supply: Balance,
        // more fields ...
    }

    impl IErc20 for Erc20 {
        #[ink(constructor)]
        fn new(initial_supply: Balance) -&gt; Self {
            // implementation ...
        }

        #[ink(message)]
        fn total_supply(&amp;self) -&gt; Balance {
            // implementation ...
        }

        #[ink(message, payable)]
        fn transfer(&amp;mut self, to: AccountId, amount: Balance) {
            // implementation ...
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<h1><a class="header" href="#erc20" id="erc20">ERC20</a></h1>
<p>metis provides <a href="https://github.com/patractlabs/metis/tree/master/traits/token/erc20">trait_definition</a> and <a href="https://github.com/patractlabs/metis/tree/master/traits/token/erc20">calling stub between contracts</a> that fully complies with the <code>ERC20</code> standard. com/patractlabs/metis/tree/master/stubs/token/erc20)
And the standard implementation of <a href="https://github.com/patractlabs/metis/tree/master/impls/token/erc20">erc20 contract</a>.</p>
<p>The following is a detailed introduction to the use of the erc20 trait and stub provided by metis.</p>
<h2><a class="header" href="#trait-definition" id="trait-definition">Trait Definition</a></h2>
<p>By processing macros with <code>#[ink::trait_definition]</code>, developers can define their own trait definitions, which can then be implemented by ink! smart contract. This allows the definition of shared smart contract interfaces for different specific implementations. Note that this <code>#[ink::trait_definition]</code> can be defined anywhere, even in another crate!</p>
<h3><a class="header" href="#erc20-trait-source-code-analysis" id="erc20-trait-source-code-analysis">erc20 trait source code analysis</a></h3>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span>#![cfg_attr(not(feature = &quot;std&quot;), no_std)]

<span class="boring">fn main() {
</span>// Note: The tarit definition needs to be exported here for other packages to use
pub use self::erc20::{Error, IErc20, Result};
pub mod events {
    // pub use crate::erc20::{Transfer, Approval};
}

use ink_lang as ink;
#[ink::contract]
mod erc20 {
    use ink_lang as ink;
    use ink_prelude::string::String;
    /// The ERC-20 result type.
    pub type Result&lt;T&gt; = core::result::Result&lt;T, Error&gt;;

    /// Event emitted when a token transfer occurs.
    #[ink(event)]
    pub struct Transfer {
        #[ink(topic)]
        pub from: Option&lt;AccountId&gt;,
        #[ink(topic)]
        pub to: Option&lt;AccountId&gt;,
        #[ink(topic)]
        pub value: Balance,
    }
    /// Event emitted when an approval occurs that `spender` is allowed to withdraw
    /// up to the amount of `value` tokens from `owner`.
    #[ink(event)]
    pub struct Approval {
        #[ink(topic)]
        pub owner: AccountId,
        #[ink(topic)]
        pub spender: AccountId,
        #[ink(topic)]
        pub value: Balance,
    }

    /// The ERC-20 error types.
    #[derive(Debug, PartialEq, Eq, scale::Encode, scale::Decode)]
    #[cfg_attr(feature = &quot;std&quot;, derive(scale_info::TypeInfo))]
    pub enum Error {
        /// Returned if not enough balance to fulfill a request is available.
        InsufficientBalance,
        /// Returned if not enough allowance to fulfill a request is available.
        InsufficientAllowance,
    }

    /// Trait implemented by all ERC-20 respecting smart contracts.
    #[ink::trait_definition]
    pub trait IErc20 {
        /// Creates a new ERC-20 contract with the specified initial supply.
        #[ink(constructor)]
        fn new(
            initial_supply: Balance,
            name: Option&lt;String&gt;,
            symbol: Option&lt;String&gt;,
            decimals: Option&lt;u8&gt;,
        ) -&gt; Self;

        /// Returns the token name.
        #[ink(message)]
        fn token_name(&amp;self) -&gt; Option&lt;String&gt;;

        /// Returns the token symbol.
        #[ink(message)]
        fn token_symbol(&amp;self) -&gt; Option&lt;String&gt;;

        /// Returns the token decimals.
        #[ink(message)]
        fn token_decimals(&amp;self) -&gt; Option&lt;u8&gt;;
        /// Returns the total token supply.
        #[ink(message)]
        fn total_supply(&amp;self) -&gt; Balance;
        /// Returns the account balance for the specified `owner`.
        #[ink(message)]
        fn balance_of(&amp;self, owner: AccountId) -&gt; Balance;

        /// Transfers `value` amount of tokens from the caller's account to account `to`.
        #[ink(message)]
        fn transfer(&amp;mut self, to: AccountId, value: Balance) -&gt; Result&lt;()&gt;;

        /// Returns the amount which `spender` is still allowed to withdraw from `owner`.
        #[ink(message)]
        fn allowance(&amp;self, owner: AccountId, spender: AccountId) -&gt; Balance;

        /// Transfers `value` tokens on the behalf of `from` to the account `to`.
        #[ink(message)]
        fn transfer_from(&amp;mut self, from: AccountId, to: AccountId, value: Balance) -&gt; Result&lt;()&gt;;

        /// Allows `spender` to withdraw from the caller's account multiple times, up to
        /// the `value` amount.
        #[ink(message)]
        fn approve(&amp;mut self, spender: AccountId, value: Balance) -&gt; Result&lt;()&gt;;
    }

    // TODO tmp hack struct for passing compile
    #[ink(storage)]
    pub struct Phantom;
    impl Phantom {
        #[ink(constructor)]
        pub fn new() -&gt; Self {
            Phantom {}
        }
        #[ink(message)]
        pub fn message(&amp;self) {}
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>First, you must define <code>#[ink::trait_definition]</code>, where a trait interface of <code>IErc20</code> is defined. At least one of <code>#[ink(constructor)]</code> and <code>#[ink(message)]</code> must be defined in trait_definition.
All interfaces have only declarations, not implementations.</p>
<p><code>#[ink::trait_definition]</code> can be defined separately from <code>#[ink::contract]</code>. For simple traits, you only need to define trait_definition, as defined in the introduction. But in this erc20 trait
In the implementation, the reason why it is defined in <code>#[ink::contract]</code> is because of the existence of <code>#[ink(event)]</code>. We hope to not only provide interfaces, but also provide some event and error definitions, so that developers When using our erc20-trait package, you can clearly know that it will
Which events are triggered and what errors occur, but the catch is that <code>#[ink(event)]</code> cannot be separated from the separate definition of <code>#[ink::contract]</code>, so we can only temporarily implement a <code>Phantom</code> contract and store it. Make the compilation pass. We have submitted this issue as an official issue
(Https://github.com/paritytech/ink/issues/683).</p>
<p>After defining <code>#[ink::trait_definition]</code>, pay attention to exporting the trait, such as: <code>pub use self::erc20::{Error, IErc20, Result};</code>, only after exporting can it be used by other crates .</p>
<h3><a class="header" href="#use-erc20-trait-to-implement-the-contract" id="use-erc20-trait-to-implement-the-contract">Use erc20-trait to implement the contract</a></h3>
<ol>
<li>Create a new contract</li>
</ol>
<pre><code>cargo contract new myerc20
</code></pre>
<p>Note: The ink! dependencies of all contracts in metis are the codes in the latest ink warehouse, so you need to change the dependencies in the newly created contract project to the latest, otherwise it will cause version conflicts, as follows:</p>
<pre><code class="language-toml">[dependencies]
ink_primitives = { version = &quot;3.0.0-rc3&quot;, git = &quot;https://github.com/paritytech/ink&quot;, default-features = false }
ink_metadata = { version = &quot;3.0.0-rc3&quot;, git = &quot;https://github.com/paritytech/ink&quot;, default-features = false, features = [&quot;derive&quot;], optional = true }
ink_env = { version = &quot;3.0.0-rc3&quot;, git = &quot;https://github.com/paritytech/ink&quot;, default-features = false }
ink_storage = { version = &quot;3.0.0-rc3&quot;, git = &quot;https://github.com/paritytech/ink&quot;, default-features = false }
ink_lang = { version = &quot;3.0.0-rc3&quot;, git = &quot;https://github.com/paritytech/ink&quot;, default-features = false }
ink_prelude = { version = &quot;3.0.0-rc3&quot;, git = &quot;https://github.com/paritytech/ink&quot;, default-features = false }
</code></pre>
<ol start="2">
<li>Add the <code>erc20-trait</code> package to the <code>cargo.toml</code> dependency of the new contract project</li>
</ol>
<pre><code class="language-toml">[dependencies]
erc20-trait = { git = &quot;https://github.com/patractlabs/metis&quot;, default-features = false, features = [&quot;ink-as-dependency&quot;] }

[features]
default = [&quot;std&quot;]
std = [
    &quot;erc20-trait/std&quot;,
]
</code></pre>
<p>When adding a dependency here, the <code>features = [&quot;ink-as-dependency&quot;]</code> feature is enabled because it is in ink! As a dependency, the Chinese contract needs to be turned on and modified.</p>
<ol start="3">
<li>Implement the erc20 trait in the new contract project</li>
</ol>
<p>The complete code is at: <code>https://github.com/patractlabs/metis/blob/master/impls/token/erc20</code></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span>#![cfg_attr(not(feature = &quot;std&quot;), no_std)]

<span class="boring">fn main() {
</span>use ink_lang as ink;

#[ink::contract]
mod erc20 {
    // Here you need to import the interface and errors defined in erc20_trait
    use erc20_trait::{Error, IErc20, Result};
    use ink_prelude::string::String;

    /// Basic version of StandardToken, with no allowances.
    #[ink(storage)]
    pub struct Erc20 {
        /// Total token supply.
        total_supply: Lazy&lt;Balance&gt;,
        /// Mapping from owner to number of owned token.
        balances: StorageHashMap&lt;AccountId, Balance&gt;,
        /// Mapping of the token amount which an account is allowed to withdraw
        /// from another account.
        allowances: StorageHashMap&lt;(AccountId, AccountId), Balance&gt;,
        /// Name of the token
        name: Option&lt;String&gt;,
        /// Symbol of the token
        symbol: Option&lt;String&gt;,
        /// Decimals of the token
        decimals: Option&lt;u8&gt;,
    }

    impl IErc20 for Erc20 {
        #[ink(constructor)]
        fn new(
            initial_supply: Balance,
            name: Option&lt;String&gt;,
            symbol: Option&lt;String&gt;,
            decimals: Option&lt;u8&gt;,
        ) -&gt; Self {
            // implementation ...
        }

        // Omitted part of interface
        
        #[ink(message)]
        fn transfer_from(&amp;mut self, from: AccountId, to: AccountId, value: Balance) -&gt; Result&lt;()&gt; {
            // implementation ...
        }
        
        #[ink(message)]
        fn approve(&amp;mut self, spender: AccountId, value: Balance) -&gt; Result&lt;()&gt; {
            // implementation ...
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#call-stub-across-contracts" id="call-stub-across-contracts">Call stub across contracts</a></h2>
<p>Before that, we have implemented the standard erc20 contract through the erc20 trait, and it is essential to interact with the erc20 contract in some complex dapps. Metis provides <code>erc20-stub</code> to support cross-contract calls. We have implemented the erc20 contract.</p>
<h3><a class="header" href="#erc20-stub-source-code-analysis" id="erc20-stub-source-code-analysis">erc20 stub source code analysis</a></h3>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span>#![cfg_attr(not(feature = &quot;std&quot;), no_std)]

<span class="boring">fn main() {
</span>// Need to export Erc20Stub for sub-contract call
pub use self::erc20::Erc20Stub;
use ink_lang as ink;

#[ink::contract]
mod erc20 {
    use ink_prelude::string::String;

    /// The ERC-20 error types.
    #[derive(Debug, PartialEq, Eq, scale::Encode, scale::Decode)]
    #[cfg_attr(feature = &quot;std&quot;, derive(scale_info::TypeInfo))]
    pub enum Error {
        /// Returned if not enough balance to fulfill a request is available.
        InsufficientBalance,
        /// Returned if not enough allowance to fulfill a request is available.
        InsufficientAllowance,
    }

    /// The ERC-20 result type.
    pub type Result&lt;T&gt; = core::result::Result&lt;T, Error&gt;;

    #[ink(storage)]
    pub struct Erc20Stub {}

    impl Erc20Stub {
        /// Creates a new ERC-20 contract with the specified initial supply.
        #[ink(constructor)]
        pub fn new(
            _initial_supply: Balance,
            _name: Option&lt;String&gt;,
            _symbol: Option&lt;String&gt;,
            _decimals: Option&lt;u8&gt;,
        ) -&gt; Self {
            unimplemented!()
        }

        /// Returns the token name.
        #[ink(message, selector = &quot;0x6b1bb951&quot;)]
        pub fn token_name(&amp;self) -&gt; Option&lt;String&gt; {
            unimplemented!()
        }

        /// Returns the token symbol.
        #[ink(message, selector = &quot;0xb42c3368&quot;)]
        pub fn token_symbol(&amp;self) -&gt; Option&lt;String&gt; {
            unimplemented!()
        }

        /// Returns the token decimals.
        #[ink(message, selector = &quot;0xc64b0eb2&quot;)]
        pub fn token_decimals(&amp;self) -&gt; Option&lt;u8&gt; {
            unimplemented!()
        }

        /// Returns the total token supply.
        #[ink(message, selector = &quot;0x143862ae&quot;)]
        pub fn total_supply(&amp;self) -&gt; Balance {
            unimplemented!()
        }

        /// Returns the account balance for the specified `owner`.
        #[ink(message, selector = &quot;0xb7d968c9&quot;)]
        pub fn balance_of(&amp;self, _owner: AccountId) -&gt; Balance {
            unimplemented!()
        }

        /// Transfers `value` amount of tokens from the caller's account to account `to`.
        #[ink(message, selector = &quot;0x10d455c2&quot;)]
        pub fn transfer(&amp;mut self, _to: AccountId, _value: Balance) -&gt; Result&lt;()&gt; {
            unimplemented!()
        }

        /// Returns the amount which `spender` is still allowed to withdraw from `owner`.
        #[ink(message, selector = &quot;0xc04aa300&quot;)]
        pub fn allowance(&amp;self, _owner: AccountId, _spender: AccountId) -&gt; Balance {
            unimplemented!()
        }

        /// Transfers `value` tokens on the behalf of `from` to the account `to`.
        #[ink(message, selector = &quot;0xbb399017&quot;)]
        pub fn transfer_from(
            &amp;mut self,
            _from: AccountId,
            _to: AccountId,
            _value: Balance,
        ) -&gt; Result&lt;()&gt; {
            unimplemented!()
        }

        /// Allows `spender` to withdraw from the caller's account multiple times, up to
        /// the `value` amount.
        #[ink(message, selector = &quot;0x4ce0e831&quot;)]
        pub fn approve(&amp;mut self, _spender: AccountId, _value: Balance) -&gt; Result&lt;()&gt; {
            unimplemented!()
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>From the above code, we can know that there is no erc20 specific logic implementation in the stub contract, only an empty implementation of the interface is provided, and the contract will be instantiated by the child contract as the parent contract.
And you can call the interface of the parent contract in the child contract.</p>
<p>Note: In the erc20-stub contract, the <code>selector</code> of each contract method is set with a fixed value, where the value of <code>selector</code> is determined by <code>BLAKE2(&quot;IErc20::{message_func_name}&quot;.to_string().as_bytes ())[0..4]</code>
The formula is calculated.</p>
<p>The calculation method of <code>selector</code> in the ink! system is different from that of solidity. In solidity, the method signature is hashed, while in ink! there is a set of calculation methods. The simplest one is for <code>{message_func_name} </code>
Perform hash operation, but when message is implemented by <code>#[ink::trait_definition]</code>, use {trait_name} + {message_func_name} mixed hash method, detailed calculation rules,
You can check ink! Source code (https://github.com/paritytech/ink/blob/master/crates/lang/ir/src/ir/item_impl/callable.rs#L190).</p>
<p>Therefore, erc20-stub is only applicable to cross-contract calls of the erc20 contract implemented in metis (implemented through the IErc20 trait). If it is an erc20 contract implemented in other ways, this stub cannot be used due to the mismatch of <code>selector</code>.</p>
<h3><a class="header" href="#cross-contract-call-through-erc20-stub" id="cross-contract-call-through-erc20-stub">Cross-contract call through erc20 stub</a></h3>
<ol>
<li>Add the <code>erc20-stub</code> package to the <code>cargo.toml</code> dependency of the new contract project</li>
</ol>
<pre><code class="language-toml">[dependencies]
erc20-stub = {git = &quot;https://github.com/patractlabs/metis&quot;, default-features = false, features = [&quot;ink-as-dependency&quot;]}

[features]
default = [&quot;std&quot;]
std = [
    &quot;erc20-stub/std&quot;,
]
</code></pre>
<ol start="2">
<li>Instantiate erc20 stub in the new contract</li>
</ol>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span>#![cfg_attr(not(feature = &quot;std&quot;), no_std)]

<span class="boring">fn main() {
</span>use ink_lang as ink;

#[ink::contract]
mod delegate {
    use erc20_stub::Erc20Stub;
    use ink_env::call::FromAccountId;
    use ink_storage::Lazy;

    #[ink(storage)]
    pub struct CrossCall {
        callee: Lazy&lt;Erc20Stub&gt;,
    }

    impl CrossCall {
        #[ink(constructor)]
        pub fn new(callee: AccountId) -&gt; Self {
            let token: Erc20Stub = FromAccountId::from_account_id(callee);
            Self { callee: Lazy::new(token) }
        }

        #[ink(message)]
        pub fn transfer(&amp;mut self, owner: AccountId, amount: Balance) {
            self.callee.transfer(owner, amount).unwrap();
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>In the ink! contract, you can use <code>FromAccountId</code> to instantiate the contract object (not to create a new contract), and then you can use the contract object to make cross-contract calls to contract methods.</p>
<blockquote>
<p><code>ink_storage::Lazy</code> manages data entities and delays the execution of read/write operations on the storage. Only when it is determined that reading/writing is really needed, it will be executed on the storage.</p>
</blockquote>
<h1><a class="header" href="#access-control" id="access-control">Access Control</a></h1>
<p>Although smart contract applications are decentralized, implementing necessary centralized access control in the contract can make the contract more secure.</p>
<h2><a class="header" href="#ownership-and-ownable" id="ownership-and-ownable">Ownership and Ownable</a></h2>
<p>The concept of ownership is the most common and basic form of access control: an account is the owner of the contract and can perform management tasks on the contract.</p>
<p>metis provides <a href="https://github.com/patractlabs/metis/tree/master/traits/access/ownership">Ownership</a> to realize the ownership in your contract.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[ink::trait_definition]
pub trait Ownable {
    /// Initializes the contract setting the deployer as the initial owner.
    #[ink(constructor)]
    fn new() -&gt; Self;

    /// Returns the account id of the current owner.
    #[ink(message)]
    fn owner(&amp;self) -&gt; Option&lt;AccountId&gt;;

    /// Transfer ownership to new owner.
    #[ink(message)]
    fn transfer_ownership(&amp;mut self, new_owner: Option&lt;AccountId&gt;);
}
<span class="boring">}
</span></code></pre></pre>
<h3><a class="header" href="#use-ownership-to-realize-contract-ownership" id="use-ownership-to-realize-contract-ownership">Use <code>Ownership</code> to realize contract ownership</a></h3>
<ol>
<li>Add the <code>ownership</code> package to the <code>cargo.toml</code> dependency of the new contract project</li>
</ol>
<pre><code class="language-toml">[dependencies]
ownership = {version = &quot;0.1.0&quot;, git = &quot;https://github.com/patractlabs/metis&quot;, default-features = false}

[features]
default = [&quot;std&quot;]
std = [
    &quot;ownership/std&quot;,
]
</code></pre>
<ol start="2">
<li>The simplest realization of <code>ownership</code></li>
</ol>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use ink_lang as ink;

#[ink::contract]
mod ownership {
use super::Ownable;

    #[ink(storage)]
    pub struct Ownership {
        owner: Option&lt;AccountId&gt;,
    }

    impl Ownable for Ownership {
        #[ink(constructor)]
        fn new() -&gt; Self {
            Self {
                owner: Self::env().caller(),
            }
        }

        #[ink(message)]
        fn owner(&amp;self) -&gt; Option&lt;AccountId&gt; {
            self.owner.clone()
        }

        #[ink(message)]
        fn transfer_ownership(&amp;mut self, new_owner: Option&lt;AccountId&gt;) {
            assert_eq!(self.owner(), Some(self.env().caller()));
            if let Some(new_one) = new_owner {

            }
            self.owner = new_owner;
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>By default, the owner of the contract is the account that deployed it, and <code>Ownable</code> also provides the <code>transfer_ownership</code> method to allow you to transfer the contract ownership to other accounts.</p>
<h1><a class="header" href="#carpo" id="carpo">Carpo</a></h1>
<h1><a class="header" href="#patract" id="patract">Patract</a></h1>
<p><img src="patract/./imgs/overview.jpg" alt="overview" /></p>
<p>Patract 做的东西具体包括:</p>
<ul>
<li>
<p>在开发者端：</p>
<ul>
<li>Jupiter：独立的智能合约测试网，提供给合约开发者测试合约链的环境。</li>
<li>Ask!：AssemblyScript 版的 Ink! 合约框架，吸引 TS/JS 的开发者，给不愿意使用 rust 的合约开发者另一个选择。</li>
<li>Redspot：Wasm 合约开发工作流和脚手架：对标 Ethereum 生态中的 Tuffle/Redhat，让合约开发项目化，自动化的工具。Redspot 采用插件化设计，运行开发者添加自己设计的插件丰富 Redspot 的功能。</li>
<li>Europa：Runtime 和合约运行沙盒：对标 Ethereum 生态中的 EthereumJS/Ganache，给合约开发者提供了丰富的调试信息，便于快速开发合约。</li>
<li>Elara：实时和可扩展的波卡 API：对标 Ethereum 中的 Infura，给合约项目方提供节点的 Endpoint，不用自行搭建节点获取数据。</li>
<li>Megaclite：零知识证明的底层支持：在 Jupiter/Patract 链中提供零知识原语支持，可以允许项目方设计 zkRollup 或其他零知识相关合约。</li>
<li>Metis：Ink! 合约标准库：对标 Ethereum 中的 openzeppelin-contracts，给合约开发者提供可复用的轮子，不必从零开始编写合约代码。</li>
<li>Himalia：多语言合约 SDK：对标 Ethereum 中的 Web3J，Web3Py 等 SDK，给合约项目方提供不同语言的环境，丰富的接口与合约进行交互。</li>
<li>Leda：合约监控台：对标 Ethereum 生态中各类合约监控设施，让合约项目方随时监控合约的存储情况，代币转移情况，合约调用情况等等。</li>
<li>Carpo：专注开发合约的智能 WebIDE：对标 Ethereum 中的 Remix，但其将会是对 Patract 以上合约开发工具的集大成者。Carpo 将采用最新的 WebIDE 技术，使得云端开发无限贴近本地开发，同时完整的云端让开发者无需搭建任何开发环境即可进行开发，开箱即用的 Patract 工具链给合约开发者提供了一体化开发体验，让开发者的开发、调试、测试和部署的合约过程如丝般顺畅。</li>
</ul>
</li>
<li>
<p>在用户端包括：</p>
<ul>
<li>Patra Store：作为 Patract 平行链钱包和 DApp 生态的入口，在测试网阶段将集成一些示例应用和配套开发工具套件用法演示，帮助开发者快速开发 Wasm 合约和前端界面，帮助用户快速进入波卡新合约生态。</li>
<li>Patra Scan：专门为智能合约链优化的区块链浏览器，集成比统一的链浏览器更丰富的合约数据信息展示，增强统计和自定义的查询功能。</li>
</ul>
</li>
</ul>
<h1><a class="header" href="#elara" id="elara">Elara</a></h1>
<p>In Polkadot, Kusama or Parachain, RPC is the interface between Dapp and the network. As the Polkadot network continues to expand, more and more parachains will be online, and more and more parachains will support smart contract functions. Faced with more and more parallel chains, developers need to build and maintain multiple chain node RPCs in order to interact with them, which will be a huge development cost for them.</p>
<p>Whether it is facing the development and testing needs of developers, or users' online Dapp usage needs, convenient, convenient, fast and stable network access is one of the necessary conditions. Therefore, providing developers and ordinary users with a unified and simplified network access service capability is a necessary support for serving Dapp developers, and it is also the infrastructure of the Polkadot ecosystem.</p>
<p>Elara's goal is to build an infrastructure and network public access service similar to Infura, to provide developers with a unified access layer with multiple connections. We will create a universal architecture that can easily access Polkadot, Kusama, various parachains and various substrate chains, that is, focus on serving Polkadot and Kusama, while maintaining scalability, and benefiting the entire Substrate ecosystem.</p>
<p>In addition, as part of the smart contract development ecosystem service, Elara will be integrated with other components of the Patract Suite in the future, and will be fully integrated in terms of contract development environment support, development tool components, contract deployment and application release, and simplify the application foundation. Architecture allows developers to focus on building upper-level applications.</p>
<p>Currently, we have provided online service elara.patract.io. The community is welcome to use Elara:
-Everyone can use Polkadot provided by Elara and the public shared RPC services of multiple ecological mainnets (such as wss://polkadot.elara.patract.io and https://polkadot.elara.patract.io).
-Developers can visit elara.patract.io to obtain exclusive online services with free access to multiple networks.</p>
<p>More information:</p>
<p>Github: <a href="https://github.com/patractlabs/elara">https://github.com/patractlabs/elara</a></p>
<p>Homepage: <a href="https://elara.patract.io">https://elara.patract.io</a></p>
<p>Docs:<a href="https://docs.elara.patract.io/">https://docs.elara.patract.io/</a></p>
<h1><a class="header" href="#tutorial-4" id="tutorial-4">Tutorial</a></h1>
<p>Elara's API requires a valid Project Endpoint to be included in your request. This identifier should be appended to the request URL.</p>
<h2><a class="header" href="#get-your-project-endpoint" id="get-your-project-endpoint">Get YOUR-PROJECT-ENDPOINT</a></h2>
<ol>
<li>
<p>Use your github account to log in <a href="https://elara.patract.io/">Elara official website</a></p>
</li>
<li>
<p>Enter <a href="https://elara.patract.io/#/dashboard/console">Elara Dashboard</a>, click to select the main chain in the left sidebar.</p>
</li>
<li>
<p>Click the &quot;Create New Project&quot; button in the upper right corner, enter &quot;PROJECT-NAME&quot; in the pop-up dialog box, and then click &quot;OK&quot;. If everything is ok, you will see a message stating that the project has been successfully created.</p>
</li>
<li>
<p>In the project list, click the project to enter the project details page
-There is a list of information showing &quot;PID&quot;, a string of characters and numbers with a length of 32, which is the &quot;YOUR-PROJECT-ID&quot; of the project
-There is a column that displays &quot;ENDPOINTS&quot; information, including &quot;https&quot; and &quot;wss&quot; for accessing ENDPOINT. That is the &quot;YOUR-PROJECT-ENDPOINT&quot; of the project</p>
</li>
</ol>
<h2><a class="header" href="#make-a-request" id="make-a-request">Make a request</a></h2>
<p>Use one of these ENDPOINT as the provider of your client program.</p>
<p><em>Note: Please be sure to replace YOUR-PROJECT-ENDPOINT with Project Endpoint in the Elara dashboard</em></p>
<ul>
<li>Method 1: curl sends an HTTP request:</li>
</ul>
<pre><code class="language-bash">#curl http
curl --location --request POST'https://YOUR-PROJECT-ENDPOINT' \
    --header'Content-Type: application/json' \
    --data-raw'{
        &quot;id&quot;:1,
        &quot;jsonrpc&quot;:&quot;2.0&quot;,
        &quot;method&quot;:&quot;chain_getBlock&quot;,
        &quot;params&quot;:[]
    }'
</code></pre>
<ul>
<li>Method 2: Use wscat to send websocket request:</li>
</ul>
<pre><code>parachain@ubuntu:~/elara$ wscat -c wss://YOUR-PROJECT-ENDPOINT
Connected (press CTRL+C to quit)
&gt; {&quot;id&quot;:1,&quot;jsonrpc&quot;:&quot;2.0&quot;,&quot;method&quot;:&quot;chain_getBlock&quot;,&quot;params&quot;:[]}
&lt;{&quot;jsonrpc&quot;:&quot;2.0&quot;,&quot;result&quot;:{&quot;block&quot;:{&quot;extrinsics&quot;:[&quot;0x280402000b901ac96e7601&quot;],&quot;header&quot;:{&quot;digest&quot;:{&quot;logs&quot;:[&quot;0x066175726120dfcdf90f00000000&quot;,&quot; 0x05617572610101acb2a4725f0f8945593cea6aa6ef70df2a8fd4a2c4eb1c0d1bf51828f26e371f897473113541f9c0d9f94e51471a3d685a86866a12133ea012d2777bb9709589 &quot;]},&quot; extrinsicsRoot &quot;:&quot; 0xcca5112546305b07d904c2aa26155dffe6c66de043708e1ac89e57609fbcc6d1 &quot;,&quot; number &quot;:&quot; 0x17922 &quot;,&quot; parentHash &quot;:&quot; 0xdb798a19707ef9085b97d0b00854c613ae4abdb560e2ea1164f2e7bbfbc288a1 &quot;,&quot; stateRoot &quot;:&quot; 0xdc575fe975067ded933020df9035db0e496143e6b9a062a4313fd1f6e9d02922 &quot;}},&quot; justification &quot;: null},&quot; id &quot;: 1}
&gt;
</code></pre>
<ul>
<li>Method 3: Use SDK</li>
</ul>
<p>You can refer to polkadot-js and use the following similar code to access the node through Https or Websocket:</p>
<pre><code class="language-javascript">const {ApiPromise, WsProvider} = require('@polkadot/api');
const {HttpProvider} = require('@polkadot/rpc-provider');

(async function () {
// Http
const httpProvider = new HttpProvider('https://YOUR-PROJECT-ENDPOINT')
const hash = await httpProvider.send('chain_getBlockHash', [])
console.log('latest block Hash', hash)

// Websocket
const wsProvider = new WsProvider('wss://YOUR-PROJECT-ENDPOINT')
const api = await ApiPromise.create({ provider: wsProvider })
//Do something

})()
</code></pre>
<p>It is important to note that JSON-RPC requests have nothing to do with transmission, and the same request can be made via HTTPS and Websockets.</p>
<h1><a class="header" href="#design-brief" id="design-brief">Design Brief</a></h1>
<p>Elara has long-term development iteration planning and operation and maintenance goals, in order to be able to support the continuous transition of Polkadot ecological developers from the 10,000+ level to the 100 million+ level. The core of Elara is a set of high-performance, high-availability and high-scalability distributed architecture. It is significantly different from other projects that provide Node API Service:</p>
<ol>
<li>
<p>Elara's back-end architecture is not a simple but inefficient NodePool+LoadBalancer. This solution cannot bear the impact of large-scale applications and traffic, and cannot be expanded in time, because Node will become a significant bottleneck in the system. In Elara's architecture, only a small number of Nodes are required to provide basic data sources. Elara supports the access of a large number of users through the design of distributed architecture, the integration of multiple services, and the ultimate optimization of request access paths. The short-term development cost of the NodePool solution is low, but the unit cost of long-term service to users is extremely high. Conversely, Elara’s initial investment in technology costs is relatively high, but in the long term it can greatly reduce the unit cost of serving users, while also ensuring high service quality.</p>
</li>
<li>
<p>Elara focuses on providing a minimalist full-featured experience for ecological developers. What we provide is an extremely &quot;thin&quot; layer of service, and we hope that developers will not feel the existence of Elara. The API service provided by Elara not only includes all the functions of the node, but also includes the historical status data function, but also includes the project's request statistics dashboard and other functions. The service capabilities provided to developers are far greater than the capabilities provided by the deployment of nodes by themselves. Therefore, under this goal, functions such as &quot;one-click node deployment&quot; are very redundant, and developers should only focus on their own business applications.</p>
</li>
<li>
<p>Elara is an open platform, upholding the principle of community building. In the next iteration of the version, we will continue to access more mainnets and establish a set of process specifications for the automatic access of the Polkadot ecological main chain and parachain.</p>
</li>
</ol>
<p>In terms of overall design, Elara is designed as a microservice architecture system consisting of multiple microservices that can be independently extended. All microservices run as independent processes after they are started, so in the future, individual microservices can be upgraded in parallel, such as expansion, reconstruction, replacement implementation, and so on. Among them, <code>Redis</code> is used as a storage container for high-speed data access, and is decoupled from the use of <code>kafka</code> for architecture. In the future, it will be easy to add more complex functional modules based on this design to let Elara play a more powerful effect.</p>
<p>The core architecture of Elara is roughly as follows</p>
<p><img src="https://user-images.githubusercontent.com/21072025/111115173-35923280-859f-11eb-8172-737c07aab4e7.png" alt="elara" /></p>
<h1><a class="header" href="#api-access" id="api-access">API access</a></h1>
<h2><a class="header" href="#endpoint-rules" id="endpoint-rules">ENDPOINT Rules</a></h2>
<p><code>Https</code> access</p>
<pre><code>https://api.elara.patract.io/&lt;Network&gt;/&lt;YOUR-PROJECT-ID&gt;
</code></pre>
<p><code>Websocket</code> access</p>
<pre><code>wss://api.elara.patract.io/&lt;Network&gt;/&lt;YOUR-PROJECT-ID&gt;
</code></pre>
<h2><a class="header" href="#support-network" id="support-network">Support network</a></h2>
<table><thead><tr><th><strong>NETWORK</strong></th><th><strong>DESCRIPTION</strong></th><th>ENDPOINT</th></tr></thead><tbody>
<tr><td>Polkadot</td><td>JSON-RPC over HTTPS</td><td>https://api.elara.patract.io/Polkadot/YOUR-PROJECT-ID</td></tr>
<tr><td>Polkadot</td><td>JSON-RPC over WebSocket</td><td>wss://api.elara.patract.io/Polkadot/YOUR-PROJECT-ID</td></tr>
<tr><td>Kusama</td><td>JSON-RPC over HTTPS</td><td>https://api.elara.patract.io/Kusama/YOUR-PROJECT-ID</td></tr>
<tr><td>Kusama</td><td>JSON-RPC over WebSocket</td><td>wss://api.elara.patract.io/Kusama/YOUR-PROJECT-ID</td></tr>
<tr><td>Rococo</td><td>JSON-RPC over HTTPS</td><td>https://api.elara.patract.io/Rococo/YOUR-PROJECT-ID</td></tr>
<tr><td>Rococo</td><td>JSON-RPC over WebSocket</td><td>wss://api.elara.patract.io/Rococo/YOUR-PROJECT-ID</td></tr>
<tr><td>Jupiter</td><td>JSON-RPC over HTTPS</td><td>https://api.elara.patract.io/Jupiter/YOUR-PROJECT-ID</td></tr>
<tr><td>Jupiter</td><td>JSON-RPC over WebSocket</td><td>wss://api.elara.patract.io/Jupiter/YOUR-PROJECT-ID</td></tr>
<tr><td>Darwinia</td><td>JSON-RPC over HTTPS</td><td>https://api.elara.patract.io/Darwinia/YOUR-PROJECT-ID</td></tr>
<tr><td>Darwinia</td><td>JSON-RPC over WebSocket</td><td>wss://api.elara.patract.io/Darwinia/YOUR-PROJECT-ID</td></tr>
<tr><td>Dock</td><td>JSON-RPC over HTTPS</td><td>https://api.elara.patract.io/Dock/YOUR-PROJECT-ID</td></tr>
<tr><td>Dock</td><td>JSON-RPC over WebSocket</td><td>wss://api.elara.patract.io/Dock/YOUR-PROJECT-ID</td></tr>
<tr><td>Edgeware</td><td>JSON-RPC over HTTPS</td><td>https://api.elara.patract.io/Edgeware/YOUR-PROJECT-ID</td></tr>
<tr><td>Edgeware</td><td>JSON-RPC over WebSocket</td><td>wss://api.elara.patract.io/Edgeware/YOUR-PROJECT-ID</td></tr>
<tr><td>Kulupu</td><td>JSON-RPC over HTTPS</td><td>https://api.elara.patract.io/Kulupu/YOUR-PROJECT-ID</td></tr>
<tr><td>Kulupu</td><td>JSON-RPC over WebSocket</td><td>wss://api.elara.patract.io/Kulupu/YOUR-PROJECT-ID</td></tr>
<tr><td>Nodle</td><td>JSON-RPC over HTTPS</td><td>https://api.elara.patract.io/Nodle/YOUR-PROJECT-ID</td></tr>
<tr><td>Nodle</td><td>JSON-RPC over WebSocket</td><td>wss://api.elara.patract.io/Nodle/YOUR-PROJECT-ID</td></tr>
<tr><td>Plasm</td><td>JSON-RPC over HTTPS</td><td>https://api.elara.patract.io/Plasm/YOUR-PROJECT-ID</td></tr>
<tr><td>Plasm</td><td>JSON-RPC over WebSocket</td><td>wss://api.elara.patract.io/Plasm/YOUR-PROJECT-ID</td></tr>
<tr><td>Stafi</td><td>JSON-RPC over HTTPS</td><td>https://api.elara.patract.io/Stafi/YOUR-PROJECT-ID</td></tr>
<tr><td>Stafi</td><td>JSON-RPC over WebSocket</td><td>wss://api.elara.patract.io/Stafi/YOUR-PROJECT-ID</td></tr>
<tr><td>Chainx</td><td>​​JSON-RPC over HTTPS</td><td>https://api.elara.patract.io/Chainx/YOUR-PROJECT-ID</td></tr>
<tr><td>Chainx</td><td>​​JSON-RPC over WebSocket</td><td>wss://api.elara.patract.io/Chainx/YOUR-PROJECT-ID</td></tr>
<tr><td>Mandala</td><td>JSON-RPC over HTTPS</td><td>https://api.elara.patract.io/Mandala/YOUR-PROJECT-ID</td></tr>
<tr><td>Mandala</td><td>JSON-RPC over WebSocket</td><td>wss://api.elara.patract.io/Mandala/YOUR-PROJECT-ID</td></tr>
</tbody></table>
<h2><a class="header" href="#error-code" id="error-code">error code</a></h2>
<p>If the Substrate RPC method encounters an error, the error member contained in the response object must be an object containing code members and descriptive message members. The following list contains all possible error codes and associated messages:</p>
<table><thead><tr><th><strong>CODE</strong></th><th><strong><strong>MEANING</strong></strong></th><th><strong>CATEGORY</strong></th></tr></thead><tbody>
<tr><td>-32700</td><td>Parse error</td><td>Invalid JSON</td></tr>
<tr><td>-32600</td><td>Invalid request</td><td>JSON is not a valid request object</td></tr>
<tr><td>-32601</td><td>Method not found</td><td>Method does not exist</td></tr>
<tr><td>-32602</td><td>Invalid params</td><td>Invalid method parameters</td></tr>
<tr><td>-32603</td><td>Internal error</td><td>Internal JSON-RPC error</td></tr>
<tr><td>-1</td><td>CheckAuthenticated Fail</td><td>non-standard</td></tr>
<tr><td>-2</td><td>Project Name Empty</td><td>non-standard</td></tr>
<tr><td>-3</td><td>Project Name Error!</td><td>non-standard</td></tr>
<tr><td>-4</td><td>Chain Error</td><td>non-standard</td></tr>
<tr><td>-5</td><td>Out Of Limit</td><td>non-standard</td></tr>
<tr><td>-6</td><td>NotActive</td><td>non-standard</td></tr>
<tr><td>-7</td><td>RPC Error</td><td>non-standard</td></tr>
<tr><td>-8</td><td>Project Error</td><td>non-standard</td></tr>
<tr><td>-9</td><td>No Access Allowed</td><td>non-standard</td></tr>
<tr><td>-10</td><td>Black Uid</td><td>non-standard</td></tr>
<tr><td>-11</td><td>Duplicate Name</td><td>non-standard</td></tr>
</tbody></table>
<h2><a class="header" href="#introduction-2" id="introduction-2">Introduction</a></h2>
<p>PatraStore embeds Dapp through iFrame, PatraStore will provide Dapp with Signer and Provider functions.</p>
<p>Reading this document requires a certain understanding of <a href="https://polkadot.js.org/docs/">pokadot-js</a>.</p>
<h2><a class="header" href="#overview-1" id="overview-1">Overview</a></h2>
<p>The communication between PatraStore and Dapp uses PostMessage to communicate. For the convenience of developers, we provide a set of SDK. This set of SDK implements the protocol in <a href="https://github.com/polkadot-js/extension">polkadot-js/extension</a>, so our SDK can be fully compatible with [@polkadot/extension-dapp](https ://www.npmjs.com/package/@polkadot/extension-dapp).</p>
<p>Developers can easily import PatraStore's SDK. We provide CDN service to host the SDK. You only need to include <code>&lt;script type=&quot;text/javascript&quot; src=&quot;https://static.patrastore.io/sdk in the code. /store-sdk.min.js&quot;&gt;&lt;/script&gt;</code>.</p>
<h2><a class="header" href="#getting-started" id="getting-started">Getting started</a></h2>
<p>First of all, please make sure you include <code>&lt;script type=&quot;text/javascript&quot; src=&quot;https://static.patrastore.io/sdk/store-sdk.min.js&quot;&gt;&lt;/script&gt;</code> in the html, In order to ensure that the SDK can work normally, you need to quote it before the business code. A better way is to put it in the <code>head</code> tag of html.</p>
<p>Make sure you have a certain understanding of the <a href="https://polkadot.js.org/docs/extension">document</a> of <code>@polkadot/extension-dapp</code>, we will also post a demo below.</p>
<p>Install the corresponding dependencies. <code>yarn add @polkadot/extension-dapp</code>.</p>
<h3><a class="header" href="#request-user-authorization" id="request-user-authorization">Request user authorization</a></h3>
<p>**This step is before all the following operations are called. **</p>
<pre><code class="language-typescript">import {web3Enable} from'@polkadot/extension-dapp';

await web3Enable();
</code></pre>
<h3><a class="header" href="#get-injected" id="get-injected">Get Injected</a></h3>
<pre><code class="language-typescript">import {web3FromSource} from'@polkadot/extension-dapp';

// The injected name of PatraStore is store
const injected = await web3FromSource('store');
</code></pre>
<h3><a class="header" href="#signer" id="signer">Signer</a></h3>
<pre><code class="language-typescript">const signer = injected.signer;
</code></pre>
<p>After obtaining the Signer, you can use the signer to retrieve the signature of PatraStore</p>
<h3><a class="header" href="#provideroptional" id="provideroptional">Provider(Optional)</a></h3>
<p>The Provider we provide is implemented based on PostMessage. To ensure that Dapp and PatraStore are connected to the same chain, it is recommended that you use this method to instantiate the Provider.</p>
<pre><code class="language-typescript">import type { ProviderInterface } from '@polkadot/rpc-provider/types';
import { WsProvider } from '@polkadot/rpc-provider';
import { web3ListRpcProviders, web3UseRpcProvider } from '@polkadot/extension-dapp';

let provider: ProviderInterface;
const providers = await web3ListRpcProviders('store');
if (providers &amp;&amp; Object.keys(providers).length &gt; 0) {
  provider = (await web3UseRpcProvider('store', Object.keys(providers)[0])).provider;
} else {
  provider = new WsProvider(url);
}
</code></pre>
<h3><a class="header" href="#init-api" id="init-api">Init Api</a></h3>
<p>After the above steps, we have obtained Provider and Signer. Below is a complete example of instantiating <code>ApiPromise</code>.</p>
<pre><code class="language-typescript">import type { ProviderInterface } from '@polkadot/rpc-provider/types';

import { ApiPromise } from '@polkadot/api/promise';
import { WsProvider } from '@polkadot/rpc-provider';
import { web3Enable, web3FromSource, web3ListRpcProviders, web3UseRpcProvider } from '@polkadot/extension-dapp';

async function initApi(): ApiPromise {
  await web3Enable();

  let provider: ProviderInterface;
  const providers = await web3ListRpcProviders('store');
  if (providers &amp;&amp; Object.keys(providers).length &gt; 0) {
    provider = (await web3UseRpcProvider('store', Object.keys(providers)[0])).provider;
  } else {
    provider = new WsProvider(url);
  }

  const { signer } = await web3FromSource('store');

  return new ApiPromise({
    provider,
    signer,
    // Jupiter types
    types: {
      &quot;LookupSource&quot;: &quot;MultiAddress&quot;,
      &quot;Address&quot;: &quot;MultiAddress&quot;,
      &quot;FullIdentification&quot;: &quot;AccountId&quot;,
      &quot;AuthorityState&quot;: {
        &quot;_enum&quot;: [
          &quot;Working&quot;,
          &quot;Waiting&quot;
        ]
      },
      &quot;EraIndex&quot;: &quot;u32&quot;,
      &quot;ActiveEraInfo&quot;: {
        &quot;index&quot;: &quot;EraIndex&quot;,
        &quot;start&quot;: &quot;Option&lt;u64&gt;&quot;
      },
      &quot;UnappliedSlash&quot;: {
        &quot;validator&quot;: &quot;AccountId&quot;,
        &quot;reporters&quot;: &quot;Vec&lt;AccountId&gt;&quot;
      }
    }
  })
}

const api: ApiPromise = await initApi();
</code></pre>
<h3><a class="header" href="#more-usage" id="more-usage">More usage</a></h3>
<p>Please refer to <a href="https://polkadot.js.org/docs/extension">https://polkadot.js.org/docs/extension</a></p>
<h2><a class="header" href="#publish-dapp" id="publish-dapp">Publish DApp</a></h2>
<p>Currently we do not support hosting DApps. Developers need to deploy DApps and upload information (domain name, type, picture, account, etc.) on PatraStore.</p>
<p>Make sure that the front end of the DApp you develop includes our <a href="patra-store/./getting-starter.html">SDK</a>, otherwise the DApp will not work properly in PatraStore.</p>
<ol>
<li>Enter <a href="https://patrastore.io/jupiter-a1/system/developer">https://patrastore.io/:chain-value/system/developer</a> page</li>
<li>Click the Publish DApp button
<img src="patra-store/./imgs/publish.png" alt="" />
<img src="patra-store/./imgs/publish-form.png" alt="" /></li>
<li>Select Account and fill in the basic information of the DApp</li>
<li><strong>Add meta tag to html</strong>
<pre><code class="language-html">&lt;!-- The accountId must be the same as the account address you selected. We will check the meta tag at intervals in the background. If the accountId and the account address are inconsistent, the DApp will become Offline --&gt;
&lt;meta name=&quot;patrastore:verify&quot; content=&quot;accountId&quot;&gt;
</code></pre>
</li>
<li>Click the <code>Publish</code> button, and if the information filled above is correct, the DApp can be successfully published.</li>
</ol>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
